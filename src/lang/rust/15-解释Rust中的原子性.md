# 解释 Rust 中的原子性

[原文](https://cfsamsonbooks.gitbook.io/explaining-atomics-in-rust/)

> 当处理原子性以及内存排序选项时理解它们可以帮助我们更好的理解多线程编程以及为什么 Rust 可以帮助我们编写安全高性能的多线程代码。

---

尝试通过阅读随机的文章或者 Rust (或 C++) 中的文档来理解原子性，就像是通过逆向工程`E = MC^2`来学物理一样。

我将会在本文中尽最大的努力来向你我解释这个概念。如果我成功了，比例将会是`WTF?/AHA! < 1`。

---

## 多处理器编程

当我们为多个 CPU 编写代码时，有一些细微的 (subtle) 的事情需要考虑。你将看到，如果编译器或 CPU 认为重排我们编写的代码可以获得更快的执行速度，它们就会这么做。在单线程的程序中，我们不需要考虑什么，但是一旦我们开始编写多线程程序时，编译器重排可能就会给我们带来问题。

然而，虽然编译器的顺序可以通过查看反汇编的代码进行检查，当系统运行在多个 CPU 之上时，事情可能会变得更加复杂。

当线程在不同的 CPU 上运行时，CPU 内部的指令重排可以导致一些难以调试的问题，因为我们大多数时候观察的只是 CPU 重排，执行推断 (speculative)，流水线 (pipeline) 以及缓存的副作用。

我也不认为 CPU 可以提前知道它将如何运行你的代码。

> 原子性解决的问题与内存的加载与存储有关。任何不会操作共享内存的指令重排都不会对我们关心的内容产生影响。 
>
> 除非另有说明，否则我在这里将使用一个主要参考：[Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)。因此当我说参考了 Intel 开发人员参考手册的某一章节，便指的是这篇文章。

让我们从最底层开始，用适合我们的方式来获取更好的理解。

---

## 强 vs 弱内存排序

首先，我们需要正确的理解一些概念。在处理内存方面，CPU 提供了不同的保证。我们可以将其区分为从弱 (Weak) 到强 (Strong)。但是，这不是一个精确的规范，因此有些模型介于两者之间。

为了抽象这些差异，Rust 有一个[抽象机](http://www.stroustrup.com/abstraction-and-machine.pdf)的概念。它从 C++ 中借用了这个模型。这个抽象机需要一个抽象，它可以针对弱 CPU 和强 CPU (以及介于两者之间的状态)编程。

你可以看到，[C++ 抽象机](https://people.mpi-sws.org/~viktor/papers/cpp2015-invited.pdf)指定了很多访问内存的方式。如果我们在相同语言中针对强弱处理器应该使用相同的语义，则必须使用这些访问内存的方式。

具有强内存模型的 CPU 提供了一些重要的保证，让我们在抽象机中使用的语义不会做任何操作。这一点也不花哨，这仅是对编译器的提示，让其不要对程序员编写的内存操作顺序做任何改变。

然而在使用弱内存模型的系统中，可能需要设置内存栏栅或使用特殊的指令来防止同步问题。根据经验学习这种抽象机的最好方式是使用具有弱有序的 CPU。然而，因为大多数程序员都是在具有强内存模型的 CPU 上编程，因此我们将只需要指出差异就可以理解为什么该语义是它们表现的那样。

目前大多数使用 AMD 或 Intel 处理器的电脑都使用强有序。这就意味着 CPU 会保证不会重排确定的操作顺序。可以在 [Intel 开发人员手册](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)第 8.2.2 节找到这个保证的相关示例。

> - 读操作不会和其他读操作重新排序。
> - 写操作不会和旧的读操作重新排序。
> - 写内存操作不会和其他(带有异常的)写操作重新排序。

重要的是，它还包含一个不受保证的示例：

> - 读操作可能会与旧的写到不同地址的操作重新排序，但是不会与写到相同地址的操作重新排序。

最后一个示例对于理解后面的`SeqCst`内存排序至关重要，现在这里只是为它做个说明。

现在，在之后的章节，我将会试图理清它们的差异。但是我仍将使用抽象机的弱模型作为解释的基础...

> ⚠️ 我将指出使用这个提示的强有序 CPU 的差异。

---

## CPU 缓存

通常，一个 CPU 有三种级别的缓存：L1，L2，L3。其中 L2 和 L3在各个核心之间共享，L1 是每个核心的缓存。我们的挑战就在这里开始。


L1 缓存使用了某种 [MESI 缓存协议](https://en.wikipedia.org/wiki/MESI_protocol)。名字听起来可能很神秘，但是该协议其实很简单。它是缓存中以下不同状态的首字母缩写 (acronym)：

```console
这些状态适用于 L1 缓存中的每一个缓存行：

(M) Modified - 修改(脏数据)。需要将数据写回主内存。
(E) Exclusive - 只存在 L1 缓存中。不需要被同步(清理)。
(S) Shared - 可能存在其他的缓存中。目前与主内存一起使用。
(I) Invalid - 缓存行是无效的。其他缓存可能会将其修改。
```

> 在 [Intel 开发者手册](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)的第 11.4 节中，有更多关于缓存状态的描述。

我们可以通过对 CPU 中的每一个缓存行分配一个带有四种状态的枚举，对 L1 缓存进行建模。

> **这听起来是不是很熟悉？**  
> 
> 在 Rust 中我们有两种类型的引用 & 共享引用 (shared references) 和 &mut 独占引用(exclusive references)。
> 
> 如果你不再将它们视为`mutable`和`immutable`，这将对你有很大的帮助。因为并非一直如此。允许内部可变性 (interior mutability) 的原子和类型确实打破了这种心智模型。相反，我们应当将它们视为`exclusive`和`shared`。
> 
> 这确实可以很好的映射到 E 和 S (L1 缓存中可能存在的两种状态数据)。在语言中对其进行建模可以很好的提供一些优化，而其他不存在这些语义的语言却无法做到。
> 
> 在 Rust 中，只有内存是`Exclusive`且默认可以被修改。
>
> 这意味着，只要我们不会打破规则以及可变的共享引用，所有的 Rust 程序可以假设运行在核心上的 L1 缓存是最新的，不需要做任何同步。
>
> 当然，许多程序需要在核心之间共享内存才能工作，但是明确并谨慎这么做可以更好的让代码在多处理器上运行。

---

## 处理器之间的通信

如果我们确实想要访问并改变共享内存，其他的核心是如何知道它们的 L1 缓存是非法的呢？

如果数据存在不同核心的 L1 缓存中(请记住，它处于`Shared`状态)并被修改时，缓存行是无效的。为了通知其他核心它们的缓存数据是无效的，就必须有一些可以在核心之间通信的方式，对吗？

是的，确实如此，但是，很难找到有关确切详细信息的文档。每个核心都有一个我们可以当作邮箱的东西。

这个邮箱可以缓存一定数量的消息。