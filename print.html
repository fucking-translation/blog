<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blog Translation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">6.</strong> Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">7.</strong> Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">8.</strong> 图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">10.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">11.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">12.</strong> Rust 的 Pin 与 Unpin</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="用rust学习解析器组合器"><a class="header" href="#用rust学习解析器组合器">用Rust学习解析器组合器</a></h1>
<h4 id="a-hrefhttpsbodillolparser-combinators原文a"><a class="header" href="#a-hrefhttpsbodillolparser-combinators原文a"><a href="https://bodil.lol/parser-combinators/">原文</a></a></h4>
</br>
<p><a href="lang/rust/01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html#%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E6%83%B3%E6%B3%95">1. 初学者的想法</a><br />
<a href="lang/rust/01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html#%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%9C%AC%E6%96%87">2. 如何阅读本文</a><br />
<a href="lang/rust/01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html#Xcruciating%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">3. <code>Xcruciating</code>标记语言</a><br />
<a href="lang/rust/01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html#%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90%E5%99%A8">4. 定义解析器</a><br />
<a href="lang/rust/01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html#%E6%88%91%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%90%E5%99%A8">5. 我们的第一个解析器</a></p>
<p>本文向已是 Rust 程序员的人们传授解析器组合器的基础知识。它假定不涉及其他知识，并将解释与 Rust 没有直接关系的所有内容，以及为达到此目的使用 Rust 的一些令人意外的特性。如果你不了解 Rust，他不会教你 Rust 的内容，但是这样的话，同样也无法更好的教你解析器和组合器的知识。如果你想要学习 Rust 语言，我推荐  <a href="https://doc.rust-lang.org/book/">Rust编程语言</a> 这本书。</p>
<h2 id="初学者的想法"><a class="header" href="#初学者的想法">初学者的想法</a></h2>
<p>当每个程序员发现自己需要解析器时，它们的生活将变得有意义。</p>
<p>初学者程序员将会问：“什么是解析器？”。<br />
中级程序员将会说：“这很简单，我将写一串正则表达式”。<br />
高级程序员将会说：“退一步考虑问题，我知道<code>Lex</code>（词法分析器）和<code>Yacc</code>（语法解析器）”</p>
<p>初学者的想法是正确的。</p>
<p>不是说正则表达式不好（但是请不要用正则表达式写复杂的解析器）。使用经过数千年磨练至完美的解析器和词法分析生成器之类的强大工具并不是没有乐趣可言。但是从头开始一点一点学习解析器将更有趣。这两者只是对当前实际问题的抽象，如果你直接选择正则表达式或者解析器生成工具，你将失去这一份乐趣。在初学者眼中，正如人们说的：本来（解决这个问题）有很多种方法，但是在专家眼里，已经形成思维定视，只会选择一种他们最习惯的方式。
在本文中我们将从头开始学习如何构建解析器，基于被称为解析器组合器的函数式编程语言的通用技术。一旦你掌握了它们的基本概念，它们的优势将非常巨大，同时又非常接近第一原理。因为这里唯一的抽象是你将在基础的组合器之上构建你自己的抽象。所有这些，你必须先构建它们，才能使用它们。</p>
<h2 id="如何阅读本文"><a class="header" href="#如何阅读本文">如何阅读本文</a></h2>
<p>强烈建议你初始化一个 Rust 项目，并且在<code>src/lib.rs</code>中书写你阅读到的代码片段（你可以直接从页面上直接复制，但是最好还是自己手敲，因为这样会自动确保你完整阅读代码）。本文将按序介绍你需要的每段代码。请注意，有时会引入你先前编写功能的最新版本，这时，你需要将旧版本替换为新版本。</p>
<p>该代码是使用 2018 年语言版本的<code>rustc</code>的 1.34.0 版本编写的。你应该尽可能使用最新版本的编译器，只要你确保你使用的是 2018 的版本即可（检查<code>Cargo.toml</code>文件中是否包含<code>edition = &quot;2018&quot;</code>）。代码不需要任何的外部依赖。</p>
<p>如果要运行本文中的测试用例，请执行<code>cargo test</code>。</p>
<h2 id="xcruciating标记语言"><a class="header" href="#xcruciating标记语言"><code>Xcruciating</code>标记语言</a></h2>
<p>我们将用简化的XML格式写一个解析器，如下所示：</p>
<pre><code class="language-xml">&lt;parent-element&gt;
  &lt;single-element attribute=&quot;value&quot; /&gt;
&lt;/parent-element&gt;
</code></pre>
<p>XML元素使用<code>&lt;</code>符号开头和一个由字母组成的标志符开头，后面可以根任意数量的字母，数字和<code>-</code>。后面跟一些空格，以及一些属性对的可选列表：前面定义一个标识符，后面跟一个<code>=</code>符号和一个双引号字符串，最后以<code>/&gt;</code>结尾来表示一个没有子节点的单个元素。或者用<code>&gt;</code>表示后面跟了一串子节点，最终是一个以<code>&lt;/</code>开头的结束标签，后跟一个必须与开始标识匹配的标志符，然后以<code>&gt;</code>结束。</p>
<p>这就是我们将要支持的特性。没有命名空间，没有文本节点，其余的都没有，并且没有模式校验。我们甚至都不会自寻烦恼，去实现字符串的转义引号（<code>\&quot;</code>） - 它们由第一个双引号开始，到下一个双引号结束，就是这样。如果你想在实际字符串中使用双引号，你可以将这个不合理的要求转移到其他地方。</p>
<p>我们将用下面的结构体来解析这些元素。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String,
    attributes: Vec&lt;(String, String)&gt;,
    children: Vec&lt;Element&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>没有花哨的类型，仅仅用字符串表示名称（那是每个标签开始的标志符），用字符串元组表示属性（标志符和对应的值），还有一个看起来和父元素完全一样的子元素列表。</p>
<p>（如果你正在输入，请加上那一系列的<code>derive</code>，你将在后面用到它们）。</p>
<h2 id="定义解析器"><a class="header" href="#定义解析器">定义解析器</a></h2>
<p>好了，是时候编写解析器了。</p>
<p>解析是从数据流中派生结构的过程。解析器就是要弄清楚该结构的工具。</p>
<p>在我们即将探索的知识中，解析器最简单的一种形式就是一个函数，该函数接受一些输入并返回解析后的输出以及输入的其余部分，或者是一个错误信息：“我无法解析该输入”。</p>
<p>事实证明，简而言之，更复杂的解析器看起来也是如此。如果你要获取友好的错误提示，你可能会使输入，输出和错误的含义复杂化，但是解析器的特征依然如此：消费输入并产生解析后的数据以及输入的其余部分，或者会让你知道无法将输入解析成输出。</p>
<p>让我们将其（解析器）写成函数的形式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Fn(Input) -&gt; Result&lt;(Input, Output), Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>更具体的说，就我们而言，我们希望可以填充这些类型，就像下面代码块所示。因为我们要做的是将一个字符串转化为<code>Element</code>结构体，并且在这方面我们不想陷入错综复杂的错误提示中，所以当我们不能够解析输入的字符串时，只需返回一段提示错误的字符串即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Fn(&amp;str) -&gt; Result&lt;(&amp;str, Element), &amp;str&gt;
<span class="boring">}
</span></code></pre></pre>
<p>我们使用字符串切片（<code>&amp;str</code>），是因为他是指向字符串的有效指针。我们可以进一步对其进行切片，通过切掉已解析的部分来消耗输入，并将余下的输入和结果一起返回。</p>
<p>可能使用<code>&amp;[u8]</code>类型作为输入（一串字节数组，如果将输入的字节限制在<code>ASCII</code>范围内，则<code>u8</code>和<code>char</code>相对应）会看起来更加干净，尤其是字符串切片（<code>&amp;str</code>）的行为和大多数切片的行为有所不同。你不能够通过一个数字来检索它们，你必须使用一个分片<code>input[0..1]</code>。另一方面，它们对于解析字符串有很多有用的函数，而字节切片没有。</p>
<p>事实上，我们通常都需要依赖这些函数而不是像<code>input[0]</code>这样对他进行索引。因为 Rust 的字符串是<code>UTF-8</code>格式的，这些索引并不总是对应于单个字符，所以对于我们来说，让标准库为我们处理这些问题更好。</p>
<h2 id="我们的第一个解析器"><a class="header" href="#我们的第一个解析器">我们的第一个解析器</a></h2>
<p>让我们来一起写一个解析器，只需要关注字符串中的第一个字符并判断它是否是字母<code>a</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn the_letter_a(input: &amp;str) -&gt; Result&lt;(&amp;str, ()), &amp;str&gt; {
  match input.chars().next() {
      Some('a') =&gt; Ok((&amp;input['a'.len_utf8()..], ())),
      _ =&gt; Err(input),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们来看一下输入和输入和输出的类型：和上面讨论的一样，我们让字符串切片作为输入，并返回携带<code>(&amp;str, ())</code>元组或者错误类型<code>&amp;str</code>的<code>Result</code>。<code>(&amp;str, ())</code>元组比较有趣：正如我们所说的，我们想要返回一个包含下一次待解析的输入和输出。<code>&amp;str</code>是下一次输入，解析返回的结果仅仅是一个单元类型<code>()</code>。因为如果解析成功，只可能有一种结果（我们找到了字母<code>a</code>），但是这里我们并不需要返回字母<code>a</code>，我们只需要告诉调用者我们成功发现了字母<code>a</code>即可。</p>
<p>然后，让我们看下解析器本身的代码。我们从提取输入的第一个字符开始：<code>input.chars().next()</code>。依靠标准库来避免带来的 Unicode 编码问题并不是在开玩笑 - 我们要求它为字符串的字符提供一个<code>chars()</code>迭代器，然后从中取出第一项。该项是封装在<code>Option</code>中的<code>char</code>类型，因此是<code>Option&lt;char&gt;</code>，如果它的值为<code>None</code>则表示我们尝试在空字符串中提取一个<code>char</code>。</p>
<p>更糟的是，<code>char</code>可能并不是你想的那样是 Unicode 字符。</p>
<h1 id="用rust编写llvm的玩具编译器"><a class="header" href="#用rust编写llvm的玩具编译器">用Rust编写LLVM的玩具编译器</a></h1>
<h4 id="a-hrefhttpsblogulysseioposta-toy-front-end-for-llvm-written-in-rust原文a"><a class="header" href="#a-hrefhttpsblogulysseioposta-toy-front-end-for-llvm-written-in-rust原文a"><a href="https://blog.ulysse.io/post/a-toy-front-end-for-llvm-written-in-rust/">原文</a></a></h4>
</br>
<p>我目前的副业是用Rust编写一个可以将代码转换成LLVM IR的编译器。LLVM的API对于新手（noobs）来说有点令人生畏（daunting），而且没有很多有关的教程（有限的教程大多数还是基于C++的，如何使用Rust做同样的事并不总是那么明确）。我希望当我准备做一件事情时，有人可以手把手的教我，这也是我要写这篇文章的原因。</p>
<p>对于Rust，与LLVM的接口交互的最佳选择是使用<code>llvm-sys</code>。互联网上的一些热心朋友在<a href="http://rustdoc.taricorp.net/llvm-sys/llvm_sys/">这里</a>托管了一些关于<code>llvm-sys</code>的文档。当然，你还应该去查看LLVM的<a href="http://llvm.org/docs/tutorial/LangImpl01.html">官方指南</a>，因为它可以帮助你理解LLVM是如何“思考”的。这篇文章基本上是LLVM官方指南的Rust翻译。</p>
<p>你可以从这里获取最终的<a href="https://github.com/ucarion/llvm-rust-getting-started">代码</a>。</p>
<h2 id="搭建开发环境"><a class="header" href="#搭建开发环境">搭建开发环境</a></h2>
<p>对于新手，使用LLVM开发有一个可以复用的方式：</p>
<pre><code class="language-shell"># `curl` is just so we can next install Rust
sudo apt-get -y install clang curl llvm-3.8-dev
curl https://sh.rustup.rs -sSf | sh

# The `llvm-sys` crate expects something called `llvm-config` on your PATH.
sudo ln -s /usr/bin/llvm-config-3.8 /usr/bin/llvm-config
</code></pre>
<p>如果你是在Ubuntu上执行上面的语句（你可能需要执行<code>apt-get update</code>），你就可以继续了。如果不是，你需要使用下面的<code>Vagrantfile</code>文件在Vagrant Box中运行上述语句。</p>
<pre><code class="language-shell">Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;bento/ubuntu-16.04&quot;
end
</code></pre>
<p>你可以从执行<code>cargo init llvm-example --bin</code>开始，并将下面（从llvm-sys中拷贝）的代码写入<code>src/main.rs</code>中：</p>
<pre><pre class="playground"><code class="language-rust">//! Construct a function that does nothing in LLVM IR.

extern crate llvm_sys as llvm;

use std::ptr;

fn main() {
    unsafe {
        // Set up a context, module and builder in that context.
        let context = llvm::core::LLVMContextCreate();
        let module = llvm::core::LLVMModuleCreateWithName(b&quot;nop\0&quot;.as_ptr() as *const _);
        let builder = llvm::core::LLVMCreateBuilderInContext(context);

        // Get the type signature for void nop(void);
        // Then create it in our module.
        let void = llvm::core::LLVMVoidTypeInContext(context);
        let function_type = llvm::core::LLVMFunctionType(void, ptr::null_mut(), 0, 0);
        let function = llvm::core::LLVMAddFunction(module, b&quot;nop\0&quot;.as_ptr() as *const _, function_type);

        // Create a basic block in the function and set our builder to generate
        // code in it.
        let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function,b&quot;entry\0&quot;.as_ptr() as *const _);
        llvm::core::LLVMPositionBuilderAtEnd(builder, bb);

        // Emit a `ret void` into the function
        llvm::core::LLVMBuildRetVoid(builder);

        // Dump the module as IR to stdout.
        llvm::core::LLVMDumpModule(module);

        // Clean up. Values created in the context mostly get cleaned up there.
        llvm::core::LLVMDisposeBuilder(builder);
        llvm::core::LLVMDisposeModule(module);
        llvm::core::LLVMContextDispose(context);
    }
}
</code></pre></pre>
<p>并在你的<code>Cargo.toml</code>文件中：</p>
<pre><code class="language-toml">[package]
name = &quot;llvm-example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Ulysse Carion &lt;ulysse@ulysse.io&gt;&quot;]

[[bin]]
name = &quot;main&quot;

[dependencies]
llvm-sys = &quot;0.2&quot;
</code></pre>
<p>你可以获得：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cargo run
   Compiling llvm-example v0.1.0 (file:///vagrant)
     Running `target/debug/main`
; ModuleID = 'nop'

define void @nop() {
entry:
  ret void
}
</code></pre>
<p>完美！现在我们可以开始编写自己的东西了。</p>
<h2 id="一个不太平凡的程序"><a class="header" href="#一个不太平凡的程序">一个不太平凡的程序</a></h2>
<p>首先，让我们编译一个程序，该程序通过从main函数中返回一个整数来简单的设置一个返回码。</p>
<p>下面是我使用的方式（我们有时候需要使用一个解析器，所以我先添加了<code>peg</code>库）：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(plugin)]
#![plugin(peg_syntax_ext)]

extern crate llvm_sys as llvm;

use std::ffi::CString;
use std::fs::File;
use std::io::Read;
use std::ptr;

fn main() {
    let mut input = String::new();
    let mut f = File::open(&quot;in.ex&quot;).unwrap();
    f.read_to_string(&amp;mut input).unwrap();

    let parsed_input = parser::program(&amp;input).unwrap();

    unsafe {
        codegen(parsed_input);
    }
}

peg! parser(r#&quot;
    #[pub]
    program -&gt; String
        = i:int_literal &quot;\n&quot; { i }

    int_literal -&gt; String
        = [0-9]+ { match_str.to_owned() }
&quot;#);

unsafe fn codegen(input: String) {
    let context = llvm::core::LLVMContextCreate();
    let module = llvm::core::LLVMModuleCreateWithName(b&quot;example_module\0&quot;.as_ptr() as *const _);
    let builder = llvm::core::LLVMCreateBuilderInContext(context);

    // In LLVM, you get your types from functions.
    let int_type = llvm::core::LLVMInt64TypeInContext(context);
    let function_type = llvm::core::LLVMFunctionType(int_type, ptr::null_mut(), 0, 0);
    let function = llvm::core::LLVMAddFunction(module, b&quot;main\0&quot;.as_ptr() as *const _, function_type);

    let entry_name = CString::new(&quot;entry&quot;).unwrap();
    let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function, entry_name.as_ptr());
    llvm::core::LLVMPositionBuilderAtEnd(builder, bb);

    // The juicy part: construct a `LLVMValue` from a Rust value:
    let int_value: u64 = input.parse().unwrap();
    let int_value = llvm::core::LLVMConstInt(int_type, int_value, 0);

    llvm::core::LLVMBuildRet(builder, int_value);

    // Instead of dumping to stdout, let's write out the IR to `out.ll`
    let out_file = CString::new(&quot;out.ll&quot;).unwrap();
    llvm::core::LLVMPrintModuleToFile(module, out_file.as_ptr(), ptr::null_mut());

    llvm::core::LLVMDisposeBuilder(builder);
    llvm::core::LLVMDisposeModule(module);
    llvm::core::LLVMContextDispose(context);
}
</code></pre></pre>
<p>它起作用了！测试一下：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cat in.ex
42
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ lli-3.8 out.ll ; echo $?
42
</code></pre>
<p>有点酷哦！顺便提一下，下面是<code>out.ll</code>文件的内容：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  ret i64 42
}
</code></pre>
<h2 id="算术"><a class="header" href="#算术">算术</a></h2>
<p>让我们添加对数字的加减乘除操作的支持。为了实现这个，我们需要扩展我们的语法。我们引入一个枚举来代表AST（抽象语法树）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Literal(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>并扩展语法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `product` and `sum` are that way to get operator precedence
peg! parser(r#&quot;
    use super::Expr;

    #[pub]
    program -&gt; Expr
        = e:expression &quot;\n&quot; { e }

    expression -&gt; Expr
        = sum

    sum -&gt; Expr
        = a:product _ &quot;+&quot; _ b:sum { Expr::Add(Box::new(a), Box::new(b)) }
        / a:product _ &quot;-&quot; _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) }
        / product

    product -&gt; Expr
        = a:int_literal _ &quot;*&quot; _ b:product { Expr::Mul(Box::new(a), Box::new(b)) }
        / a:int_literal _ &quot;/&quot; _ b:product { Expr::Div(Box::new(a), Box::new(b)) }
        / int_literal

    int_literal -&gt; Expr
        = [0-9]+ { Expr::Literal(match_str.to_owned()) }

    _ = &quot; &quot;*
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<p>接下来，可以提交代码。你可以指定诸如“addtmp”的字符串，这些字符串将被用作IR中对应“寄存器”名称的一部分。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When you write out instructions in LLVM, you get back `LLVMValueRef`s. You
// can then use these references in other instructions.
unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        Expr::Literal(int_literal) =&gt; {
            let int_type = llvm::core::LLVMInt64TypeInContext(context);
            llvm::core::LLVMConstInt(int_type, int_literal.parse().unwrap(), 0)
        },

        Expr::Add(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;addtmp&quot;).unwrap();
            llvm::core::LLVMBuildAdd(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Sub(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;subtmp&quot;).unwrap();
            llvm::core::LLVMBuildSub(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Mul(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;multmp&quot;).unwrap();
            llvm::core::LLVMBuildMul(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Div(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;divtmp&quot;).unwrap();
            llvm::core::LLVMBuildUDiv(builder, lhs, rhs, name.as_ptr())
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，你可以执行<code>10 * 4 + 20/2 - 8</code>之类的程序！如果你问我，那可真是太酷了。</p>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>我们将采用简单的方式并假设程序不会执行任何烦人的操作，如引用未定义的变量等。我们只将变量存储在寄存器中，并将它们存在<code>HashMap&lt;String, LLVMValueRef&gt;</code>中，之所以有用是因为运行该程序只有这一种方式。</p>
<p>我们扩展语言和解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Literal(String),
    Ref(String),
    Assign(String, Box&lt;Expr&gt;),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
}

peg! parser(r#&quot;
    use super::Expr;

    #[pub]
    program -&gt; Vec&lt;Expr&gt;
        = e:(expression ** &quot;\n&quot;) &quot;\n&quot; { e }

    expression -&gt; Expr
        = i:identifier _ &quot;=&quot; _ s:sum { Expr::Assign(i, Box::new(s)) }
        / sum

    sum -&gt; Expr
        = a:product _ &quot;+&quot; _ b:sum { Expr::Add(Box::new(a), Box::new(b)) }
        / a:product _ &quot;-&quot; _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) }
        / product

    product -&gt; Expr
        = a:ref_or_literal _ &quot;*&quot; _ b:product { Expr::Mul(Box::new(a), Box::new(b)) }
        / a:ref_or_literal _ &quot;/&quot; _ b:product { Expr::Div(Box::new(a), Box::new(b)) }
        / ref_or_literal

    ref_or_literal -&gt; Expr
        = i:identifier { Expr::Ref(i) }
        / int_literal

    identifier -&gt; String
        = [a-zA-Z]+ { match_str.to_owned() }

    int_literal -&gt; Expr
        = [0-9]+ { Expr::Literal(match_str.to_owned()) }

    _ = &quot; &quot;*
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<p>然后为这两个新的表达式添加支持：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, names: &amp;mut HashMap&lt;String, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        // ...

        Expr::Ref(name) =&gt; {
            *names.get(&amp;name).unwrap()
        },

        Expr::Assign(name, expr) =&gt; {
            let new_value = codegen_expr(context, builder, names, *expr);
            names.insert(name, new_value);
            new_value
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>并迅速的在<code>codegen</code>函数中更新：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zero = llvm::core::LLVMConstInt(int_type, 0, 0);

let mut names = HashMap::new();
let mut return_value = zero; // return value on empty program
for expr in input {
    return_value = codegen_expr(context, builder, &amp;mut names, expr);
}
llvm::core::LLVMBuildRet(builder, return_value);
<span class="boring">}
</span></code></pre></pre>
<p>现在让我们来一探究竟：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vagrant@vagrant:/vagrant$ cat in.ex
a = 3
b = 76
a + b
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ cat out.ll
; ModuleID = 'example_module'

define i64 @main() {
entry:
  ret i64 79
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<p>在使用<code>if</code>关键字的时候遇到一些麻烦。让<code>if</code>起作用的最简单的方式就是将所有的变量存储在堆栈上。并让LLVM做一些优化。在LLVM中，你可以通过<code>alloca</code>指令创建一个栈变量，并使用<code>load/store</code>进行读写。</p>
<p>为了实现这个，我们通过添加新的解析规则再一次扩展了语言和语法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>expression -&gt; Expr
    = if_expression
    / i:identifier _ &quot;=&quot; _ s:expression { Expr::Assign(i, Box::new(s)) }
    / sum

if_expression -&gt; Expr
    = &quot;if&quot; _ e:expression _ &quot;{\n&quot; _ then_body:statements _ &quot;}&quot; _ &quot;else&quot; _ &quot;{\n&quot; _ else_body:statements _ &quot;}&quot; {
        Expr::If(Box::new(e), then_body, else_body)
    }
<span class="boring">}
</span></code></pre></pre>
<p>并在AST节点上添加了一个新的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Literal(String),
    Ref(String),
    Assign(String, Box&lt;Expr&gt;),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    If(Box&lt;Expr&gt;, Vec&lt;Expr&gt;, Vec&lt;Expr&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，完成关于<code>if</code>表达式的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, func: LLVMValueRef, names: &amp;mut HashMap&lt;String, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        // ...

        Expr::If(condition, then_body, else_body) =&gt; {
            let condition_value = codegen_expr(context, builder, func, names, *condition);
            let int_type = llvm::core::LLVMInt64TypeInContext(context);
            let zero = llvm::core::LLVMConstInt(int_type, 0, 0);

            // `is_nonzero` is a 1-bit integer
            let name = CString::new(&quot;is_nonzero&quot;).unwrap();
            let is_nonzero = llvm::core::LLVMBuildICmp(builder, llvm::LLVMIntPredicate::LLVMIntNE, condition_value, zero, name.as_ptr());

            // It's fine to create blocks first, and then fill them in later.
            let entry_name = CString::new(&quot;entry&quot;).unwrap();
            let then_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());
            let else_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());
            let merge_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());

            llvm::core::LLVMBuildCondBr(builder, is_nonzero, then_block, else_block);

            llvm::core::LLVMPositionBuilderAtEnd(builder, then_block);
            let mut then_return = zero;
            for expr in then_body {
                then_return = codegen_expr(context, builder, func, names, expr);
            }
            llvm::core::LLVMBuildBr(builder, merge_block);

            llvm::core::LLVMPositionBuilderAtEnd(builder, else_block);
            let mut else_return = zero;
            for expr in else_body {
                else_return = codegen_expr(context, builder, func, names, expr);
            }
            llvm::core::LLVMBuildBr(builder, merge_block);

            // Position the builder so that it's ready to work on the next
            // expression.
            llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block);
            zero
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>代码有点多，但是完成了你所期待的事情。现在，你可以像这样来运行程序：</p>
<pre><code class="language-groovy">a = 1
if a {
    a = 42
} else {
    a = 13
}
a
</code></pre>
<p>上述代码对应的IR如下所示：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  %a = alloca i64
  store i64 1, i64* %a
  %a1 = load i64, i64* %a
  %is_nonzero = icmp ne i64 %a1, 0
  br i1 %is_nonzero, label %entry2, label %entry3

entry2:                                           ; preds = %entry
  store i64 42, i64* %a
  br label %entry4

entry3:                                           ; preds = %entry
  store i64 13, i64* %a
  br label %entry4

entry4:                                           ; preds = %entry3, %entry2
  %a5 = load i64, i64* %a
  ret i64 %a5
}
</code></pre>
<p>然而，我们还没有结束。目前，我们的“if”表达式的返回结果始终为zero(见上述<code>codegen_expr</code>函数中If分支的返回值)。而我们想要的正好与其相反，如果我们执行了“then”路径，则if的求值结果应该为then_return，否则返回else_return。</p>
<p>你如何使用LLVM跟踪它执行了哪个分支？通过使用“Phi”节点。你给phi指令一个(block, value)对，该phi节点将会返回与先前执行的块相对应的值。</p>
<p>我们可以这样结束if。注意，我们必须更新then_block和else_block，因为这是我们在“then/else”分支中需要的最后一个块，并且前面的then_block是“then/else”的第一个块。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is mostly the same code as before, just note the new calls to
// `LLVMGetInsertBlock`.

llvm::core::LLVMPositionBuilderAtEnd(builder, then_block);
let mut then_return = zero;
for expr in then_body {
    then_return = codegen_expr(context, builder, func, names, expr);
}
llvm::core::LLVMBuildBr(builder, merge_block);
let then_block = llvm::core::LLVMGetInsertBlock(builder);

llvm::core::LLVMPositionBuilderAtEnd(builder, else_block);
let mut else_return = zero;
for expr in else_body {
    else_return = codegen_expr(context, builder, func, names, expr);
}
llvm::core::LLVMBuildBr(builder, merge_block);
let else_block = llvm::core::LLVMGetInsertBlock(builder);

// Insert the phi node
llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block);
let phi_name = CString::new(&quot;iftmp&quot;).unwrap();
let phi = llvm::core::LLVMBuildPhi(builder, int_type, phi_name.as_ptr());

let mut values = vec![then_return, else_return];
let mut blocks = vec![then_block, else_block];

llvm::core::LLVMAddIncoming(phi, values.as_mut_ptr(), blocks.as_mut_ptr(), 2);
phi
<span class="boring">}
</span></code></pre></pre>
<p>然后，你就得到了一个令人惊叹的编译器：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cat in.ex
a = 1
b = 0
c = if a {
    if b {
        11
    } else {
        40
    }
} else {
    if b {
        10
    } else {
        20
    }
}
c + 2
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ lli-3.8 out.ll ; echo $?
42
</code></pre>
<p>太酷了！下面是我们提供的示例输入程序的IR：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  %a = alloca i64
  %b = alloca i64
  %c = alloca i64
  store i64 1, i64* %a
  store i64 0, i64* %b
  %a1 = load i64, i64* %a
  %is_nonzero = icmp ne i64 %a1, 0
  br i1 %is_nonzero, label %entry2, label %entry3

entry2:                                           ; preds = %entry
  %b5 = load i64, i64* %b
  %is_nonzero6 = icmp ne i64 %b5, 0
  br i1 %is_nonzero6, label %entry7, label %entry8

entry3:                                           ; preds = %entry
  %b10 = load i64, i64* %b
  %is_nonzero11 = icmp ne i64 %b10, 0
  br i1 %is_nonzero11, label %entry12, label %entry13

entry4:                                           ; preds = %entry14, %entry9
  %iftmp16 = phi i64 [ %iftmp, %entry9 ], [ %iftmp15, %entry14 ]
  store i64 %iftmp16, i64* %c
  %c17 = load i64, i64* %c
  %addtmp = add i64 %c17, 2
  ret i64 %addtmp

entry7:                                           ; preds = %entry2
  br label %entry9

entry8:                                           ; preds = %entry2
  br label %entry9

entry9:                                           ; preds = %entry8, %entry7
  %iftmp = phi i64 [ 11, %entry7 ], [ 40, %entry8 ]
  br label %entry4

entry12:                                          ; preds = %entry3
  br label %entry14

entry13:                                          ; preds = %entry3
  br label %entry14

entry14:                                          ; preds = %entry13, %entry12
  %iftmp15 = phi i64 [ 10, %entry12 ], [ 20, %entry13 ]
  br label %entry4
}

</code></pre>
<p>请注意：这些块具有以下的模式：不包含第一个条目，它们三个为一组，第一个是“then”分支，然后是“else”分支，最后是“merge”块（带有可识别的phi指令）。每一次我们遇到“if”表达式时都会在main后面附加三个新块。因为要在AST中递归查询三元组，所以块的三元组是有序的。</p>
<p>这就是我想要分享的全部内容！希望在这一点上你可以有足够的实力来决定你的命运。</p>
<h1 id="使用-nom-解析-url"><a class="header" href="#使用-nom-解析-url">使用 nom 解析 url</a></h1>
<h4 id="a-hrefhttpsbloglogrocketcomparsing-in-rust-with-nom原文a"><a class="header" href="#a-hrefhttpsbloglogrocketcomparsing-in-rust-with-nom原文a"><a href="https://blog.logrocket.com/parsing-in-rust-with-nom/">原文</a></a></h4>
</br>
<p><img src="lang/rust/./img/parsing-rust-nom.png" alt="nom" /></p>
</br>
<p>在本教程中，我们将演示如何使用 nom 解析器组合器库在 Rust 中编写一个非常基础的 URL 解析器。我们将包含以下内容</p>
<ul>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8?">什么是解析器组合器?</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#nom%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">nom是如何工作的</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E8%AE%BE%E7%BD%AEnom">设置nom</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#nom%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">nom中的错误处理</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E4%BD%BF%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%90%E5%99%A8">使用Rust写一个解析器</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E8%A7%A3%E6%9E%90%E5%BE%85%E6%8E%88%E6%9D%83%E7%9A%84URL">解析待授权的URL</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#Rust%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%B8%BB%E6%9C%BA%EF%BC%8CIP%E5%92%8C%E7%AB%AF%E5%8F%A3">Rust解析：主机，IP和端口</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E4%BD%BF%E7%94%A8Rust%E8%A7%A3%E6%9E%90%E8%B7%AF%E5%BE%84">使用Rust解析路径</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%89%87%E6%AE%B5">查询和片段</a></li>
<li><a href="lang/rust/03-%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90url.html#%E5%9C%A8Rust%E4%B8%AD%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9A%84%E6%B5%8B%E8%AF%95">在Rust中使用nom解析：最终的测试</a></li>
</ul>
<h2 id="什么是解析器组合器"><a class="header" href="#什么是解析器组合器">什么是解析器组合器?</a></h2>
<p>解析器组合器是高阶函数，可以接受多个解析器作为输入，并返回一个新的解析器作为输出。</p>
<p>这种方式让你可以为简单的任务(如：解析某个字符串或数字)构建解析器，并使用组合器函数将它们组合成一个递归下降(recursive descent)的解析器。</p>
<p>组合解析的好处包括可测试性，可维护性和可读性。每个部件都非常小且具有自我隔离性，从而使整个解析器由模块化组件构成。</p>
<p>如果你对这个概念不熟悉，我强烈推荐你阅读 Bodil Stokke 的<a href="lang/rust/./01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html">用 Rust 学习解析器组合器</a>。</p>
<h2 id="nom是如何工作的"><a class="header" href="#nom是如何工作的">nom是如何工作的</a></h2>
<p><a href="https://github.com/Geal/nom">nom</a> 是使用 Rust 编写的解析器组合器库，它可以让你创建安全的解析器，而不会占用内存或影响性能。它依靠 Rust 强大的类型系统和内存安全来生成既正确又高效的解析器，并使用函数，宏和特征来抽象出容易出错的管道。</p>
<p>为了演示 <code>nom</code> 是如何工作的，我们将创建一个基础的 URL 解析器。我们不会完整的实现 <a href="https://url.spec.whatwg.org/">URL 规范</a>；这将远远超出此代码示例的范围。相反，我们将采用一些捷径。</p>
<p>最终的目标是能够将合法的 URL (如：<a href="https://www.zupzup.org/about/?someVal=5&amp;anotherVal=hello#anchor">https://www.zupzup.org/about/?someVal=5&amp;anotherVal=hello#anchor</a> 和 <a href="http://user:pw@127.0.0.1:8080">http://user:pw@127.0.0.1:8080</a>) 解析成相关的结构，并在解析过程中为非法的 URL 返回一个有用的错误。</p>
<p>而且，由于可测试性被认为是解析器组合器的一大优势，我们将对大多数组件进行测试，以了解其具体的优势。</p>
<p>让我们开始吧！</p>
<h2 id="设置nom"><a class="header" href="#设置nom">设置nom</a></h2>
<p>为了进行下面的一系列操作，你需要安装最新的 Rust 版本 (1.44+)。</p>
<p>首先，创建一个新的 Rust 项目:</p>
<pre><code class="language-console">cargo new --lib rust-nom-example
cd rust-nom-example
</code></pre>
<p>然后，编辑<code>Cargo.toml</code>文件并添加你需要的依赖：</p>
<pre><code class="language-toml">[dependencies]
nom = &quot;6.0&quot;
</code></pre>
<p>是的，我们需要的是最新版本的<code>nom</code>库(在撰写本文时是 6.0)。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>编写解析器时，通常先定义输出结构以了解你需要哪些部分是很有意义的。</p>
<p>在这里，我们正在解析一个 URL，因此，让我们给它定义一个结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Eq)]
pub struct URI&lt;'a&gt; {
    scheme: Scheme,
    authority: Option&lt;Authority&lt;'a&gt;&gt;,
    host: Host,
    port: Option&lt;u16&gt;,
    path: Option&lt;Vec&lt;&amp;'a str&gt;&gt;,
    query: Option&lt;QueryParams&lt;'a&gt;&gt;,
    fragment: Option&lt;&amp;'a str&gt;,
}

#[derive(Debug, PartialEq, Eq)]
pub enum Scheme {
    HTTP,
    HTTPS,
}

pub type Authority&lt;'a&gt; = (&amp;'a str, Option&lt;&amp;'a str&gt;);

#[derive(Debug, PartialEq, Eq)]
pub enum Host {
    HOST(String),
    IP([u8; 4]),
}

pub type QueryParam&lt;'a&gt; = (&amp;'a str, &amp;'a str);
pub type QueryParams&lt;'a&gt; = Vec&lt;QueryParam&lt;'a&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>让我们逐行进行说明。</p>
<p>这些字段是根据它们在常规 URI 中出现的顺序进行排列的。首先，我们有 scheme。在这里，我们将 URI 的前缀限制为<code>http://</code>和<code>https://</code>，但是请注意，这里还有很多其它可选的 scheme。</p>
<p>接下来是<code>authority</code>部分，它由用户名和可选密码组成，通常是完全可选的。</p>
<p>host 可以是 IP，(在我们的示例中仅为 IPv4)，也可以是主机字符串，如：<code>example.org</code>，后面跟一个可选的port，port 仅是个数字：如：<code>localhost:8080</code>。</p>
<p>在端口之后是 path。它是由<code>/</code>分割的字符串序列，如：<code>/some/important/path</code>。query 和 fragment 部分是可选的，它们表示 URL 的<code>?query=some-value&amp;another=5</code>和<code>#anchor</code>部分。query 是字符串元组的可选列表，而 fragment 只是可选字符串(完整的 URL 示例是<code>https://some/important/?query=some-value&amp;another=5#anchor</code>)。</p>
<p>如果你对这些类型中的生命周期(<code>'a</code>)感到困惑，请不用感到沮丧；它不会真的影响到我们写代码的方式。本质上，我们可以使用指向输入字符串各部分的指针，而不是为 URL 的每一部分分配新的字符串，只要输入的生命周期和我们 URI 结构一样长就可以了。</p>
<p>在开始解析之前，让我们实现<code>From</code>特征将合法的 scheme 转换成<code>Scheme</code>枚举：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;&amp;str&gt; for Scheme {
    fn from(i: &amp;str) -&gt; Self {
        match i.to_lowercase().as_str() {
            &quot;http://&quot; =&gt; Scheme::HTTP,
            &quot;https://&quot; =&gt; Scheme::HTTPS,
            _ =&gt; unimplemented!(&quot;no other schemes supported&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>顺便说一句，让我们从顶部开始，开始解析 scheme。</p>
<h2 id="nom中的错误处理"><a class="header" href="#nom中的错误处理">nom中的错误处理</a></h2>
<p>在我们开始之前，先讨论一下 <code>nom</code> 中的错误处理。虽然我们不会面面俱到，但是至少会让调用者大致了解在解析的哪一步出了什么问题。</p>
<p>为了达到我们的目的，我们将使用<code>nom</code>中的<code>context</code>组合器。在<code>nom</code>中，一个解析器通常会返回如下类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type IResult&lt;I, O, E = (I, ErrorKind)&gt; = Result&lt;(I, O), Err&lt;E&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>在本例中，我们将返回一个输入值(<code>&amp;str</code> - 输入字符串)的元组类型。它包含仍需要解析的字符串，以及输出的值。当解析失败时，它也会返回一个错误。</p>
<p>标准的<code>IResult</code>只允许我们使用 nom 内置的错误类型，如果我们想要创建自定义的错误类型以及在这些错误中添加一些上下文呢？</p>
<p><code>ParserError</code> 特征和 <code>VerboseError</code> 类型让我们可以构建自己的错误类型，并可以在已有的错误中添加上下文。在这个简单的例子中，我们将会在我们的解析错误类型中添加上下文。为了方便起见，让我们定义一个自己的结果类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Res&lt;T, U&gt; = IResult&lt;T, U, VerboseError&lt;T&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>除了它带有<code>VerboseError</code>之外，本质上是相同的。这意味着我们可以使用 nom 的上下文组合器，它允许我们在任何解析器中隐式地添加错误上下文。</p>
<p>nom 的官方文档包含这些选项，但是错误处理并不是最直观的方法。</p>
<p>为了看到它的实际效果，让我们为该 scheme 创建第一个解析器。</p>
<h2 id="使用rust写一个解析器"><a class="header" href="#使用rust写一个解析器">使用Rust写一个解析器</a></h2>
<p>为了解析 URL 的scheme，我们想要匹配<code>http://</code>和<code>https://</code>，除此之外没有别的了。由于我们使用的是功能强大的解析器组合器库，因此我们不需要手动编写底层的解析器。<code>nom</code> 已经帮我们覆盖了。</p>
<p><a href="https://github.com/fucking-translation/tutorial/Rust/nom/%E9%80%89%E6%8B%A9nom%E7%BB%84%E5%90%88%E5%99%A8.md">解析器组合器宏清单</a>讲述了在某些用例中如何使用 nom 中的解析器组合器。</p>
<p>我们将会使用<code>tag_no_case</code>解析器和<code>alt</code>组合器来做基础的说明：“每个小写(输入)应该是<code>http://</code>或<code>https://</code>” 。在本教程中，我们将只使用常规函数，但请注意，nom 中的许多解析器和组合器也可以作为宏使用。</p>
<p>在 Rust 中使用 nom 如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scheme(input: &amp;str) -&gt; Res&lt;&amp;str, Scheme&gt; {
    context(
        &quot;scheme&quot;,
        alt((tag_no_case(&quot;HTTP://&quot;), tag_no_case(&quot;HTTPS://&quot;))),
    )(input)
    .map(|(next_input, res)| (next_input, res.into()))
}
<span class="boring">}
</span></code></pre></pre>
<p>如你所示：我们使用<code>context</code>组合器封装了实际的解析器并在其中添加了<code>scheme</code>上下文，因此，此处触发的任何错误都将在结果中标记为<code>scheme</code>。</p>
<p>一旦将解析器和组合器组装成了整个解析器，便使用输入字符串来调用它，这是我们唯一的输入参数。然后我们对结果进行<code>map</code> - 如上所述，它由剩余的输入和解析的输出组成，并通过实现前面提到的<code>.into()</code>特征将我们解析后的 scheme 转换成<code>Scheme</code>枚举。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use nom::{
        error::{ErrorKind, VerboseError, VerboseErrorKind},
        Err as NomErr,
    };

    #[test]
    fn test_scheme() {
        assert_eq!(scheme(&quot;https://yay&quot;), Ok((&quot;yay&quot;, Scheme::HTTPS)));
        assert_eq!(scheme(&quot;http://yay&quot;), Ok((&quot;yay&quot;, Scheme::HTTP)));
        assert_eq!(
            scheme(&quot;bla://yay&quot;),
            Err(NomErr::Error(VerboseError {
                errors: vec![
                    (&quot;bla://yay&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                    (&quot;bla://yay&quot;, VerboseErrorKind::Nom(ErrorKind::Alt)),
                    (&quot;bla://yay&quot;, VerboseErrorKind::Context(&quot;scheme&quot;)),
                ]
            }))
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如你所见，在成功的情况下，我们取回已解析<code>Scheme</code>枚举和剩余待解析的字符串(<code>yay</code>)。另外，如果有错误，我们将列举出已触发的错误以及定义的上下文列表(<code>scheme</code>)。</p>
<p>在本例中，两次<code>tag</code>调用都失败了，因此，<code>alt</code>组合器也失败了，因为它无法产生单个值。</p>
<p>那不是很难。在上面我们基本上只是解析了一个常量的字符串，让我们通过解析<code>authority</code>部分来尝试更高级的内容。</p>
<h2 id="解析待授权的url"><a class="header" href="#解析待授权的url">解析待授权的URL</a></h2>
<p>如果我们还记得我们在之前的 URI 的结构，尤其是 authority 部分，我们会看到我们正在寻找一个完全可选的结构。如果它存在，则需要一个用户名和一个可选的密码。</p>
<p>这是我们使用的类型别名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Authority&lt;'a&gt; = (&amp;'a str, Option&lt;&amp;'a str&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>我们该怎么办呢？在 URL 中，它看起来像：</p>
<p><a href="https://username:password@example.org">https://username:password@example.org</a></p>
<p><code>:password</code>是可选的，但是在任何情况下，它都会以<code>@</code>作为结尾，所以我们可以通过使用<code>terminated</code>解析器开始。这给了我们一个字符串，该字符串是通过终止另一个字符串得到的。</p>
<p>在<code>authority</code>部分中，我们看到<code>:</code>作为一个分隔符。根据文档，我们可以使用<code>separated_pair</code>组合器，它通过分割一个字符串给我们提供了两个值。但是我们如何处理实际的文本呢？这里有几种选项，一种是使用<code>alphanumeric1</code>解析器。它生成了一个至少包含一个字符的字母数字字符串。</p>
<p>为了简单起见，我们不必担心可以在 URL 的不同部分使用哪些字符。这与编写和构造解析器无关，只会使所有的内容变得更长且更不方便。出于我们的目的，我们假设 URL 的大部分都可以由字母数字组成，有时候还包含连字符和点 - 根据 <a href="https://url.spec.whatwg.org/#url-code-points">URL 标准</a>，这当然是错误的。</p>
<p>让我们来看看组合后的<code>authority</code>解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn authority(input: &amp;str) -&gt; Res&lt;&amp;str, (&amp;str, Option&lt;&amp;str&gt;)&gt; {
    context(
        &quot;authority&quot;,
        terminated(
            separated_pair(alphanumeric1, opt(tag(&quot;:&quot;)), opt(alphanumeric1)),
            tag(&quot;@&quot;),
        ),
    )(input)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们通过运行一些测试用例来检验它是否工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_authority() {
    assert_eq!(
        authority(&quot;username:password@zupzup.org&quot;),
        Ok((&quot;zupzup.org&quot;, (&quot;username&quot;, Some(&quot;password&quot;))))
    );
    assert_eq!(
        authority(&quot;username@zupzup.org&quot;),
        Ok((&quot;zupzup.org&quot;, (&quot;username&quot;, None)))
    );
    assert_eq!(
        authority(&quot;zupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;.org&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (&quot;zupzup.org&quot;, VerboseErrorKind::Context(&quot;authority&quot;)),
            ]
        }))
    );
    assert_eq!(
        authority(&quot;:zupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (
                    &quot;:zupzup.org&quot;,
                    VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)
                ),
                (&quot;:zupzup.org&quot;, VerboseErrorKind::Context(&quot;authority&quot;)),
            ]
        }))
    );
    assert_eq!(
        authority(&quot;username:passwordzupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;.org&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (
                    &quot;username:passwordzupzup.org&quot;,
                    VerboseErrorKind::Context(&quot;authority&quot;)
                ),
            ]
        }))
    );
    assert_eq!(
        authority(&quot;@zupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (
                    &quot;@zupzup.org&quot;,
                    VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)
                ),
                (&quot;@zupzup.org&quot;, VerboseErrorKind::Context(&quot;authority&quot;)),
            ]
        }))
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>看起来很不错！对于各种情况，我们都有与之对应的测试用例，缺少密码，缺少<code>@</code>以及其他几种错误的情况。</p>
<p>让我们继续来到 <code>host</code> 部分。</p>
<h2 id="rust解析主机ip和端口"><a class="header" href="#rust解析主机ip和端口">Rust解析：主机，IP和端口</a></h2>
<p>因为 host 部分可以包含 主机字符串或者 IP，这一步将会有点复杂。更糟的是，在结尾还有一个可选的<code>:port</code>。</p>
<p>为了尽可能保持简单，我们只支持 IPv4 的 IP。我们将从 host 开始。让我们看一下它的实现并逐行进行说明。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn host(input: &amp;str) -&gt; Res&lt;&amp;str, Host&gt; {
    context(
        &quot;host&quot;,
        alt((
            tuple((many1(terminated(alphanumerichyphen1, tag(&quot;.&quot;))), alpha1)),
            tuple((many_m_n(1, 1, alphanumerichyphen1), take(0 as usize))),
        )),
    )(input)
    .map(|(next_input, mut res)| {
        if !res.1.is_empty() {
            res.0.push(res.1);
        }
        (next_input, Host::HOST(res.0.join(&quot;.&quot;)))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>首先你注意到这里有两个选项(<code>alt</code>)。在这两种情况下，都有一个元组，并包含了一个解析器链。</p>
<p>在第一种情况下，我们想要一个或多个(<code>many1</code>)字母数字字符串，包含一个连字符，被一个<code>.</code>终结并以顶级域名 (alpha1) 结尾。</p>
<p><code>alphanumerichyphen1</code>解析器如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn alphanumerichyphen1&lt;T&gt;(i: T) -&gt; Res&lt;T, T&gt;
where
    T: InputTakeAtPosition,
    &lt;T as InputTakeAtPosition&gt;::Item: AsChar,
{
    i.split_at_position1_complete(
        |item| {
            let char_item = item.as_char();
            !(char_item == '-') &amp;&amp; !char_item.is_alphanum()
        },
        ErrorKind::AlphaNumeric,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>这有点复杂，但基本上是 nom 中<code>alphanumeric1</code>解析器带有<code>-</code>的复制版本。我不知道它是否是最好的方式，但是它确实有用。</p>
<p>在任何情况下，主机部分都有第二个选项，它是一个字符串，如：<code>localhost</code>。</p>
<p>为什么我们要用将1和1传给<code>many_m_n</code>解析器这种看起来很无用的方式来表示呢？这里的问题是，在<code>alt</code>组合器中，所有的选项都必须返回相同的类型 - 在这里，它是一个字符串向量和另一个字符串的元组。</p>
<p>我们也在<code>map</code>函数中看到，如果元组的第二部分不为空(顶级域名)，则将其添加到元组的第一部分。最后，我们构建了一个 HOST 枚举，将字符串部分用一个<code>.</code>相连，并创建了一个原始的主机字符串。</p>
<p>让我们来看一些测试用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_host() {
    assert_eq!(
        host(&quot;localhost:8080&quot;),
        Ok((&quot;:8080&quot;, Host::HOST(&quot;localhost&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;example.org:8080&quot;),
        Ok((&quot;:8080&quot;, Host::HOST(&quot;example.org&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;some-subsite.example.org:8080&quot;),
        Ok((&quot;:8080&quot;, Host::HOST(&quot;some-subsite.example.org&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;example.123&quot;),
        Ok((&quot;.123&quot;, Host::HOST(&quot;example&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;$$$.com&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;$$$.com&quot;, VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)),
                (&quot;$$$.com&quot;, VerboseErrorKind::Nom(ErrorKind::ManyMN)),
                (&quot;$$$.com&quot;, VerboseErrorKind::Nom(ErrorKind::Alt)),
                (&quot;$$$.com&quot;, VerboseErrorKind::Context(&quot;host&quot;)),
            ]
        }))
    );
    assert_eq!(
        host(&quot;.com&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;.com&quot;, VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)),
                (&quot;.com&quot;, VerboseErrorKind::Nom(ErrorKind::ManyMN)),
                (&quot;.com&quot;, VerboseErrorKind::Nom(ErrorKind::Alt)),
                (&quot;.com&quot;, VerboseErrorKind::Context(&quot;host&quot;)),
            ]
        }))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们来到 主机是 IP 的情况。首先，我们需要能够解析 IPv4 的 IP 中每一个的部分(如：127.0.0.1)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ip_num(input: &amp;str) -&gt; Res&lt;&amp;str, u8&gt; {
    context(&quot;ip number&quot;, n_to_m_digits(1, 3))(input).and_then(|(next_input, result)| {
        match result.parse::&lt;u8&gt;() {
            Ok(n) =&gt; Ok((next_input, n)),
            Err(_) =&gt; Err(NomErr::Error(VerboseError { errors: vec![] })),
        }
    })
}

fn n_to_m_digits&lt;'a&gt;(n: usize, m: usize) -&gt; impl FnMut(&amp;'a str) -&gt; Res&lt;&amp;str, String&gt; {
    move |input| {
        many_m_n(n, m, one_of(&quot;0123456789&quot;))(input)
            .map(|(next_input, result)| (next_input, result.into_iter().collect()))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了获取每一个数字，我们尝试使用<code>n_to_m_digits</code>解析器来寻找一到三个连续的数字并将他们转换成 <code>u8</code>。</p>
<p>通过这种方式，我们可以查看如何将完整的 IP 解析成<code>u8</code>数组：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ip(input: &amp;str) -&gt; Res&lt;&amp;str, Host&gt; {
    context(
        &quot;ip&quot;,
        tuple((count(terminated(ip_num, tag(&quot;.&quot;)), 3), ip_num)),
    )(input)
    .map(|(next_input, res)| {
        let mut result: [u8; 4] = [0, 0, 0, 0];
        res.0
            .into_iter()
            .enumerate()
            .for_each(|(i, v)| result[i] = v);
        result[3] = res.1;
        (next_input, Host::IP(result))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们要查找的查好是3个后面跟<code>.</code>的<code>ip_num</code>，然后是另一个<code>ip_num</code>。在映射函数中，我们将这些独立的结果拼接，从而将<code>u8</code>数组转换成<code>Host::IP</code>枚举。</p>
<p>再一次，我们将写一些测试用例来确保它是正常工作的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ipv4() {
    assert_eq!(
        ip(&quot;192.168.0.1:8080&quot;),
        Ok((&quot;:8080&quot;, Host::IP([192, 168, 0, 1])))
    );
    assert_eq!(ip(&quot;0.0.0.0:8080&quot;), Ok((&quot;:8080&quot;, Host::IP([0, 0, 0, 0]))));
    assert_eq!(
        ip(&quot;1924.168.0.1:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;4.168.0.1:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (&quot;1924.168.0.1:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Count)),
                (&quot;1924.168.0.1:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
    assert_eq!(
        ip(&quot;192.168.0000.144:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;0.144:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (
                    &quot;192.168.0000.144:8080&quot;,
                    VerboseErrorKind::Nom(ErrorKind::Count)
                ),
                (&quot;192.168.0000.144:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
    assert_eq!(
        ip(&quot;192.168.0.1444:8080&quot;),
        Ok((&quot;4:8080&quot;, Host::IP([192, 168, 0, 144])))
    );
    assert_eq!(
        ip(&quot;192.168.0:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (&quot;192.168.0:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Count)),
                (&quot;192.168.0:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
    assert_eq!(
        ip(&quot;999.168.0.0:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;999.168.0.0:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Count)),
                (&quot;999.168.0.0:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>将它们放置在一起，我们需要另一个可以同时解析 IP 和 host 的解析器，并返回一个<code>Host</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ip_or_host(input: &amp;str) -&gt; Res&lt;&amp;str, Host&gt; {
    context(&quot;ip or host&quot;, alt((ip, host)))(input)
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，让我们来解析端口(原文遗漏)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn port(input: &amp;str) -&gt; Res&lt;&amp;str, u16&gt; {
    context(
        &quot;port&quot;,
        tuple((
            tag(&quot;:&quot;),
            n_to_m_digits(1, 5)
        )),
    )(input)
        .and_then(|(next_input, result)| {
            let port = result.1.parse::&lt;u16&gt;();
            match port {
                Ok(port) =&gt; Ok((next_input, port)),
                Err(e) =&gt; Err(NomErr::Error(VerboseError { errors: vec![ (input, VerboseErrorKind::Nom(ErrorKind::Digit))] }))
            }
        })
}
<span class="boring">}
</span></code></pre></pre>
<p>并使用一些测试用例保证它是可以正常工作的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_port() {
    assert_eq!(port(&quot;:0&quot;), Ok((&quot;&quot;, 0u16)));
    assert_eq!(port(&quot;:65535&quot;), Ok((&quot;&quot;, 65535u16)));
    assert_eq!(
        port(&quot;:65536&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;:65536&quot;, VerboseErrorKind::Nom(ErrorKind::Digit))
            ]
        })));
    assert_eq!(
        port(&quot;:a&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;a&quot;, VerboseErrorKind::Nom(ErrorKind::OneOf)),
                (&quot;a&quot;, VerboseErrorKind::Nom(ErrorKind::ManyMN)),
                (&quot;:a&quot;, VerboseErrorKind::Context(&quot;port&quot;))
            ]
        })));
}
<span class="boring">}
</span></code></pre></pre>
<p>还不错，一切正常！</p>
<h2 id="使用rust解析路径"><a class="header" href="#使用rust解析路径">使用Rust解析路径</a></h2>
<p>下一步是解决路径问题。在此，我们再次假设该路径中的字符串只能包含带有连字符和点的字母数字字符串，并使用以下帮助程序进行解析：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn url_code_points&lt;T&gt;(i: T) -&gt; Res&lt;T, T&gt;
where
    T: InputTakeAtPosition,
    &lt;T as InputTakeAtPosition&gt;::Item: AsChar,
{
    i.split_at_position1_complete(
        |item| {
            let char_item = item.as_char();
            !(char_item == '-') &amp;&amp; !char_item.is_alphanum() &amp;&amp; !(char_item == '.')
            // ... actual ascii code points and url encoding...: https://infra.spec.whatwg.org/#ascii-code-point
        },
        ErrorKind::AlphaNumeric,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>为了解析<code>path</code>，我们希望可以将由<code>/</code>分隔的字符串解析成字符串向量：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn path(input: &amp;str) -&gt; Res&lt;&amp;str, Vec&lt;&amp;str&gt;&gt; {
    context(
        &quot;path&quot;,
        tuple((
            tag(&quot;/&quot;),
            many0(terminated(url_code_points, tag(&quot;/&quot;))),
            opt(url_code_points),
        )),
    )(input)
    .map(|(next_input, res)| {
        let mut path: Vec&lt;&amp;str&gt; = res.1.iter().map(|p| p.to_owned()).collect();
        if let Some(last) = res.2 {
            path.push(last);
        }
        (next_input, path)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>我们总是由<code>/</code>开始。这已经是一个合法的路径了，但是我们仍然可以有<code>0</code>个或更多个(<code>many0</code>)由<code>/</code>分隔的字符串，后面跟一个最终的可选的字符串(如：<code>index.php</code>)。</p>
<p>在映射中，我们检查元组的第三部分(最后一部分)是否存在，如果存在，则将其添加到路径向量中。</p>
<p>让我们为路径也写一点测试用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_path() {
    assert_eq!(path(&quot;/a/b/c?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])));
    assert_eq!(path(&quot;/a/b/c/?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])));
    assert_eq!(path(&quot;/a/b-c-d/c/?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;b-c-d&quot;, &quot;c&quot;])));
    assert_eq!(path(&quot;/a/1234/c/?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;1234&quot;, &quot;c&quot;])));
    assert_eq!(
        path(&quot;/a/1234/c.txt?d&quot;),
        Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;1234&quot;, &quot;c.txt&quot;]))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>看起来不错！我们获取到了路径中的不同部分以及剩余的字符串，并且它们都被添加到了字符串向量中了。</p>
<p>让我们通过解析 query 和 URL 部分的 fragment 来增强功能。</p>
<h2 id="查询和片段"><a class="header" href="#查询和片段">查询和片段</a></h2>
<p>查询主要是由键值对组成：第一个键前面跟一个<code>?</code>，其余的查询由<code>&amp;</code>进行分隔。再一次，我们将自己限制为有限的<code>url_code_points</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn query_params(input: &amp;str) -&gt; Res&lt;&amp;str, QueryParams&gt; {
    context(
        &quot;query params&quot;,
        tuple((
            tag(&quot;?&quot;),
            url_code_points,
            tag(&quot;=&quot;),
            url_code_points,
            many0(tuple((
                tag(&quot;&amp;&quot;),
                url_code_points,
                tag(&quot;=&quot;),
                url_code_points,
            ))),
        )),
    )(input)
    .map(|(next_input, res)| {
        let mut qps = Vec::new();
        qps.push((res.1, res.3));
        for qp in res.4 {
            qps.push((qp.1, qp.3));
        }
        (next_input, qps)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>实际上这相当不错，因为解析器是非常直观(intuitive)且可读性的。我们解析<code>?</code>后面的第一个键值对的元组，使用<code>=</code>分隔，然后同样的操作执行<code>0</code>或多次，它们是以<code>&amp;</code>而不是<code>?</code>开头。</p>
<p>然后，在映射中，我们简单的将所有的键值对放在向量中，然后就有了我们在文章的开头定义的结构。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type QueryParam&lt;'a&gt; = (&amp;'a str, &amp;'a str);
pub type QueryParams&lt;'a&gt; = Vec&lt;QueryParam&lt;'a&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这里有一组基础的测试用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_query_params() {
    assert_eq!(
        query_params(&quot;?bla=5&amp;blub=val#yay&quot;),
        Ok((&quot;#yay&quot;, vec![(&quot;bla&quot;, &quot;5&quot;), (&quot;blub&quot;, &quot;val&quot;)]))
    );

    assert_eq!(
        query_params(&quot;?bla-blub=arr-arr#yay&quot;),
        Ok((&quot;#yay&quot;, vec![(&quot;bla-blub&quot;, &quot;arr-arr&quot;),]))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>最后一部分是 fragment，它其实就是一个<code>#</code>后面跟一个字符串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fragment(input: &amp;str) -&gt; Res&lt;&amp;str, &amp;str&gt; {
    context(&quot;fragment&quot;, tuple((tag(&quot;#&quot;), url_code_points)))(input)
        .map(|(next_input, res)| (next_input, res.1))
}
<span class="boring">}
</span></code></pre></pre>
<p>在介绍了所有这些复杂的解析器之后，为了达到良好的效果，让我们编写一些完整性检查测试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_fragment() {
    assert_eq!(fragment(&quot;#bla&quot;), Ok((&quot;&quot;, &quot;bla&quot;)));
    assert_eq!(fragment(&quot;#bla-blub&quot;), Ok((&quot;&quot;, &quot;bla-blub&quot;)));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="在rust中使用nom解析最终的测试"><a class="header" href="#在rust中使用nom解析最终的测试">在Rust中使用nom解析:最终的测试</a></h2>
<p>让我们将它们都放在最顶层的 URI 解析器函数中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn uri(input: &amp;str) -&gt; Res&lt;&amp;str, URI&gt; {
    context(
        &quot;uri&quot;,
        tuple((
            scheme,
            opt(authority),
            ip_or_host,
            opt(port),
            opt(path),
            opt(query_params),
            opt(fragment),
        )),
    )(input)
    .map(|(next_input, res)| {
        let (scheme, authority, host, port, path, query, fragment) = res;
        (
            next_input,
            URI {
                scheme,
                authority,
                host,
                port,
                path,
                query,
                fragment,
            },
        )
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>我们有一个强制的(mandatory)<code>scheme</code>，后面跟一个可选的<code>authority</code>，然后再跟一个强制的<code>ip 或 host</code>。最后后面跟可选的<code>port</code>，<code>path</code>，<code>query 参数</code>，和一个<code>fragment</code>。</p>
<p>在映射中，剩下的唯一一件事就是将解析后的元素构成成我们的<code>URI</code>结构。</p>
<p>在这一点上，你可以看到整个结构的美观性和模块化。如果 uri 函数是你的起点，那么你可以从头到尾查看每个单独的解析器，以了解整个过程在做什么。</p>
<p>当然，我们也需要对<code>uri</code>解析器进行一些测试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_uri() {
    assert_eq!(
        uri(&quot;https://www.zupzup.org/about/&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTPS,
                authority: None,
                host: Host::HOST(&quot;www.zupzup.org&quot;.to_string()),
                port: None,
                path: Some(vec![&quot;about&quot;]),
                query: None,
                fragment: None
            }
        ))
    );

    assert_eq!(
        uri(&quot;http://localhost&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTP,
                authority: None,
                host: Host::HOST(&quot;localhost&quot;.to_string()),
                port: None,
                path: None,
                query: None,
                fragment: None
            }
        ))
    );

    assert_eq!(
        uri(&quot;https://www.zupzup.org:443/about/?someVal=5#anchor&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTPS,
                authority: None,
                host: Host::HOST(&quot;www.zupzup.org&quot;.to_string()),
                port: Some(443),
                path: Some(vec![&quot;about&quot;]),
                query: Some(vec![(&quot;someVal&quot;, &quot;5&quot;)]),
                fragment: Some(&quot;anchor&quot;)
            }
        ))
    );

    assert_eq!(
        uri(&quot;http://user:pw@127.0.0.1:8080&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTP,
                authority: Some((&quot;user&quot;, Some(&quot;pw&quot;))),
                host: Host::IP([127, 0, 0, 1]),
                port: Some(8080),
                path: None,
                query: None,
                fragment: None
            }
        ))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>它没问题！你可以在 <a href="https://github.com/zupzup/rust-nom-parsing">Github</a>找到完整的代码。</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>真是太好了！我希望本文能够使你对 Rust 中的解析器特别是解析器组合器感到兴奋。</p>
<p><code>nom</code>库解析速度特别快，是很多生产级别的库和系统的基础。除此之外，它还提供了出色的 API 和文档。</p>
<p>Rust 生态系统还提供了更多的解析选项，如：<a href="https://github.com/Marwes/combine">combine</a> 和 <a href="https://github.com/pest-parser/pest">pest</a>。</p>
<h1 id="rust-中异步编程实用介绍"><a class="header" href="#rust-中异步编程实用介绍">Rust 中异步编程实用介绍</a></h1>
<p><a href="http://jamesmcm.github.io/blog/2020/05/06/a-practical-introduction-to-async-programming-in-rust/">原文</a></p>
<blockquote>
<p>在本文中，我们将探讨一个使用 Tokio 运行时在 Rust 中进行异步编程的简短示例，展示了不同的执行场景。这篇文章主要是针对异步编程的初学者的。</p>
</blockquote>
<p>这个示例的代码可以在 <a href="https://github.com/jamesmcm/async-rust-example">Github</a> 中获取，也可以使用基于<code>async-std</code>运行时的分支(由 <a href="https://github.com/BartMassey">@BartMassey</a> 贡献)。</p>
<h2 id="什么是异步编程"><a class="header" href="#什么是异步编程">什么是异步编程</a></h2>
<p>异步编程可以让你在等待 I/O 操作(通常是网络请求或响应)结果的同时，即使在单个 OS 线程中，也可以继续执行计算。</p>
<p>这是通过使用异步运行时来实现的，该运行时将异步任务(即：<a href="https://en.wikipedia.org/wiki/Green_threads">绿色线程</a>)分配给实际的 OS 线程。</p>
<p>与 OS 线程不同，创建绿色线程并不昂贵，因此我们不必担心是否达到了硬件限制。而 OS 线程需要维护自己的堆栈，因此在处理多个线程时会占用大量内存。在 Linux 中你可以使用<code>cat /proc/sys/kernel/threads-max</code>命令来查看每个进程的线程数限制，我的是 127162。</p>
<p>例如，如果我们需要一个单独的 OS 线程来处理 Web 服务器上的每个请求，这将是一个重大的问题，这是 <a href="https://en.wikipedia.org/wiki/C10k_problem">C10k 问题</a>的根源 - 如何处理 Web 服务器上的 10000 个连接。</p>
<p>早期的 Web 服务器确实为每个请求分配了独立的 OS 线程，以便并行处理每个请求。但是这会造成这些线程花费了大量的时间来等待网络响应，而不是做其他的计算。</p>
<h2 id="async-和-await"><a class="header" href="#async-和-await">Async 和 await</a></h2>
<p>Rust 已经采用 async/await 语法定义异步代码块和函数。</p>
<p><code>async</code>关键字定义了异步代码块和函数。它被指定返回了一个<code>Future</code> - 一个需要在其他地方<code>.await</code>以触发任务执行(注意延迟执行)，并等待可用的返回的值。</p>
<p><code>.await</code>关键字(必须被用于<code>async</code>代码块/函数中)用于异步等待异步任务的完成并获取返回值。请注意，虽然在<code>Future</code>准备好之前任务本身无法进行，但是实际的 OS 线程却可以在运行时分配其他的任务，因此 (OS 线程)可以继续工作。</p>
<p>高效的任务正在通知运行时，这时它可能会导致执行另一个任务(最终，另一个任务也将等待某个事件，如果此任务中的<code>Future</code>准备就绪，则该任务可以继续执行) - 这是<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">多任务协作</a>的实现。</p>
<p>这种语法非常优雅，它使我们可以编写异步程序，该程序的结构类似于简单的同步程序。</p>
<h2 id="我们应该什么时候使用异步"><a class="header" href="#我们应该什么时候使用异步">我们应该什么时候使用异步？</a></h2>
<p>当线程原本只是在等待 I/O 操作(例如：发出网络请求或响应，对磁盘的读写以及等待用户的输入)时，异步编程将会很有用。</p>
<p>如果你始终都在计算并且没有等待 I/O 操作，异步编程其实用处不大，即使这些计算可以并行运行(如在光线跟踪器中)，它对你的帮助也十分有限。在这种情况下，最好直接在 OS 线程上并行执行计算(利用 CPU 中的多个内核)，如在<code>rayon</code>库中使用并行迭代器(如果你想要进行线程级别的控制，则可以使用<code>crossbeam</code>和<code>threadpool</code>库)。然而，请记住 Amdahl 定律，即算法优化改进可能会比专注于并行化产生更好的回报。</p>
<p>如果在等待 I/O 操作的同时没有其他任务可做，那它也没有用。例如，在上一篇<a href="http://jamesmcm.github.io/blog/2020/04/19/data-engineering-with-rust-and-aws-lambda/#en">博客</a>中，当我们向 AWS Secrets Manager 请求数据库连接凭证时，<code>Rusoto</code>实际上返回的是一个<code>RusotoFuture</code>对象，但是在这种情况下，我们对 Lambda 函数的一次调用对应于一次请求 - 等待数据库凭证到达起见无需完成任何工作。因此我们可以仅使用同步编程(幸运的是，<code>RusotoFuture</code>提供了<code>.sync()</code>函数来做到这一点)。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p>在此示例中，我们将模拟三个非常慢的网络请求，包括三个阶段：</p>
<ul>
<li>连接 - 2秒的异步延迟</li>
<li>等待响应 - 8秒的异步延迟(延迟在服务端)</li>
<li>计算 - 4秒的同步延迟(如：它必须阻塞当前的 OS 线程去做计算)。</li>
</ul>
<p>我们将使用 <a href="https://tokio.rs">Tokio</a> 作为本例中的异步运行时，因为它是目前 Rust 中最流行的异步框架。其他的异步框架如<code>async-std</code>运行时 - 基于<code>async-std</code>的本示例代码可以在 <a href="https://github.com/jamesmcm/async-rust-example/tree/async-std">Github仓库的 async-std 分支</a>上获取(由 <a href="https://github.com/BartMassey">@BartMassey</a>贡献)。</p>
<p>请注意，两者都使用<code>futures</code>库，因此你可以在切换异步运行时的同时(whilst)保留大部分相同的 API。</p>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>本示例的 server 代码改编自 <a href="https://tokio.rs/docs/getting-started/echo/">tokio教程</a>。它在延迟 8 秒后，打印接收到的字节。</p>
<p>完整的改编代码如下：</p>
<pre><pre class="playground"><code class="language-rust">use futures::stream::StreamExt;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let mut listener = TcpListener::bind(addr).await.unwrap();

    let server = {
        async move {
            let mut incoming = listener.incoming();
            while let Some(conn) = incoming.next().await {
                match conn {
                    Err(e) =&gt; eprintln!(&quot;accept failed = {:?}&quot;, e),
                    Ok(mut sock) =&gt; {
                        tokio::spawn(async move {
                            let (mut reader, mut writer) = sock.split();
                            tokio::time::delay_for(tokio::time::Duration::from_secs(8)).await;
                            match tokio::io::copy(&amp;mut reader, &amp;mut writer).await {
                                Ok(amt) =&gt; {
                                    println!(&quot;wrote {} bytes&quot;, amt);
                                }
                                Err(err) =&gt; {
                                    eprintln!(&quot;IO error {:?}&quot;, err);
                                }
                            }
                        });
                    }
                }
            }
        }
    };
    println!(&quot;Server running on localhost:6142&quot;);
    server.await;
}
</code></pre></pre>
<h2 id="同步请求"><a class="header" href="#同步请求">同步请求</a></h2>
<p>在同步的情况下，我们只需依次运行每个请求即可。因此我们预测完成 3 个任务的总执行时间为<code>3 * ( 2 + 8 + 4) = 42</code>秒。</p>
<p>我们可以用一张图对这种情况进行可视化：</p>
<p><img src="lang/rust/./img/synchronous.svg" alt="synchronous" /></p>
<p>我们实现这个仅需使用标准库：</p>
<pre><pre class="playground"><code class="language-rust">use std::io::prelude::*;
use std::net::TcpStream;
use std::thread::sleep;
use std::time::Instant;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let now = Instant::now();

    task(&quot;task1&quot;, now.clone())?;
    task(&quot;task2&quot;, now.clone())?;
    task(&quot;task3&quot;, now.clone())?;
    Ok(())
}

fn task(label: &amp;str, now: std::time::Instant) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Simulate network delay using thread sleep for 2 seconds
    println!(
        &quot;OS Thread {:?} - {} started: {:?}&quot;,
        std::thread::current().id(),
        label,
        now.elapsed(),
    );
    sleep(std::time::Duration::from_secs(2));

    // Write to server - server will echo this back to us with 8 second delay
    let mut stream = TcpStream::connect(&quot;127.0.0.1:6142&quot;)?;
    stream.write_all(label.as_bytes())?;
    println!(
        &quot;OS Thread {:?} - {} written: {:?}&quot;,
        std::thread::current().id(),
        label,
        now.elapsed()
    );

    // Read 5 chars we expect (to avoid dealing with EOF, etc.)
    let mut buffer = [0; 5];
    stream.read_exact(&amp;mut buffer)?;
    stream.shutdown(std::net::Shutdown::Both)?;
    println!(
        &quot;OS Thread {:?} - {} read: {:?}&quot;,
        std::thread::current().id(),
        label,
        now.elapsed()
    );

    // Simulate computation work by sleeping actual thread for 4 seconds
    sleep(std::time::Duration::from_secs(4));
    println!(
        &quot;OS Thread {:?} - {} finished: {:?}&quot;,
        std::thread::current().id(),
        std::str::from_utf8(&amp;buffer)?,
        now.elapsed()
    );
    Ok(())
}
</code></pre></pre>
<p>运行这段代码：</p>
<pre><code class="language-console">$ cargo run --release --bin server
$ cargo run --release --bin client_synchronous
</code></pre>
<pre><code class="language-console">OS Thread ThreadId(1) - task1 started: 578ns
OS Thread ThreadId(1) - task1 written: 2.000346788s
OS Thread ThreadId(1) - task1 read: 10.002177173s
OS Thread ThreadId(1) - task1 finished: 14.002328699s
OS Thread ThreadId(1) - task2 started: 14.002387112s
OS Thread ThreadId(1) - task2 written: 16.002673602s
OS Thread ThreadId(1) - task2 read: 24.006071003s
OS Thread ThreadId(1) - task2 finished: 28.006204147s
OS Thread ThreadId(1) - task3 started: 28.006263855s
OS Thread ThreadId(1) - task3 written: 30.00652763s
OS Thread ThreadId(1) - task3 read: 38.008234993s
OS Thread ThreadId(1) - task3 finished: 42.008389223s
</code></pre>
<p>准确给出了我们上面计算的 42 秒总执行时间。</p>
<h2 id="同步请求-tokio"><a class="header" href="#同步请求-tokio">同步请求 (Tokio)</a></h2>
<p>请注意，在使用 Tokio 时(有时是无意间)，可以从异步函数中获取同步行为。用 Tokio 实现上述功能：</p>
<pre><pre class="playground"><code class="language-rust">use futures::stream::StreamExt;
use std::error::Error;
use std::thread::sleep;
use std::time::Instant;
use tokio::join;
use tokio::net::TcpStream;
use tokio::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let now = Instant::now();

    // Synchronous
    task(&quot;task1&quot;, now.clone()).await?;
    task(&quot;task2&quot;, now.clone()).await?;
    task(&quot;task3&quot;, now.clone()).await?;
    Ok(())
}

async fn task(label: &amp;str, now: std::time::Instant) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    // Simulate network delay using Tokio async delay for 2 seconds
    println!(
        &quot;OS Thread {:?} - {} started: {:?}&quot;,
        std::thread::current().id(),
        label,
        now.elapsed(),
    );
    tokio::time::delay_for(tokio::time::Duration::from_secs(2)).await;

    // Write to server - server will echo this back to us with 8 second delay
    let mut stream = TcpStream::connect(&quot;127.0.0.1:6142&quot;).await?;
    stream.write_all(label.as_bytes()).await?;
    println!(
        &quot;OS Thread {:?} - {} written: {:?}&quot;,
        std::thread::current().id(),
        label,
        now.elapsed()
    );

    // Read 5 chars we expect (to avoid dealing with EOF, etc.)
    let mut buffer = [0; 5];
    stream.read_exact(&amp;mut buffer).await?;
    stream.shutdown(std::net::Shutdown::Both)?;
    println!(
        &quot;OS Thread {:?} - {} read: {:?}&quot;,
        std::thread::current().id(),
        label,
        now.elapsed()
    );

    // Simulate computation work by sleeping actual thread for 4 seconds
    sleep(std::time::Duration::from_secs(4));
    println!(
        &quot;OS Thread {:?} - {} finished: {:?}&quot;,
        std::thread::current().id(),
        std::str::from_utf8(&amp;buffer)?,
        now.elapsed()
    );
    Ok(())
}
</code></pre></pre>
<p>运行这段代码，产生的输出和之前一样：</p>
<pre><code class="language-console">$ cargo run --release --bin client_async
</code></pre>
<pre><code class="language-console">OS Thread ThreadId(1) - task1 started: 333ns
OS Thread ThreadId(1) - task1 written: 2.001476012s
OS Thread ThreadId(1) - task1 read: 10.003284491s
OS Thread ThreadId(1) - task1 finished: 14.003404307s
OS Thread ThreadId(1) - task2 started: 14.003476979s
OS Thread ThreadId(1) - task2 written: 16.005013941s
OS Thread ThreadId(1) - task2 read: 24.005471439s
OS Thread ThreadId(1) - task2 finished: 28.005575307s
OS Thread ThreadId(1) - task3 started: 28.005615372s
OS Thread ThreadId(1) - task3 written: 30.007082377s
OS Thread ThreadId(1) - task3 read: 38.009223127s
OS Thread ThreadId(1) - task3 finished: 42.009349576s
</code></pre>
<p>这是因为串行任务的等待(<code>.await</code>)造成了同步。主函数是异步的，但是使用<code>.await</code>会使它在继续之前等待<code>Future</code>的结果。在这方面，主函数与其他异步函数之间没有什么区别。当时没有任何其他的任务可以产生执行结果，因此任务的执行实际上还是同步的。</p>
<p>请注意，在上面的实现中是不需要<code>Send + Sync</code>的(因为它运行在单个 OS 线程中)，但是在下一个示例中，我们将会需要它们。这也是为什么我们会 clone <code>now</code> 而不是在<code>task()</code>中对其进行借用(我们也可以将其封装在<code>Arc</code>中)。</p>
<p>在下面的示例中，我们将使用同样的<code>async fn task()</code>定义，在此将其忽略。</p>
<h2 id="异步请求一个-os-线程"><a class="header" href="#异步请求一个-os-线程">异步请求(一个 OS 线程)</a></h2>
<p>在异步中单个 OS 线程的场景下，我们同时开始等待步骤(连接并获取服务端的响应)。然而，最终的计算步骤仍然需要在每个任务中依次执行完成。因此我们预期总执行时间是<code>8 + 2 + (3 * 4) = 22</code>秒。</p>
<p>对应的图表如下所示：</p>
<p><img src="lang/rust/./img/asynchronous_single.svg" alt="asynchronous_single" /></p>
<p>像之前一样使用相同的<code>async fn task()</code>定义：</p>
<pre><pre class="playground"><code class="language-rust">use futures::stream::futures_unordered::FuturesUnordered;
use futures::stream::StreamExt;
use std::error::Error;
use std::thread::sleep;
use std::time::Instant;
use tokio::net::TcpStream;
use tokio::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let now = Instant::now();

    // Asynchronous single-thread
    let mut futs = FuturesUnordered::new();

    futs.push(task(&quot;task1&quot;, now.clone()));
    futs.push(task(&quot;task2&quot;, now.clone()));
    futs.push(task(&quot;task3&quot;, now.clone()));

    while let Some(_handled) = futs.next().await {}
    Ok(())
}
</code></pre></pre>
<p>运行这段代码，总执行时间是 22 秒：</p>
<pre><code class="language-console">OS Thread ThreadId(1) - task1 started: 3.994µs
OS Thread ThreadId(1) - task2 started: 21.174µs
OS Thread ThreadId(1) - task3 started: 25.511µs
OS Thread ThreadId(1) - task3 written: 2.002221984s
OS Thread ThreadId(1) - task2 written: 2.002406898s
OS Thread ThreadId(1) - task1 written: 2.002483563s
OS Thread ThreadId(1) - task3 read: 10.003326999s
OS Thread ThreadId(1) - task3 finished: 14.003478669s
OS Thread ThreadId(1) - task2 read: 14.00365763s
OS Thread ThreadId(1) - task2 finished: 18.00379238s
OS Thread ThreadId(1) - task1 read: 18.003951713s
OS Thread ThreadId(1) - task1 finished: 22.004094444s
</code></pre>
<p>在本示例中，我们使用<code>FuturesUnordered</code>集合以便我们可以重复等待不同的 Future。然而，我们不会使用<code>tokio::spawn()</code>因此它只能运行在单个 OS 线程中(因为我们不允许创建更多的 OS 线程)。</p>
<p>请注意，在这里我们可以使用<code>join!</code>宏而不必分配一个<code>FuturesUnordered</code>，我们将在之后的示例中这么做。然而，它仅对数量很少的 Future 具有实用性。</p>
<p>我们也可以通过设置主函数上的属性参数来强制 Tokio 只能使用一个线程。</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main(core_threads = 1, max_threads = 1)]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
...
}
</code></pre></pre>
<h2 id="异步请求多个-os-线程"><a class="header" href="#异步请求多个-os-线程">异步请求(多个 OS 线程)</a></h2>
<p>在跨多个 OS 线程的异步请求中，我们可以同时进行每一步(并在 OS 线程可以在任务等待的时候去完成其他的任务)。这就意味着我们可以在不同的 OS 线程中并行的进行最终的计算。</p>
<p><img src="lang/rust/./img/asynchronous_multi.svg" alt="asynchronous_multi" /></p>
<p>因此我们预测 3 次请求的总执行时间为<code>2 + 8 + 4 = 14</code>秒。这是我们能够实现的最好的方案 - 与完成单个请求的用时一样。</p>
<p>请注意，这需要我们跨进程发送的类型是<code>线程安全</code>的，也就是说需要实现<code>Send</code>或<code>Sync</code> - 就像我们直接使用 OS 线程一样。</p>
<p>它的实现和之前的示例很像，但是不是直接等待 Future 的返回，我们对任务进行<code>tokio::spawn</code>并等待它们的处理。这允许 tokio 可以在不同的的 OS 线程中执行它们。</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let now = Instant::now();

    let mut futs = FuturesUnordered::new();
    futs.push(tokio::spawn(task(&quot;task1&quot;, now.clone())));
    futs.push(tokio::spawn(task(&quot;task2&quot;, now.clone())));
    futs.push(tokio::spawn(task(&quot;task3&quot;, now.clone())));
    while let Some(_handled) = futs.next().await {}
    Ok(())
}
</code></pre></pre>
<p>然后我们会观察到 14 秒的执行时间(请注意我们并不关心执行顺序)：</p>
<pre><code class="language-console">OS Thread ThreadId(2) - task1 started: 17.055µs
OS Thread ThreadId(3) - task2 started: 30.227µs
OS Thread ThreadId(2) - task3 started: 32.513µs
OS Thread ThreadId(2) - task3 written: 2.001499145s
OS Thread ThreadId(3) - task1 written: 2.00153689s
OS Thread ThreadId(5) - task2 written: 2.001721878s
OS Thread ThreadId(3) - task3 read: 10.003403756s
OS Thread ThreadId(2) - task1 read: 10.003501s
OS Thread ThreadId(5) - task2 read: 10.003417328s
OS Thread ThreadId(3) - task3 finished: 14.003584085s
OS Thread ThreadId(2) - task1 finished: 14.003664981s
OS Thread ThreadId(5) - task2 finished: 14.003698375s
</code></pre>
<p>不同的 OS 线程 ID 证明了任务确实是在 OS 中不同的线程中执行的。</p>
<p>为了本文内容更加完整，这里有一个使用<code>join!</code>宏的相同实现，而不是分配一个<code>FuturesUnordered</code>：</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let now = Instant::now();
    // Asynchronous multi-threaded

    match join!(
        tokio::spawn(task(&quot;task1&quot;, now.clone())),
        tokio::spawn(task(&quot;task2&quot;, now.clone())),
        tokio::spawn(task(&quot;task3&quot;, now.clone()))
    ) {
        (x, y, z) =&gt; {
            (x.ok(), y.ok(), z.ok())
        }
    };
    Ok(())
}
</code></pre></pre>
<p>这样可以节省<code>FuturesUnordered</code>的分配，但是处理返回的结果元组(尤其是对于很多的Future来说)，可能会很笨拙。</p>
<h3 id="它和-os-线程并行有什么区别呢"><a class="header" href="#它和-os-线程并行有什么区别呢">它和 OS 线程并行有什么区别呢？</a></h3>
<p>在一些同步的场景中，你可以直接使用 OS 线程来实现相同的事情，例如之前提到的<a href="https://crates.io/crates/rayon">rayon</a>库。</p>
<p>然而，这种情况下每个请求都会需要一个自己的 OS 线程，如果我们必须处理 10000 个并行请求，很可能会达到系统的线程限制。</p>
<p>也就是说，执行图如下所示：</p>
<p><img src="lang/rust/./img/synchronous_multios.svg" alt="synchronous_multios" /></p>
<p>请注意，OS 线程可能会花费大量的时间来等待 I/O 操作，而无法启动其他任务。</p>
<p>我们可以使用 rayon 修改我们在上面的第一个同步示例：</p>
<pre><pre class="playground"><code class="language-rust">use rayon::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {
    let now = Instant::now();

    [&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;]
        .par_iter()
        .map(|x| task(x, now.clone()))
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
    Ok(())
}
</code></pre></pre>
<p>而且它在预期的 14 秒内结束了(请注意这里每个任务都单独分配了一个 OS 线程)。</p>
<pre><code class="language-console">OS Thread ThreadId(3) - task1 started: 280.871µs
OS Thread ThreadId(6) - task2 started: 281.03µs
OS Thread ThreadId(7) - task3 started: 283.838µs
OS Thread ThreadId(6) - task2 written: 2.000605562s
OS Thread ThreadId(7) - task3 written: 2.000619598s
OS Thread ThreadId(3) - task1 written: 2.000679853s
OS Thread ThreadId(3) - task1 read: 10.002321036s
OS Thread ThreadId(6) - task2 read: 10.00233185s
OS Thread ThreadId(7) - task3 read: 10.002384653s
OS Thread ThreadId(3) - task1 finished: 14.002447762s
OS Thread ThreadId(6) - task2 finished: 14.002540969s
OS Thread ThreadId(7) - task3 finished: 14.002589621s
</code></pre>
<p>然而，由于一个任务对应了一个 OS 线程，当处理大量的任务时可能会无法充分利用资源。</p>
<p>而在异步的情况下，我们在(同步的)计算步骤中只需要额外的线程即可。这意味着我们可以使用固定大小的 OS 线程池，并仍然可以在计算步骤的并行化中受益，同时还可以保证系统资源的充分利用(即我们可以限制 OS 线程的最大数量，但是依然可以处理新的请求)。</p>
<h2 id="结论-1"><a class="header" href="#结论-1">结论</a></h2>
<p>我希望这篇文章可以帮助你更好的理解在 Rust 中何时以及如何去使用异步编程。</p>
<p>优雅的<code>async/await</code>语法允许进行简单明了的异步编程。但是，如果你之前没有接触过异步编程，可能需要花一点时间来适应这种方式。</p>
<p>上述的示例也展示了并发和并行之间的区别。在异步单个 OS 线程中，我们并发的处理任务，但是这不是并行执行的(因为我们只有一个 OS 线程)。</p>
<h2 id="当前的限制"><a class="header" href="#当前的限制">当前的限制</a></h2>
<p>请注意，现在你还不能在 <a href="https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html">trait 中使用异步函数</a>，并且你也不能创建<a href="https://boats.gitlab.io/blog/post/poll-drop/">异步的解构</a>。如果你希望结构在销毁时发出网络请求，但是不希望这么做的同时阻塞 OS 线程，这时就会出现问题 - 你无法使用<code>.await</code>因为<code>drop()</code>(来自 From) 不是异步的。</p>
<h1 id="tokio-内幕自底向上的理解-rust-的异步-io-框架"><a class="header" href="#tokio-内幕自底向上的理解-rust-的异步-io-框架">Tokio 内幕：自底向上的理解 Rust 的异步 I/O 框架</a></h1>
<p><a href="https://cafbit.com/post/tokio_internals/">原文</a></p>
</br>
<p><a href="https://tokio.rs/">tokio</a> 是用于开发异步 I/O 应用程序的 Rust 框架 - 它基于事件驱动的方式，与传统的同步 I/O 相比，它通常可以实现更好的伸缩性，性能与资源使用。不幸的是，tokio 由于其复杂的 (sophisticated) 抽象而难以学习。即使在阅读了教程之后，我仍然觉得自己没有内部化抽象来推理出实际发生的事情。</p>
<p>我以前在异步 I/O 编程方面的经验甚至可能成为我学习 tokio 的阻碍。我习惯于使用操作系统的 selection 工具(如 Linux 的 epoll) 作为起点，然后继续学习调度，状态机等内容。从 tokio 的抽象开始，对底层的 epoll_wait 发生的位置和方式没有清晰的了解，我发现很难将所有的点连接起来。tokio 及其 future 驱动的方式感觉就像个黑匣子。</p>
<p>我没有继续采用自上而下的方式来学习 tokio，而是决定采用自下而上的方式，通过研究源代码来确切地了解当前在<code>Future::poll()</code>中的具体实现如何驱动 epoll 事件向 I/O 消耗的进展。我不会详细介绍 tokio 和 futures 的高级用法，因为有<a href="https://tokio.rs/docs/getting-started/tokio/">其他的教程</a>对其进行了更深入的说明。除了做一些简短的总结之外，我也不会讨论异步 I/O 的一般问题，因为讨论该主题可能需要写一本书。我的目标仅仅是让人们对 futures 和 tokio 轮询的工作方式有足够的了解。</p>
<p>首先，先做一些重要的免责声明。请注意，tokio 正在积极的开发中，因此此处的某些结论可能很快就会过时。为了这次研究的目的，我使用<code>tokio-core: 0.1.10</code>，<code>futures: 0.1.17</code>以及<code>mio: 0.6.10</code>。因为我想了解 tokio 的最底层，所以我没有考虑使用诸如<code>tokio-proto</code>和<code>tokio-service</code>这种更高层次的 crate。tokio-core 的事件系统拥有很多的组件，为了尽可能简洁，本文将不会对其进行讨论。我是在 Linux 系统中学习 tokio 的，因此一些讨论必然涉及平台相关的实现细节，如：epoll。最后，这里提到的所有内容都是我作为 tokio 新手对其做出的解释，因此可能存在错误或误解。</p>
<h2 id="异步-io-简述"><a class="header" href="#异步-io-简述">异步 I/O 简述</a></h2>
<p>同步 I/O 编程涉及执行 同步的 I/O 操作，该操作会一直阻塞线程直到完成。读操作会一直阻塞直到接收到数据，写操作会一直阻塞直到输出的字节发送到内核为止。这种依次执行的操作十分适合传统的命令式编程方式。举个例子，一个 HTTP 服务器为每一个连接都创建了一个线程。在线程中，它需要一直读取字节流直到接收到整个请求(在接收到所有的字节之前线程是阻塞的)，然后处理请求，再将响应写入连接通道(在所有的字节写入之前，线程是阻塞的)。这是一种非常直接的方式。缺点(downside)是由于阻塞，每个连接都需要一个不同的线程，每个线程都有自己的堆栈。在多数情况下这都没有问题，同步 I/O 是一种正确的方式。然而，线程开销阻碍了服务器处理大量连接的伸缩性(参阅：<a href="https://en.wikipedia.org/wiki/C10k_problem">C10k问题</a>)，并且在处理少量连接的低配置系统中也可能过载。</p>
<p>如果我们的 HTTP 服务器是使用异步 I/O 编写的，它可能会在一个线程中处理所有的 I/O 操作。所有的活跃连接以及监听套接字都将被配置成非阻塞的，在事件循环 (event loop) 中监听其读/写的准备情况，并在事件发生时将执行操作分发给处理程序。每个连接需要维护其状态和缓冲区。如果一个处理程序只能读取 200 字节请求的其中100个字节，它将无法等待剩余字节的到达，因为这样做会阻止其他准备处理的连接。它必须将部分读取存储在缓冲区中，将状态设置为“读请求”，然后返回事件循环。下次此连接调用处理程序时，它可以读取请求的剩余部分并切换为“写入响应”的状态。借助复杂的状态机和易于出错的资源管理，实现这样的系统非常麻烦。</p>
<p>一个理想的异步 I/O 框架将提供一种依次编写此类 I/O 处理步骤的方式，就好像它们在阻塞一样，但是在后台会生成事件循环和状态机。在大多数语言中这都是一个艰巨的任务，但是 Tokio 给我们提供了一种更接近这种方式的异步调用。</p>
<h2 id="tokio-技术栈"><a class="header" href="#tokio-技术栈">Tokio 技术栈</a></h2>
<p><img src="lang/rust/./img/tokio-stack.svg" alt="tokio-stack" /></p>
<p>Tokio 技术栈包含以下几个组件：</p>
<ol>
<li>
<p><strong>System Selector</strong>： 每个操作系统都提供了一个接收 I/O 事件的工具，如：epoll (Linux)，kqueue (FreeBSD/Mac OS)以及 IOCP (Windows)。</p>
</li>
<li>
<p><strong>Mio - Metal I/O</strong>：<a href="https://docs.rs/mio/0.6.10/mio/">Mio</a> 是一个 Rust 库，它通过内部处理每个操作系统的细节来提供一套用于底层 I/O 的通用 API。</p>
</li>
<li>
<p><strong>Futures</strong>：<a href="https://docs.rs/futures/0.1.17/futures/">Futures</a> 为尚未发生的事件提供了一个强大的抽象。它用一种有效的方式将这些事件组合在一起，以创建可以描述复杂事件序列的组合 Futures。这种抽象足够通用，可以用于 I/O 之外的许多其他的方面，在 Tokio 中，我们将异步 I/O 的状态机作为 futures。</p>
</li>
<li>
<p><strong>Tokio</strong>：<a href="https://docs.rs/tokio-core/0.1.10/tokio_core/">tokio-core</a> 提供了中央事件循环，该循环与 Mio 集成以响应 I/O 事件，并驱动完成 futures。</p>
</li>
<li>
<p><strong>你的程序</strong>：使用 Tokio 框架的程序可以将异步 I/O 系统构造为 futures，并为其提供 Tokio 事件循环以待执行。</p>
</li>
</ol>
<h2 id="miometal-io"><a class="header" href="#miometal-io">Mio：Metal I/O</a></h2>
<p>Mio 提供了一套底层 I/O 的 API，它允许调用者接收诸如读写套接字准备情况变更的事件，以下为其中的重点：</p>
<ol>
<li>
<p><strong>Poll 和 Evented</strong>：Mio 提供了一个 <a href="https://docs.rs/mio/0.6.10/mio/event/trait.Evented.html">Evented</a> 特征来表示任何可能成为事件源的东西。在你的事件循环中，你可以通过 <a href="https://docs.rs/mio/0.6.10/mio/struct.Poll.html">mio::Poll</a> 对象来注册大量的 <code>Evented</code>，然后调用 <a href="https://docs.rs/mio/0.6.10/mio/struct.Poll.html#method.poll">mio::Poll::poll()</a> 进行阻塞直到事件发生在一个或多个 <code>Evented</code> 对象中(或超过了指定的超时时间)。</p>
</li>
<li>
<p><strong>System Selector</strong>：Mio 对 System selector 提供了跨平台的访问方式，因此 Linux 的 epoll，Windows 的 IOCP，FreeBSD/Mac OS 的 kqueue 以及其他选择都可以使用相同的 API。system selector 适配 Mio API 的开销有所不同。因为 Mio 提供了一种类似于 epoll 基于就绪的 API，因此在 Linux 中使用 Mio 时，API 的许多部分可以一对一的进行映射(例如：<code>mio::Events</code>本质上是一个结构为<code>epoll_event</code>的数组)。相反，由于 Windows 的 IOCP 是基于完成而不是基于就绪，因此需要更多的适配来桥接这两个范式。Mio 提供了自己的<code>std::net</code>结构，如：<code>TcpListener</code>，<code>TcpStream</code>以及<code>UdpSocket</code>。它们封装了<code>std::net</code>，但是默认为非阻塞形式，并提供了<code>Evented</code>实现，这些实现将套接字添加到 System selector 中。</p>
</li>
<li>
<p>非系统事件：除了提供了 I/O 源的就绪状态之外，Mio 还可以指示在用户空间中生成就绪事件。举个例子，如果工作线程完成了一个工作单元，则它可以向事件循环线程发出完成信号。你的程序调用 <a href="https://docs.rs/mio/0.6.10/mio/struct.Registration.html#method.new2">Registration::new2()</a> 以获取一个(<code>Registration</code>, <code>SetReadiness</code>)元组。<code>Registration</code>对象是一个<code>Evented</code>，可以在事件循环中向 Mio 注册。当需要指示就绪情况时，可以在<code>SetReadiness</code>对象上调用<a href="https://docs.rs/mio/0.6.10/mio/struct.SetReadiness.html#method.set_readiness">set_readiness()</a>。在 Linux 中，非系统事件通知是使用管道实现的。当调用<code>SetReadiness::set_readiness()</code>时，<code>0x01</code>字节就被写入管道中。<code>mio::Poll</code>的基础 epoll 配置为监控管道读取的末端，因此<code>epoll_wait()</code>将解除阻塞并且 Mio 可以将事件传递给调用方。实例化轮询时仅创建一个管道，而不管后来注册了多少个(如果有)非系统事件。</p>
</li>
</ol>
<p>每一个<code>Evented</code>的注册都与调用者提供的作为<code>mio::Token</code>的<code>usize</code>类型的值相关联，并且此值与事件一起返回以指示相应的注册。在 Linux 系统中，这可以很好的映射到 System selector 中，因为 token 可以放置在 64 位 <code>epoll_data</code> 联合体中，该联合体以相同的方式起作用。</p>
<p>为了提供 Mio 操作的具体示例，这是当我们使用 Mio 监视 Linux 系统上的 UDP 套接字时在内部发生的事情：</p>
<ol>
<li><strong>创建套接字</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let socket = mio::net::UdpSocket::bind(
    &amp;SocketAddr::new(
        std::net::IpAddr::V4(std::net::Ipv4Addr::new(127,0,0,1)),
        2000
    )
).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>这里创建了一个 Linux 中封装在<code>std::net::UdpSocket</code>的 UDP 套接字，这个套接字也封装在<code>mio::net::UdpSocket</code>中。这个套接字被设置为非阻塞的。</p>
<ol start="2">
<li><strong>创建 poll</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let poll = mio::Poll::new().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Mio 初始化 System selector，就绪队列(用于非系统事件)和并发保护。就绪队列初始化会创建一个管道，以便可以从用户空间发出准备就绪的信号，并将管道读取的文件描述符添加到epoll中。创建 <code>poll</code>对象时，将从递增计数器中为其分配唯一的<code>selector_id</code>。</p>
<ol start="3">
<li><strong>使用 poll 注册套接字</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>poll.register(
    &amp;socket,
    mio::Token(0),
    mio::Ready::readable(),
    mio::PollOpt::level()
).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><code>UdpSocket</code>的<code>Evented.register()</code>函数被调用时，会将代理指向一个被封装的<code>EventedFd</code>，这个<code>EventedFd</code>会将套接字的文件描述符添加到 poll selector 中(最终会调用<code>epoll_ctl(fepd, EPOLL_CTL_ADD, fd, &amp;epoll_event)</code>，并将<code>epoll_event.data</code>设置为提供的token值)。当一个<code>UdpSocket</code>被注册后，它的<code>selector_id</code>会被设置为<code>Poll</code>的<code>selector_id</code>，从而与 selector 产生关联。</p>
<ol start="4">
<li><strong>在事件循环中调用 poll()</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    poll.poll(&amp;mut events, None).unwrap();
    for event in &amp;events {
        handle_event(event);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>system selector (<code>epoll_wait()</code>)和就绪队列将会轮询是否有新事件(<code>epoll_wait()会阻塞，但是由于非系统事件除了推送到就绪队列之外，还通过管道触发了epoll，因此仍需要及时处理它们。</code>)。这一系列事件的组合可供调用端处理。</p>
<h2 id="futures-和-任务"><a class="header" href="#futures-和-任务">Futures 和 任务</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures</a> 是从函数式编程中借用的技术，因此尚未发生的计算可以表示为一个 “future“，并且这些独立的 future 可以被组合起来以构建一个复杂的系统。这对于异步 I/O 很有用，因为执行事物的基本步骤可以建模成此类组合的 futures。在 HTTP 服务器的示例中，一个 future 可以通过读取字节来读取一个请求，直到到达请求的末端为止，此时将产生请求对象。另一个 future 可能会处理请求并产生响应。再另一个 future 可能会写入响应。</p>
<p>在 Rust 中，<a href="https://docs.rs/futures/0.1.17/futures/">futures 库</a> 实现了 futures，你可以通过实现 <a href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html">Future</a> 特征来定义一个 future，它需要实现一个<a href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#tymethod.poll">poll()</a> 方法，该方法在需要时会被调用，并允许 future 开始执行。此方法会返回一个错误或表示 future 仍在等待中，因此应稍后再调用<code>poll()</code>，或者当 future 已经完成时将产生一个值。<code>Future</code> 特征还提供了大量的组合器作为默认方法。</p>
<p>想要理解 futures，先要理解三个重要的概念：任务，执行器，通知 - 以及它们是如何在正确的时间调用 futures 的<code>poll()</code>方法的。每一个 future 都会在一个 <a href="https://docs.rs/futures/0.1.17/futures/task/index.html">任务</a>上下文中执行。一个任务直接与一个 future 相关联，但是这个 future 可能是个组合 future，它驱动着很多被包含的 future(举个例子，许多 future 通过<a href="https://docs.rs/futures/0.1.17/futures/future/fn.join_all.html">join_all()</a> 组合器组合到一个future 中，或者两个 future 通过 <a href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#method.and_then">and_then()</a> 组合器依次执行)。</p>
<p>任务和他们的 future 需要一个执行器来运行。一个执行器需要在正确的时间轮询任务/ future - 通常是当获得通知可以做一些进展时。当其他一些代码调用实现了 <a href="https://docs.rs/futures/0.1.17/futures/executor/trait.Notify.html">futures::executor::Notify</a> 特征所提供 <a href="https://docs.rs/futures/0.1.17/futures/executor/trait.Notify.html#tymethod.notify">notify()</a> 方法的对象时，就会产生这样的通知。futures 库中提供的一个及其简单的执行程序就是一个例子，当在 future 上调用 <a href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#method.wait">wait()</a> 方法时，该执行程序将被调用。查看<a href="https://github.com/alexcrichton/futures-rs/blob/0.1.17/src/task_impl/std/mod.rs#L233">源代码</a>)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Waits for the internal future to complete, blocking this thread's
/// execution until it does.
///
/// This function will call `poll_future` in a loop, waiting for the future
/// to complete. When a future cannot make progress it will use
/// `thread::park` to block the current thread.
pub fn wait_future(&amp;mut self) -&gt; Result&lt;F::Item, F::Error&gt; {
    ThreadNotify::with_current(|notify| {

        loop {
            match self.poll_future_notify(notify, 0)? {
                Async::NotReady =&gt; notify.park(),
                Async::Ready(e) =&gt; return Ok(e),
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>给定一个预先创建的 <a href="https://docs.rs/futures/0.1.17/futures/executor/struct.Spawn.html">futures::executor::Spawn</a> 对象来融合任务与 future，这个执行器在循环中调用 <a href="https://docs.rs/futures/0.1.17/futures/executor/struct.Spawn.html#method.poll_future_notify">poll_future_notify()</a>。<code>Notify</code>对象变成任务上下文的一部分，future 也在被轮询。如果一个 future 的<code>poll()</code>返回<code>Async::NotReady</code>表明 future 仍在等待中，需要在 future 中再次安排轮询。<code>Notify</code>对象可以通过 <a href="https://docs.rs/futures/0.1.17/futures/task/fn.current.html">futures::task::current()</a> 获取一个任务的句柄，并在 future 有进展后调用 <a href="https://docs.rs/futures/0.1.17/futures/task/struct.Task.html#method.notify">notify()</a> 方法(当一个 future 正在被轮询时，与其关联的任务信息被存储在 thread-local 中，可以通过<code>current()</code>访问到)。在上述示例中，如果轮询返回了<code>Async::NotReady</code>，执行器将会一直阻塞直到接收到通知。也许 future 会在另一个线程中开始一些工作，并在完成时调用<code>notify()</code>，也许<code>poll()</code>在返回<code>Async::NotReady</code>之前直接自己调用<code>notify()</code>(后者不是很常见，因为从理论上来说，<code>poll()</code>应该在返回之前继续取得进展)。</p>
<p>Tokio 事件循环更像是一种复杂的 (sophisticated) 执行器，与Mio 事件集成以驱动 future 完成。在这种情况下，指示套接字准备就绪的 Mio 事件将发送一个通知使得对应的 future 进行轮询。</p>
<p>处理 future 时，任务是最基础的执行单元，且基本上就是提供了某种多任务协作的<a href="https://en.wikipedia.org/wiki/Green_threads">绿色线程</a>，允许一个操作系统线程中有多个执行上下文。如果一个任务无法取得进展，会让处理器处理其他可执行的任务。理解通知发生在任务级别而非 future 级别是十分中重要的。当一个任务接收到通知，它将会轮询它的顶级 future，可能会导致其中某些或全部的子 future 都被轮询。举个例子，如果一个任务的顶级 future 是由其他 10 个 future <code>join_all()</code>的，其中一个 future 安排的任务被通知到，全部的 10 个任务都将被轮询。</p>
<h2 id="tokio-与-mio-的接口"><a class="header" href="#tokio-与-mio-的接口">Tokio 与 Mio 的接口</a></h2>
<p>Tokio 通过上面描述的 Mio “非系统事件”的特性将任务通知转换成为 Mio 的事件。当任务获取到 Mio 的<code>(Registration, SetReadiness)</code> 元组后，它使用 Mio 的轮询将<code>Registration</code>(它是一个<code>Evented</code>)进行注册，并在<code>MySetReadiness</code>中封装实现了<code>Notify</code>特征的<code>mio::SetReadiness</code>对象，查看<a href="https://github.com/tokio-rs/tokio-core/blob/0.1.10/src/reactor/mod.rs#L791">源码</a>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MySetReadiness(mio::SetReadiness);

impl Notify for MySetReadiness {
    fn notify(&amp;self, _id: usize) {
        self.0.set_readiness(mio::Ready::readable())
              .expect(&quot;failed to set readiness&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这种方式中，任务通知被转换成为 Mio 事件，且可以在 Tokio 事件处理与分派机制中与其他类型的 Mio 事件一起进行处理。</p>
<p>就像 Mio 封装了<code>std::net</code>结构(如：<code>UdpSocket</code>，<code>TcpListener</code>，<code>TcpStream</code>)以自定义功能一样，Tokio 也使用组合和装饰来提供这些类型的 Tokio的 感知版本。例如：Tokio 的<code>UdpSocket</code>看起来像这样：</p>
<p><img src="lang/rust/./img/udpsocket.svg" alt="udpsocket" /></p>
<p>Tokio 版本的这些 I/O 源类型提供的构造函数都需要一个指向事件循环的句柄(<a href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Handle.html">tokio_core::reactor::Handle</a>)。在初始化的时候，这些类型将会将它们的套接字注册到事件循环的 Mio 轮询中，以接收<code>edge-triggered</code>(一种 epoll 事件的触发方式)事件及其新分配的偶数数字的 token(下面会提及)。当底层 I/O 操作回传<code>WouldBlock</code>时，这些类型可以很方便地通知当前的任务来接收读/写就绪状态。</p>
<p>Tokio 在 Mio 上注册了很多 <code>Evented</code> 的类型，键入特定的 token：</p>
<ul>
<li>
<p>Token 0 (<code>TOKEN_MESSAGES</code>) 被用于 tokio 内部的消息队列，它提供了移除 I/O 来源，接收读写就绪通知的定时任务，配置超时时间，在事件循环的上下文中运行任意(arbitrary)闭包。这可以安全地与其他线程的事件循环进行通信。举个例子：<a href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Remote.html#method.spawn">Remote::spawn()</a> 通过消息系统将 future 传入事件循环中。</p>
<p>消息系统被实现为 <a href="https://docs.rs/futures/0.1.17/futures/sync/mpsc/index.html">futures::sync::mpsc</a> 流。作为一个 <a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html">futures::stream::Stream</a> (与 future 很像，但是它产生一系列的值而不是单个值)，使用上面提到的<code>MySetReadiness</code>方案执行此消息队列的处理，其中<code>Registration</code>是以<code>TOKEN_MESSAGES</code>令牌进行注册的。当接收到<code>TOKEN_MESSAGES</code>事件，他们会被分发给<code>consume_queue()</code>方法来进行处理(源码：<a href="https://github.com/tokio-rs/tokio-core/blob/0.1.10/src/reactor/mod.rs#L133">enum Message</a>，<a href="https://github.com/tokio-rs/tokio-core/blob/0.1.10/src/reactor/mod.rs#L403">consume_queue()</a>)。</p>
</li>
<li>
<p>Token 1 (<code>TOKEN_FUTURE</code>) 被用来通知主任务需要被轮询。这发生在主任务关联的通知被发布的时候(换句话说就是 future 或者其中的子 future 被传递给<code>Core::run()</code>，而不是通过<code>spawn()</code>运行在不同任务上的 future)。它同样使用一个<code>MySetReadiness</code>方案将 future 的通知转换成了 Mio 的事件。在一个 future 运行在主任务之前返回<code>Async::NotReady</code>，并以其所选的方式在稍后发布通知。当接收到<code>TOKEN_FUTURE</code>事件后，Tokio 事件循环将会重新轮询主任务。</p>
</li>
<li>
<p>大于 1 的偶数 Token (TOKEN_START + key * 2) 被用来表明 I/O 来源上的就绪状态的变更。key 是指与<code>Core::inner::io_dispatch Slab&lt;ScheduledIo&gt;</code>相关联的<code>Slab</code> key。当对应的 Tokio 源类型初始化时，Mio I/O 源类型(<code>UdpSocket</code>，<code>TcpListener</code>，<code>TcpStream</code>)使用此 token 自动进行注册。</p>
</li>
<li>
<p>大于 1 的奇数 Token (TOKEN_START + key * 2 + 1) 被用来表明一个已创建的任务(以及相关的 future)需要被轮询。key 是与<code>Core::inner::task_dispatch Slab&lt;ScheduledTask&gt;</code>相关联的<code>Slab</code> key。和<code>TOKEN_MESSAGES</code>与<code>TOKEN_FUTURE</code>事件相同，这里也使用了<code>MySetReadiness</code>方案。</p>
</li>
</ul>
<h2 id="tokio-事件循环"><a class="header" href="#tokio-事件循环">Tokio 事件循环</a></h2>
<p>Tokio，尤其是<a href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Core.html">tokio_core::reactor::Core</a>，提供了一个管理 future 和任务的事件循环，来驱动 future 的完成，它同样还提供了与 Mio 的接口，因此 I/O 事件将会导致正确的任务被通知到。使用事件循环设置使用 <a href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Core.html#method.new">Core::new()</a> 初始化 <code>Core</code> 以及 使用单个 future 调用<a href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Core.html#method.run">Core::run()</a>。事件循环将会在返回之前驱动提供的 future 完成。对于服务端应用，这个 future 更像是长期存活。它确实可能是这样，举个例子：使用一个<code>TcpListener</code>来一直接收新的连接，每个连接都会被自己的 future 进行处理，这些 future 运行在由<a href="https://docs.rs/tokio-core/0.1.10/tokio_core/reactor/struct.Handle.html#method.spawn">Handle.spawn()</a>创建的独立任务中。</p>
<p>下面的流程图概述了 Tokio 事件循环的基本步骤：</p>
<p><img src="lang/rust/./img/tokio-event-loop.svg" alt="tokio-event-loop" /></p>
<h2 id="当数据抵达套接字时发生了什么"><a class="header" href="#当数据抵达套接字时发生了什么">当数据抵达套接字时发生了什么？</a></h2>
<p>了解 Tokio 的一个有用的练习是检查当数据到达套接字时在事件循环中发生的步骤。我惊讶的发现这个过程最终分为两个部分，分别在事件循环内的各自迭代中，进行独立的 epoll 事务。第一部分负责当套接字读就绪(即 Mio 事件带着比 1 大的偶数 token 或者主任务的<code>TOKEN_FUTURE</code>)时，通过发送通知给对套接字感兴趣的任务。第二部分通过轮询任务及与其关联的 future 来处理通知(即 Mio 事件带着比 1 大的奇数 token)。我们来考虑以下情景：一个创建的 future 通过上层的 Tokio 事件循环 从 Linux 系统中的<code>UdpSocket</code>上读取数据，假设之前对 future 的轮询导致<code>recv_from()</code>返回了一个<code>WouldBlock</code>错误。</p>
<p><img src="lang/rust/./img/recv-sequence-1.svg" alt="recv-sequence-1" /></p>
<p>Tokio 事件轮询调用<code>mio::Poll::poll()</code>，该方法转而(在  Linux上 )调用<code>epoll_wait()</code>，进而阻塞某个监控中的文件修饰符发生了就绪状态变更的事件。当这些发生时，<code>epoll_wait()</code>返回一个<code>epoll_event</code>结构的数组，用来描述发生了什么事，这些结构通过 Mio 转换成<code>mio::Events</code>并返回给 Tokio(在 Linux 中，这个转换是零开销的，因为<code>mio::Events</code>只是<code>epoll_event</code>数组的一个元组结构)。在我们的例子中，假定数组中只有一个事件表明套接字已经读就绪。因为事件的 token 是大于 1 的偶数，因此 Tokio 将其解释为一个 I/O 事件，并在<code>Slab&lt;ScheduledIo&gt;</code>的相关元素中查找详细信息，该元素包含有关对这个套接字的读写就绪感兴趣的任务信息。然后，Tokio 通知读任务通过<code>MySetReadiness</code>调用 Mio 的<code>set_readiness()</code>。Mio 通过将事件详细信息添加到就绪队列，并将单个 0x01 字节写入就绪管道来处理这个非系统事件。</p>
<p><img src="lang/rust/./img/recv-sequence-2.svg" alt="recv-sequence-2" /></p>
<p>在 Tokio 的事件轮询来到下一个迭代后，它再一次轮询 Mio，Mio 则调用<code>epoll_wait()</code>，这时，该函数将会返回一个发生在 Mio 就绪管道上的读就绪事件。Mio 读取之前写入管道的 0x01 字节，并从就绪队列中取出最先的非系统事件的详细信息，并将该事件返回给 Tokio。因为事件的 Token 是大于 1 的奇数，Tokio 将其解释为任务通知事件，并在<code>Slab&lt;ScheduledIo&gt;</code>的相关元素中查找详细信息，该元素包含从<code>spawn()</code>返回的任务最初的<code>Spawn</code>对象。Tokio 通过 <a href="https://docs.rs/futures/0.1.17/futures/executor/struct.Spawn.html#method.poll_future_notify">poll_future_notify()</a> 轮询任务及其相关的 future。future 可能会在之后读取套接字上的数据知道它收到一个<code>WouldBlock</code>错误。</p>
<p>与其他异步 I/O 事件相比，这两种设计管道读写的迭代方式可能会增加一点开销。在单线程程序中，使用<code>strace</code>查看线程通过管道和它自己交流是很奇怪的：</p>
<pre><code class="language-c">pipe2([4, 5], O_NONBLOCK|O_CLOEXEC) = 0
...
epoll_wait(3, [{EPOLLIN|EPOLLOUT, {u32=14, u64=14}}], 1024, -1) = 1
write(5, &quot;\1&quot;, 1) = 1
epoll_wait(3, [{EPOLLIN, {u32=4294967295, u64=18446744073709551615}}], 1024, 0) = 1
read(4, &quot;\1&quot;, 128) = 1
read(4, 0x7ffce1140f58, 128) = -1 EAGAIN (Resource temporarily unavailable)
recvfrom(12, &quot;hello\n&quot;, 1024, 0, {sa_family=AF_INET, sin_port=htons(43106), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 6
recvfrom(12, 0x7f576621c800, 1024, 0, 0x7ffce1140070, 0x7ffce114011c) = -1 EAGAIN (Resource temporarily unavailable)
epoll_wait(3, [], 1024, 0) = 0
epoll_wait(3, 0x7f5765b24000, 1024, -1) = -1 EINTR (Interrupted system call)
</code></pre>
<p>Mio 使用这种管道的方式来支持可能从其他线程调用<code>set_readiness()</code>的一般情况，也许在强制事件的公平调度以及维护 future 与 I/O 之间的间接层方面也会有一些好处。</p>
<h2 id="收获组合-future-和-衍生-future"><a class="header" href="#收获组合-future-和-衍生-future">收获：组合 future 和 衍生 future</a></h2>
<p>当我第一次学习 Tokio 时，我写了一个小程序监听来自不同 UDP 套接字上的数据。我创建了 10 个 读取套接字的 future 实例，它们每一个都监听不同的端口。我天真的使用<a href="https://docs.rs/futures/0.1.17/futures/future/fn.join_all.html">join_all()</a> 将它们组合成一个 future，并将其传入<code>Core::run()</code>，然后惊讶的发现当单个数据包抵达时，每个 future 都在被轮询。同样让人惊讶的是<code>tokio_core::net::UdpSocket::recv_from()</code>已足够聪明，在先前的 Mio 轮询中，可以避免在未标记已就绪的套接字上实际调用操作系统的<code>recv_from()</code>。以下的<code>strace</code>反应出在 future 的<code>poll()</code>中的调试<code>println!()</code>，大致如下：</p>
<pre><code class="language-c">epoll_wait(3, [{EPOLLIN|EPOLLOUT, {u32=14, u64=14}}], 1024, -1) = 1
write(5, &quot;\1&quot;, 1) = 1
epoll_wait(3, [{EPOLLIN, {u32=4294967295, u64=18446744073709551615}}], 1024, 0) = 1
read(4, &quot;\1&quot;, 128) = 1
read(4, 0x7ffc183129d8, 128) = -1 EAGAIN (Resource temporarily unavailable)
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
recvfrom(12, &quot;hello\n&quot;, 1024, 0, {sa_family=AF_INET, sin_port=htons(43106), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 6
getsockname(12, {sa_family=AF_INET, sin_port=htons(2006), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 0
write(1, &quot;recv 6 bytes from 127.0.0.1:43106 at 127.0.0.1:2006\n&quot;, 52) = 52
recvfrom(12, 0x7f2a11c1c400, 1024, 0, 0x7ffc18312ba0, 0x7ffc18312c4c) = -1 EAGAIN (Resource temporarily unavailable)
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
write(1, &quot;UdpServer::poll()...\n&quot;, 21) = 21
epoll_wait(3, [], 1024, 0) = 0
epoll_wait(3, 0x7f2a11c36000, 1024, -1) = ...
</code></pre>
<p>因为 Tokio 和 futures 的内部机制对我来说有些模糊 (opaque)，我想我希望后台发生一些魔法规则只会轮询需要的 future。当然，在对 Tokio 有了更好的了解之后，很明显我的程序正在使用这样的 future。</p>
<p><img src="lang/rust/./img/futures-join.svg" alt="futures-join" /></p>
<p>这实际上可以正常工作，但不是最佳选择 - 特别是在你有很多套接字的情况下。因为通知是在任务级别发生的，因此在上面任何绿色框中排列的任何通知都将导致通知主要任务。它将轮询它的 <code>FromAll</code> future，使得所有的子 future 都将接受轮询。我真正需要的是一个主 future，它可以使用<code>Handle::spawn()</code>来启动封装在各自任务中的 future，这样的安排大致如下所示：</p>
<p><img src="lang/rust/./img/futures-spawn.svg" alt="futures-spawn" /></p>
<p>当任何 future 安排通知时，只有 future 特定的任务会被通知到，并且只有该 future 会被轮询(回想一下，当<code>tokio_core::net::UdpSocket::recv_from()</code>从它的底层<code>mio::net::UdpSocket::recv_from()</code>调用中接收到<code>WouldBlock</code>时，“安排通知”会自动发生)。future 的组合器是用来描述协议流的强大工具，否则将在手动状态机中实现该协议流，但是了解你的设计可能需要在何处支持独立且并行执行的任务，这一点很重要。</p>
<h2 id="最后的思考"><a class="header" href="#最后的思考">最后的思考</a></h2>
<p>学习 Tokio的源码，Mio 以及 futures 确实有助于巩固我对 Tokio 的理解，并通过理解具体的实现来验证我的抽象策略。这种方法在仅学习抽象层的狭隘使用案例时非常危险，我们必须意识到具体的示例仅是助于理解的一般用例，在阅读了源码之后再学习 Tokio 的教程，我有一些马后炮的意见：Tokio 非常合理，应该很容易理解与上手。</p>
<p>我仍有一些问题待日后研究：</p>
<ul>
<li>
<p>Tokio 是否能够处理边缘触发的饥饿问题？我想将来可以通过限制单个<code>poll()</code>中的读写次数来处理它。当达到极限时， future 可以在明确通知当前任务后提前返回，而不是依赖于 Tokio 的 I/O 源类型的隐式“定时<code>WouldBlock</code>”的行为，从而使其他任务及 future 有机会取得进展。</p>
</li>
<li>
<p>Tokio 是否支持以任何方式在多线程中运行事件循环，而不是依靠寻找机会将工作分担给工作线程以最大程度地利用处理器内核。</p>
</li>
</ul>
<p>2017-12-19 更新：这里有 <a href="https://www.reddit.com/r/rust/comments/7klghl/tokio_internals_understanding_rusts_asynchronous/">Reddit thread on r/rust</a> 在讨论本文。Mio 的作者 Carl Lerche 在<a href="https://www.reddit.com/r/rust/comments/7klghl/tokio_internals_understanding_rusts_asynchronous/drfw5n1/">这里</a>和<a href="https://www.reddit.com/r/rust/comments/7klghl/tokio_internals_understanding_rusts_asynchronous/drfwc1m/">这里</a> 贴了些信息量很大的留言。除了回应上述问题，他也指出 <a href="https://docs.rs/futures/0.1.17/futures/stream/struct.FuturesUnordered.html">FuturesUnordered</a> 提供了一种组合 future 的方式，以便对相关的子 future 进行轮询，从而避免了像<code>join_all()</code>那样对每个 future 进行轮询，且需要权衡其他分配。同样，Tokio 的未来版本将从<code>mio::Registration</code>方案迁移到通知任务，这可以简化前面描述的某些步骤。</p>
<p>2017-12-21更新：看起来 Hacker News 也在讨论<a href="https://news.ycombinator.com/item?id=15972593">这篇文章</a>。</p>
<p>2018-01-26更新：我为 Tokio 的示例代码创建了一个<a href="https://github.com/simmons/tokio-aio-examples">Github仓库</a>。</p>
<h1 id="a-hrefhttpsgithubcomrustmagazinerust_magazine_2021blobmainsrcchapter_3arenas-in-rustmd转a-rust-中的-arenas"><a class="header" href="#a-hrefhttpsgithubcomrustmagazinerust_magazine_2021blobmainsrcchapter_3arenas-in-rustmd转a-rust-中的-arenas"><a href="https://github.com/RustMagazine/rust_magazine_2021/blob/main/src/chapter_3/arenas-in-rust.md">「转」</a> Rust 中的 Arenas</a></h1>
<blockquote>
<p>转载：<a href="https://github.com/RustMagazine/rust_magazine_2021">RustMagazine 2021 期刊</a> -&gt; <a href="https://github.com/RustMagazine/rust_magazine_2021/blob/main/src/chapter_3/arenas-in-rust.md">Rust 中的 Arenas</a></p>
</blockquote>
<h1 id="rust-中的-arenas-内存池"><a class="header" href="#rust-中的-arenas-内存池">Rust 中的 Arenas 内存池</a></h1>
<p>最近有一些关于 Rust 中 <code>Arenas</code> 的讨论，我想我应该写一篇关于这个的文章。</p>
<p>在 Rust 中，<code>Arenas</code> 并不是那种 &quot;典型的&quot; 问题，所以很少有人了解它们。只会在各种用例的应用程序中有看到它们。一般来说，你只需要调包就行了，没必要为它使用 <code>unsafe</code> 。因此无需专门去了解它，但这些知识也不是无用的，尤其是对使用 <code>Arenas</code> 的人来说更是如此 。</p>
<p>此外，我在实现自引用的 <code>Arenas</code> 时会涉及到一系列非常<em>酷</em>的 <code>lifetime</code>操作 ，我以前完全没写过。</p>
<p>我主要是为了一些<em>很酷</em>的生命周期效应而写的，但是我认为有必要写一篇针对所有 <code>Rustaceans</code> 的介绍。如果你已经知道什么是 <code>Arenas</code>，并且想看到一些很炫酷的 <code>lifetime</code> 技巧，则可以直接跳到<a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/#implementing-a-self-referential-arena">这里</a>阅读。</p>
<h2 id="什么是-arena-"><a class="header" href="#什么是-arena-">什么是 arena ?</a></h2>
<p><code>Arenas</code> 本质上是一种将生命周期相同的内存进行分组的模式。比如说有时需要在某个生命周期内分配一堆对象，之后这些对象将被全部销毁。每次都调用系统分配器效率低下，更可取的是为对象预分配一堆内存，并在完成处理后立即将其全部清理干净。</p>
<blockquote>
<p>译者注: 没错就是 cache</p>
</blockquote>
<p>从广义上讲，使用 <code>Arenas</code>  有以下两个原因：</p>
<p>首先，如上所述，使用它的主要目标是减轻内存消耗。例如，在游戏或应用程序中，可能存在大量对象需要逐帧分配，使用完立即销毁的情况。特别是在游戏开发中，这非常普遍，而内存压力是游戏开发人员比较关心的事情。使用 <code>Arenas</code>，可以轻松地分配一个 <code>Arena</code>，在每个帧中将其填满，并在帧结束后将其清空。缓存局部性还能其他好处：可以确保大多数每帧对象在帧期间（可能比其他对象使用得更多）位于缓存中，因为它们是相邻分配的。</p>
<p>另一个原因可能是用于编写<code>自引用</code>的数据，例如带有环的复杂图，使用此方法可以一次性清除全部数据。例如，在编写编译器时，类型信息可能将需要引用其他类型或者其他数据，从而导致复杂的类型有环图。一旦推导出类型，就不需要专门销毁它了，因此可以使用一个 <code>Arenas</code> 来存储所有计算出的类型信息，当类型信息无关紧要时，就可以直接将他们一次性清楚。使用这种模式可以让代码不必担心自引用位是否会 “提前” 释放，它可以保证，如果存在一个 <code>Ty</code> ，则它的寿命与其他所有 <code>Ty</code> 一样长，并且可以直接引用它们。</p>
<blockquote>
<p>译者注: 不会导致空引用</p>
</blockquote>
<p>这两个目标不一定是相互联系的：可以使用一个 <code>Arenas</code> 来同时实现两个目标。但是，也可以拥有一个禁止使用自我引用类型的 <code>Arenas</code>（有得有失，你能得到一些好处）。在本文的稍后部分，我将实现一个允许自我引用类型但对减轻内存分配压力影响不大的 <code>Arenas</code>，主要是为了易于实现。<em>通常</em>，如果你正在为自引用类型编写 <code>Arenas</code>，则可以使其同时减少分配器压力，但可能会有所取舍。</p>
<h2 id="在-rust-中如何使用-arena-"><a class="header" href="#在-rust-中如何使用-arena-">在 Rust 中如何使用 arena ?</a></h2>
<p>一般来说，要使用 arena ，只需要调包。 我简单的搜索一下现有的 <code>Arenas</code> 实现，在<a href="https://crates.io/search?q=arena">这里</a>。下面我会介绍两个我已经了解的库，但我只是挂 &quot;二&quot; 漏万。</p>
<p>要指出的是，如果只需要环结构，而不必使用 <code>arenas</code> ，那么出色的 <a href="https://docs.rs/petgraph/">petgraph</a> 通常就足够了。 <a href="https://docs.rs/slotmap/">slotmap</a> 也很不错； 它是类似地图的数据结构，可用于基于分代索引的自引用数据。 </p>
<h3 id="bumpalo"><a class="header" href="#bumpalo">Bumpalo</a></h3>
<p><code>Bumpalo</code> 是一种快速的 <code>bump allocator[1]</code>，它允许异构的内容，并且仅在不关心析构函数运行的情况下才允许循环。</p>
<blockquote>
<p>参见: <a href="https://blog.codingnow.com/2013/11/bump_pointer_allocator.html">1</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bumpalo::Bump;

// (example slightly modified from `bumpalo` docs)

// Create a new arena to bump allocate into.
let bump = Bump::new();

// Allocate values into the arena.
let scooter = bump.alloc(Doggo {
    cuteness: u64::max_value(),
    age: 8,
    scritches_required: true,
});

// Happy birthday, Scooter!
scooter.age += 1;
<span class="boring">}
</span></code></pre></pre>
<p>每次对 <code>Bump::alloc()</code> 的调用都会返回对已分配对象的可变引用。 这可以分配不同的对象，它们甚至可以相互引用 (不用环的话,借用检查就会强制这样做) 。 默认情况下，它不会在其内容上调用析构函数。 但是，可以使用 <code>bumpalo::boxed</code>（或Nightly上的自定义分配器）来实现这个效果。 可以类似地使用 <code>bumpalo::collections</code>来获取 <code>bumpalo</code> 支持的向量和字符串。<code> bumpalo::boxed</code> 将不允许自引用。</p>
<h3 id="typed-arena"><a class="header" href="#typed-arena">typed-arena</a></h3>
<p><a href="https://docs.rs/typed-arena/">typed-arena</a>是一个 <code>areana</code> 分配器，它只能存储单一类型的对象，但是就可以循环引用： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example from typed-arena docs

use std::cell::Cell;
use typed_arena::Arena;

struct CycleParticipant&lt;'a&gt; {
    other: Cell&lt;Option&lt;&amp;'a CycleParticipant&lt;'a&gt;&gt;&gt;,
}

let arena = Arena::new();

let a = arena.alloc(CycleParticipant { other: Cell::new(None) });
let b = arena.alloc(CycleParticipant { other: Cell::new(None) });

// mutate them after the fact to set up a cycle
a.other.set(Some(b));
b.other.set(Some(a));
<span class="boring">}
</span></code></pre></pre>
<p>和 <code>bumpalo</code> 不同的是，<code>typed-arena</code> 当 <code>arena</code> 本身超出范围时，就会使用析构函数。</p>
<blockquote>
<p>你或许想知道，析构函数在引用数据上的安全性–毕竟，无论哪一个变量被第二次销毁，析构函数都会读到悬挂的引用。我们将在文章的后面对此进行介绍，但这与 <code>drop</code> 检查有关，特别是如果尝试自引用时，则 arena 元素本身允许的唯一显式析构函数将是带有适当标记类型的析构函数。</p>
</blockquote>
<h2 id="实现一个支持自引用的-arena"><a class="header" href="#实现一个支持自引用的-arena">实现一个支持自引用的 arena</a></h2>
<p>写自引用代码是很有趣的，因为 Rust 非常警惕自我参照数据。 但是 <code>areana</code> 可以让你清楚地将“我不在乎此对象”和“可以删除此对象”阶段分开，以允许自引用和循环类型出现。</p>
<blockquote>
<p>人们很少需要实现自己的 arena，Bumpalo 和 Typedarena 涵盖了大多数使用场景，实在没办法的话不妨先在 crates.io 上 找一下。 但是，如果你的确需要直接实现的话，或者对具体的生命周期细节感兴趣，那么本节适合你。</p>
</blockquote>
<p>实现带有 Entry 类型的 Arena 的关键是以下几种规则：</p>
<ul>
<li><code>Arena</code>和<code>Entry</code>都应具有生命周期参数：<code>Arena &lt;'arena&gt;</code>和<code>Entry &lt;'arena&gt;</code></li>
<li><code>Arena</code>方法都应将<code>Arena &lt;'arena&gt;</code>作为<code>＆'arena self</code>，即<code>self</code>的类型为<code>＆'arena Arena &lt;'arena&gt;</code></li>
<li><code>Entry</code>几乎应该始终以<code>＆'arena Entry &lt;'arena&gt;</code>的形式传递（为此创建别名非常有用）</li>
<li>使用内部可变性；<code>Arena</code>上的<code>＆mut self</code>将使所有代码停止编译。如果使用<code>unsafe</code>的可变性，请确保 <code>RefCell&lt;Entry&lt;'arena&gt;&gt;</code>  具有 <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a> 。</li>
</ul>
<p>从生命周期的角度来看基本上就是这样，剩下的全部就是确定所需的 API。掌握了以上规则，只要确保定义区域与所需的保证一起使用，就不必了解底层生命周期的状况。</p>
<p>让我们看一个实现，然后剖析其工作原理。 </p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<p>我的库 <a href="https://docs.rs/elsa">elsa</a> 在其中一个示例中使用 100％ <code>safe</code> 的代码实现了一个 <code>arena</code> 。由于 <code>elsa :: FrozenVec</code> 要求其内容位于间接引用之后，因此该 <code>arena</code> 无法节省分配，并且它不是通用的，但这是一种合理的方式来说明生命周期的工作方式，而无需陷入 使用 <code>unsafe</code> 带来的麻烦之中。</p>
<p>该示例实现了 <code>Person &lt;'arena&gt;</code> 类型的 <code>Arena</code> ，<code>Arena &lt;'arena&gt;</code> 。目标是实现某种可能有环的有向社交图。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use elsa::FrozenVec;

struct Arena&lt;'arena&gt; {
    people: FrozenVec&lt;Box&lt;Person&lt;'arena&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/elsa/1.4.0/elsa/vec/struct.FrozenVec.html">elsa::FrozenVec</a> 是类似于 <code>Vec</code> 的仅支持追加内容的抽象，可让你调用<code>push</code> 而不需要传入可变的引用，这是只使用 <code>safe</code> 的一个实现。</p>
<p>每个 <code>Person &lt;'arena&gt;</code> 都有一个他们关注的人的列表，但也跟踪他们关注的人：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person&lt;'arena&gt; {
    pub follows: FrozenVec&lt;PersonRef&lt;'arena&gt;&gt;,
    pub reverse_follows: FrozenVec&lt;PersonRef&lt;'arena&gt;&gt;,
    pub name: &amp;'static str,
}

// following the rule above about references to entry types
type PersonRef&lt;'arena&gt; = &amp;'arena Person&lt;'arena&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这个生命周期 <code>arena</code>  其实是 “arena本身的生命周期”。 从这开始事情就变得奇怪起来了：通常，如果一个有生命周期参数，则调用者可以选择其中的内容。 不必只是说“这是对象本身的生命周期”，调用者通常可以根据需要实例化 <code>arena &lt;'static&gt;</code> 或为某个 <code>'a</code> 实例化 <code>Arena &lt;'a&gt;</code> 。 但是在这里，我们声明 “<code>'arena</code> 是 <code>arena</code> 自身的生命周期”； 很明显，一定有东西不太对。</p>
<p>这是我们实际实现的地方：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'arena&gt; Arena&lt;'arena&gt; {
    fn new() -&gt; Arena&lt;'arena&gt; {
        Arena {
            people: FrozenVec::new(),
        }
    }
    
    fn add_person(&amp;'arena self, name: &amp;'static str,
                  follows: Vec&lt;PersonRef&lt;'arena&gt;&gt;) -&gt; PersonRef&lt;'arena&gt; {
        let idx = self.people.len();
        self.people.push(Box::new(Person {
            name,
            follows: follows.into(),
            reverse_follows: Default::default(),
        }));
        let me = &amp;self.people[idx];
        for friend in &amp;me.follows {
            // We're mutating existing arena entries to add references,
            // potentially creating cycles!
            // 把每一个元素都加上了 引用 , 很有可能导致循环引用
            friend.reverse_follows.push(me)
        }
        me
    }

    fn dump(&amp;'arena self) {
        // code to print out every Person, their followers, and the people who follow them
        // 打印出 `Person` ,他们的关注者 ,和关注的人
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>注意 <code>add_person中的&amp;'arena self</code>。</p>
<p>此处的很好的实现了,“如果A 关注了 B，然后B又关注A” 这种通常需要分开处理的情况，但这仅是示例。</p>
<p>最后，我们可以像这样使用 <code>arena</code> ：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arena = Arena::new();
    let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
    let best_friend = arena.add_person(&quot;best friend&quot;, vec![lonely]);
    let threes_a_crowd = arena.add_person(&quot;threes a crowd&quot;, vec![lonely, best_friend]);
    let rando = arena.add_person(&quot;rando&quot;, vec![]);
    let _everyone = arena.add_person(&quot;follows everyone&quot;, vec![rando, threes_a_crowd, lonely, best_friend]);
    arena.dump();
}
</code></pre></pre>
<p>在这种情况下，所有 “可变性” 都发生在 <code>arena</code> 本身的实现中，但是此代码可能会将元素直接添加到 <code>follows/reverse_follows</code> 列表中，或者 <code>Person</code> 可能具有用于其他类型链接的 <code>RefCells</code> 。</p>
<h3 id="生命周期是如何工作的"><a class="header" href="#生命周期是如何工作的">生命周期是如何工作的</a></h3>
<p>那么这是如何工作的呢？ 如前所述，在 Rust 中使用这样的抽象，调用者通常可以自由地根据其处理方式来设置生存期。 例如，如果 <code>HashMap&lt;K，&amp;'a str&gt;</code>，则 <code>'a</code> 将根据你尝试插入的内容的生存期进行调整。</p>
<p>当构造 <code>Arena</code> 时，其生命周期确实仍然不受限制，我们可以通过检查以下强制约束生命周期的代码来进行测试(依然是能过编译的)。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena: Arena&lt;'static&gt; = Arena::new();
<span class="boring">}
</span></code></pre></pre>
<p>当你想做点什么的时候,就会停止工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena: Arena&lt;'static&gt; = Arena::new();
let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">error[E0597]: `arena` does not live long enough
  --&gt; examples/mutable_arena.rs:5:18
   |
4  |     let arena: Arena&lt;'static&gt; = Arena::new();
   |                -------------- type annotation requires that `arena` is borrowed for `'static`
5  |     let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
   |                  ^^^^^ borrowed value does not live long enough
...
11 | }
   | - `arena` dropped here while still borrowed
</code></pre>
<p><code>add_person</code> 方法以某种方式强制将 <code>Arena</code> 的 <code>arena</code> 参数设置为自己的生命周期，从而对其进行约束（并且无法用类型注释将其强制约束为其他任何值）。 这是与 <code>add_person</code> 的<code>＆'arena</code> 自签名（即 self 是 <code>＆'arena Arena &lt;'self&gt;</code> ）的巧妙互动，以及<code>'Arena in Arena &lt;'arena&gt;</code> 是<a href="https://doc.rust-lang.org/nomicon/subtyping.html#variance">不变的生命周期</a>。</p>
<p>通常，在 Rust 程序中，生命周期具有&quot;伸缩性&quot;。 以下代码可以通过编译：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ask for two strings *with the same lifetime*
// 要求具有相同 生命周期的 string 
fn take_strings&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) {}

// string literal with lifetime 'static
// 要求具有 `'static' 生命周期的 ` string literal`  
let lives_forever = &quot;foo&quot;;
// owned string with shorter, local lifetime
// 要求具有 `local` 生命周期
let short_lived = String::from(&quot;bar&quot;);

// still works!
// 能跑通
take_strings(lives_forever, &amp;*short_lived);
<span class="boring">}
</span></code></pre></pre>
<p>在这段代码中，Rust 很高兴地注意到，虽然 <code>live_forever</code> 和 <code>&amp;* short_lived</code> 具有不同的生命周期，但假装 <code>life_forever</code> 在 <code>take_strings</code> 函数的有效期内具有较短的生命周期是完全可以接受的。这只是引用，使用生命周期长的引用也适用于生命周期短的情况。</p>
<p>事实是，这种伸缩性并非对所用的生命周期都一样！<a href="https://doc.rust-lang.org/nomicon/subtyping.html">nomicon chapter on subtyping and variance</a> 一章详细说明了为什么会这样，但一般的经验法则是，大多数生命周期都是“紧缩的” (更专业的说法是 <code>协变的</code> )，就像上面的<code>&amp;a str</code> 中的一样，但是如果涉及某种形式的可变性，它们是不可变的，也称为“不变式”。如果使用的是函数类型，则具有 <code>弹性的</code> 生命周期 (即抗变的)，但是这种情况很少见。</p>
<p>我们的 <code>Arena &lt;'arena&gt;</code> 使用内部可变性（通过 <code>FrozenVec</code>）使' <code>arena</code>不变。 让我们再次看一下两行代码。当编译器看到下面代码的第一行时，便会构建 <code>arena</code>，我们将其生命周期称为“ a”。此时 Arena 类型是 <code>Arena &lt;'？&gt;</code> ，其中的'？由表示形式表示，但生命周期不受限制。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena = Arena::new(); 
let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<p>让我们把生命周期写清楚一点：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena = Arena::new(); // type Arena&lt;'?&gt;, lives for 'a

// explicitly write the `self` that gets constructed when you call add_person
// 显式写出 在调用 add_person 时的构建函数
let ref_to_arena = &amp;arena; // type &amp;'a Arena&lt;'?&gt;
let lonely = Arena::add_person(ref_to_arena, &quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<p>还记得我之前列出的第二条规则吗？</p>
<ul>
<li>Arena方法都应将Arena &lt;'arena&gt;接收为＆'arena自身，即其自身类型为＆'arena Arena &lt;'arena&gt; 我们遵循这条规则；</li>
</ul>
<p><code>add_person</code> 的签名是 <code>fn add_person(&amp;'arena self)</code>。这意味着 <code>ref_to_arena</code> 的生存期必须与 <code>&amp;'arena Arena &lt;'arena&gt;</code> 模式匹配。目前，它的生命周期是<code>&amp;'a Arena &lt;'?&gt;</code>，表示<code>'?</code>强制与'a相同，即 <code>arena</code> 变量本身的生存期。如果生命周期是可变的，则编译器可以压缩其他生存期来适配它，但它是不变的，并且不受限制的生存期被强制转变成一个确切的生命周期。</p>
<p>通过这个巧妙的技巧，我们可以强制编译器将 <code>Arena &lt;'arena&gt;</code> 的生存期参数设置为其实例的生存期。 </p>
<p>在此之后，其余的工作就非常简单了。 <code>Arena &lt;'arena&gt;</code> 拥有类型为 <code>Person &lt;'arena&gt;</code>的元素，也就是说：“<code>Person</code> 被允许引用具有 <code>'arena</code> 生命周期的元素, 例如 <code>Arena</code>“。</p>
<p><code>type PersonRef &lt;'arena&gt; =&amp;'arena Person &lt;'arena&gt;</code>是引用在 <code>Arena</code> 中并允许从其中引用对象 <code>Person</code> 的引用的便捷缩写。</p>
<h3 id="析构器如何工作"><a class="header" href="#析构器如何工作">析构器如何工作</a></h3>
<p>到目前为止，我还没有讨论存在析构函数的情况下如何保证安全。 如果 <code>Arena</code> 具 有循环引用，并且编写了一个析构函数读取去这些循环引用，那么在销毁的过程中就会导致悬垂引用。</p>
<p>这是 rust 十分模糊的地方。 除了“明确析构器巧妙地改变借用检查行为”，你没有什么需要必须去了解的。 但是了解这里的机制对建立一个更好的心智模型更有帮助。</p>
<p>如果将以下代码添加到 <code>arena</code> 示例中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'arena&gt; Drop for Person&lt;'arena&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;goodbye {:?}&quot;, self.name);
        for friend in &amp;self.reverse_follows {
            // potentially dangling!
            println!(&quot;\t\t{}&quot;, friend.name);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>报错:</p>
<pre><code class="language-shell">error[E0597]: `arena` does not live long enough
  --&gt; examples/mutable_arena.rs:5:18
   |
5  |     let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
   |                  ^^^^^ borrowed value does not live long enough
...
11 | }
   | -
   | |
   | `arena` dropped here while still borrowed
   | borrow might be used here, when `arena` is dropped and runs the destructor for type `Arena&lt;'_&gt;`
</code></pre>
<p>析构函数的存在在自引用数据的生命周期内巧妙地更改了借用检查器的行为。准确的规则是十分 <code>tricky</code>的，并在 <a href="https://doc.rust-lang.org/nomicon/dropck.html">nomicon</a>中进行了解释，但实际上发生的是，在Person &lt;'arena&gt;上存在自定义析构函数后，<code>'person arena</code>(因为是Arena)的<code>'arena</code>变成了一个“在销毁时观测到的的生命周期&quot;。然后在借用检查期间将其考虑在内---知道作用域末尾隐式调用<code>drop()</code>能够读取<code>'arena</code>的数据，Rust 做出了适当的结论，由于销毁本身是可变的操作，在销毁之后，调用<code>drop()</code> 读取内容是可行的。</p>
<p>当然，需要问的一个合理问题是，如果析构函数不允许用 <code>'arena</code> “包装”数据，应该如何在 <code>arena</code> 中存储例如 <code>Box</code> 或者 <code>FrozenVec</code>之类的东西呢？</p>
<p>原因是 Rust 知道 <code>Box::Drop</code>由于不清楚 <code>Person</code> 是什么,也不会去试图知道,而无法检查 <code>Person.follows</code>的内容。</p>
<p>当然凡事都有例外,由于析构器可以调用指定的 <code>trait</code> 方法(或者特化的方法)来告诉如何读取<code>Person</code>的内容,如果有一个随机的泛型类型提供了这种方法,就可以再次巧妙地更改借用检查器的行为。<code>stdlib</code> 类型和其他自定义数据结构通过转义填充<code>#[may_dangle]</code>（也称为“ eyepatch” 毕竟析构器 &quot;看不到&quot; 生命周期）来实现这种目的，声明不会从生命周期或通用参数中读取自定义析构函数。</p>
<p>这也适用于诸如 <a href="https://docs.rs/typed-arena/">typed-arena</a> 之类的库；如果需要创建循环引用，则将无法在为放置在 <code>arena</code>  上的类型上编写自定义析构函数。但是只要避免创建循环引用就可以使用 <code>typed-arena</code> 编写自定义析构函数了；因此将无法使用内部可变性来使一个 <code>arena</code> 指向另一个 <code>arena</code>。</p>
<p>感谢 <a href="https://mpc.sh/">Mark Cohen</a> 和 <a href="https://twitter.com/kneecaw/">Nika Layzell</a> 审阅了这篇文章的草稿。</p>
<h1 id="转rust-异步-io从-mio-到-coroutine"><a class="header" href="#转rust-异步-io从-mio-到-coroutine">「转」Rust 异步 I/O：从 mio 到 coroutine</a></h1>
<blockquote>
<p>转载：<a href="https://hexilee.me/2018/12/17/rust-async-io/">Rust 异步 I/O：从 mio 到 coroutine</a></p>
</blockquote>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E5%BC%82%E6%AD%A5-io-%E7%9A%84%E5%9F%BA%E7%9F%B3---mio">异步 IO 的基石 - mio</a>
<ul>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C-io">异步网络 IO</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E5%AE%B9%E9%94%99%E6%80%A7%E5%8E%9F%E5%88%99">容错性原则</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#poll-option">Poll Option</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#still-block">Still Block</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">自定义事件</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#callback-is-evil">Callback is evil</a></li>
</ul>
</li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#coroutine">coroutine</a>
<ul>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#generator">generator</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E8%87%AA%E5%BC%95%E7%94%A8">自引用</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#pin">Pin</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E5%90%88%E7%90%86%E7%9A%84%E6%8A%BD%E8%B1%A1">合理的抽象</a>
<ul>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#pollt">Poll&lt;T&gt;</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#await">await!</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#async">async</a></li>
</ul>
</li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#non-blocking-coroutine">non-blocking coroutine</a>
<ul>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#executor">Executor</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#block_on">block_on</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#spawn">spawn</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#tcplistener">TcpListener</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#tcpstream">TcpStream</a></li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#echo-server">echo-server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="lang/rust/07-Rust%E5%BC%82%E6%AD%A5IO:%E4%BB%8Emio%E5%88%B0coroutine.html#%E5%90%8E%E8%AE%B0">后记</a></li>
</ul>
<h3 id="引言"><a class="header" href="#引言">引言</a></h3>
<p>2018 年接近尾声，<code>rust</code> 团队勉强立住了异步 <code>IO</code> 的 flag，<code>async</code> 成为了关键字，<code>Pin</code>, <code>Future</code>, <code>Poll</code> 和 <code>await!</code> 也进入了标准库。不过一直以来实际项目中用不到这套东西，所以也没有主动去了解过。</p>
<p>最近心血来潮想用 <code>rust</code> 写点东西，但并找不到比较能看的文档（可能是因为 <code>rust</code> 发展太快了，很多都过时了），最后参考<a href="https://cafbit.com/post/tokio_internals/">这篇文章</a>和 <code>&quot;new tokio&quot;</code>( <a href="https://github.com/withoutboats/romio">romio</a> ) 写了几个 <code>demo</code>，并基于 <code>mio</code> 在 <code>coroutine</code> 中实现了简陋的异步 <code>IO</code>。</p>
<p>最终实现的 file-server 如下：</p>
<pre><pre class="playground"><code class="language-rust">// examples/async-echo.rs

#![feature(async_await)]
#![feature(await_macro)]
#![feature(futures_api)]

#[macro_use]
extern crate log;

use asyncio::executor::{block_on, spawn, TcpListener, TcpStream};
use asyncio::fs_future::{read_to_string};
use failure::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    env_logger::init();
    block_on(new_server())?
}

const CRLF: &amp;[char] = &amp;['\r', '\n'];

async fn new_server() -&gt; Result&lt;(), Error&gt; {
    let mut listener = TcpListener::bind(&amp;&quot;127.0.0.1:7878&quot;.parse()?)?;
    info!(&quot;Listening on 127.0.0.1:7878&quot;);
    while let Ok((stream, addr)) = await!(listener.accept()) {
        info!(&quot;connection from {}&quot;, addr);
        spawn(handle_stream(stream))?;
    }
    Ok(())
}

async fn handle_stream(mut stream: TcpStream) -&gt; Result&lt;(), Error&gt; {
    await!(stream.write_str(&quot;Please enter filename: &quot;))?;
    let file_name_vec = await!(stream.read())?;
    let file_name = String::from_utf8(file_name_vec)?.trim_matches(CRLF).to_owned();
    let file_contents = await!(read_to_string(file_name))?;
    await!(stream.write_str(&amp;file_contents))?;
    stream.close();
    Ok(())
}
</code></pre></pre>
<p>写这篇文章的主要目的是梳理和总结，同时也希望能给对这方面有兴趣的 <code>Rustacean</code> 作为参考。本文代码以易于理解为主要编码原则，某些地方并没有太考虑性能，还请见谅；但如果文章和代码中有明显错误，欢迎指正。</p>
<p>本文代码仓库在 <a href="https://github.com/Hexilee/async-io-demo">Github</a> （部分代码较长，建议 <code>clone</code> 下来用编辑器看），所有 <code>examples</code> 在 <code>nightly-x86_64-apple-darwin 2018 Edition</code> 上均能正常运行。运行 <code>example/async-echo</code>  时设置 <code>RUST_LOG</code> 为 <code>info</code> 可以在 terminal 看到基本的运行信息，<code>debug</code> 则可见事件循环中的事件触发顺序。</p>
<h3 id="异步-io-的基石---mio"><a class="header" href="#异步-io-的基石---mio">异步 <code>IO</code> 的基石 - <code>mio</code></a></h3>
<p><code>mio</code> 是一个极简的底层异步 <code>IO</code> 库，如今 <code>rust</code> 生态中几乎所有的异步 <code>IO</code> 程序都基于它。</p>
<p>随着 <code>channel</code>, <code>timer</code> 等 <code>sub module</code> 在 <code>0.6.5</code> 版本被标为 <code>deprecated</code>，如今的 mio 提供的唯二两个核心功能分别是：</p>
<ul>
<li>对操作系统异步网络 <code>IO</code> 的封装</li>
<li>用户自定义事件队列</li>
</ul>
<p>第一个核心功能对应到不同操作系统分别是</p>
<ul>
<li><code>Linux(Android) =&gt; epoll</code></li>
<li><code>Windows =&gt; iocp</code></li>
<li><code>MacOS(iOS), FreeBSD =&gt; kqueue</code> </li>
<li><code>Fuchsia =&gt; &lt;unknown&gt;</code></li>
</ul>
<p>mio 把这些不同平台上的 API 封装出了一套 <code>epoll like</code> 的异步网络 API，支持 <code>udp 和 tcp</code>。</p>
<blockquote>
<p>除此之外还封装了一些不同平台的拓展 API，比如 <code>uds</code>，本文不对这些 API 做介绍。</p>
</blockquote>
<h4 id="异步网络-io"><a class="header" href="#异步网络-io">异步网络 IO</a></h4>
<p>下面是一个 <code>tcp</code> 的 <code>demo</code></p>
<pre><pre class="playground"><code class="language-rust">// examples/tcp.rs

use mio::*;
use mio::net::{TcpListener, TcpStream};
use std::io::{Read, Write, self};
use failure::Error;
use std::time::{Duration, Instant};

const SERVER_ACCEPT: Token = Token(0);
const SERVER: Token = Token(1);
const CLIENT: Token = Token(2);
const SERVER_HELLO: &amp;[u8] = b&quot;PING&quot;;
const CLIENT_HELLO: &amp;[u8] = b&quot;PONG&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let addr = &quot;127.0.0.1:13265&quot;.parse()?;

// Setup the server socket
    let server = TcpListener::bind(&amp;addr)?;

// Create a poll instance
    let poll = Poll::new()?;

// Start listening for incoming connections
    poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge())?;

// Setup the client socket
    let mut client = TcpStream::connect(&amp;addr)?;

    let mut server_handler = None;

// Register the client
    poll.register(&amp;client, CLIENT, Ready::readable() | Ready::writable(),
                  PollOpt::edge())?;

// Create storage for events
    let mut events = Events::with_capacity(1024);

    let start = Instant::now();
    let timeout = Duration::from_millis(10);
    'top: loop {
        poll.poll(&amp;mut events, None)?;
        for event in events.iter() {
            if start.elapsed() &gt;= timeout {
                break 'top
            }
            match event.token() {
                SERVER_ACCEPT =&gt; {
                    let (handler, addr) = server.accept()?;
                    println!(&quot;accept from addr: {}&quot;, &amp;addr);
                    poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
                    server_handler = Some(handler);
                }

                SERVER =&gt; {
                    if event.readiness().is_writable() {
                        if let Some(ref mut handler) = &amp;mut server_handler {
                            match handler.write(SERVER_HELLO) {
                                Ok(_) =&gt; {
                                    println!(&quot;server wrote&quot;);
                                }
                                Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                                err =&gt; {
                                    err?;
                                }
                            }
                        }
                    }
                    if event.readiness().is_readable() {
                        let mut hello = [0; 4];
                        if let Some(ref mut handler) = &amp;mut server_handler {
                            match handler.read_exact(&amp;mut hello) {
                                Ok(_) =&gt; {
                                    assert_eq!(CLIENT_HELLO, &amp;hello);
                                    println!(&quot;server received&quot;);
                                }
                                Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                                err =&gt; {
                                    err?;
                                }
                            }
                        }
                    }
                }
                CLIENT =&gt; {
                    if event.readiness().is_writable() {
                        match client.write(CLIENT_HELLO) {
                            Ok(_) =&gt; {
                                println!(&quot;client wrote&quot;);
                            }
                            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                            err =&gt; {
                                err?;
                            }
                        }
                    }
                    if event.readiness().is_readable() {
                        let mut hello = [0; 4];
                        match client.read_exact(&amp;mut hello) {
                            Ok(_) =&gt; {
                                assert_eq!(SERVER_HELLO, &amp;hello);
                                println!(&quot;client received&quot;);
                            }
                            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                            err =&gt; {
                                err?;
                            }
                        }
                    }
                }
                _ =&gt; unreachable!(),
            }
        }
    };
    Ok(())
}
</code></pre></pre>
<p>这个 <code>demo</code> 稍微有点长，接下来我们把它一步步分解。</p>
<p>直接看主循环</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ...
    loop {
        poll.poll(&amp;mut events, None).unwrap();
        // ...
    }
}
</code></pre></pre>
<p>每次循环都得执行 <code>poll.poll</code>，第一个参数是用来存 <code>events</code> 的 <code>Events</code>， 容量是 <code>1024</code>；</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut events = Events::with_capacity(1024);
<span class="boring">}
</span></code></pre></pre>
<p>第二个参数是 <code>timeout</code>，即一个 <code>Option&lt;Duration&gt;</code>，超时会直接返回。返回类型是 <code>io::Result&lt;usize&gt;</code>。</p>
<blockquote>
<p>其中的 <code>usize</code> 代表 <code>events</code> 的数量，这个返回值是 <code>deprecated</code> 并且会在之后的版本移除，仅供参考</p>
</blockquote>
<p>这里我们设置了 <code>timeout = None</code>，所以当这个函数返回时，必然是某些事件被触发了。让我们遍历 <code>events</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  match event.token() {
      SERVER_ACCEPT =&gt; {
          let (handler, addr) = server.accept()?;
          println!(&quot;accept from addr: {}&quot;, &amp;addr);
          poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
          server_handler = Some(handler);
      }

      SERVER =&gt; {
          if event.readiness().is_writable() {
              if let Some(ref mut handler) = &amp;mut server_handler {
                  match handler.write(SERVER_HELLO) {
                      Ok(_) =&gt; {
                          println!(&quot;server wrote&quot;);
                      }
                      Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                      err =&gt; {
                          err?;
                      }
                  }
              }
          }
          if event.readiness().is_readable() {
              let mut hello = [0; 4];
              if let Some(ref mut handler) = &amp;mut server_handler {
                  match handler.read_exact(&amp;mut hello) {
                      Ok(_) =&gt; {
                          assert_eq!(CLIENT_HELLO, &amp;hello);
                          println!(&quot;server received&quot;);
                      }
                      Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                      err =&gt; {
                          err?;
                      }
                  }
              }
          }
      }
      CLIENT =&gt; {
          if event.readiness().is_writable() {
              match client.write(CLIENT_HELLO) {
                  Ok(_) =&gt; {
                      println!(&quot;client wrote&quot;);
                  }
                  Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                  err =&gt; {
                      err?;
                  }
              }
          }
          if event.readiness().is_readable() {
              let mut hello = [0; 4];
              match client.read_exact(&amp;mut hello) {
                  Ok(_) =&gt; {
                      assert_eq!(SERVER_HELLO, &amp;hello);
                      println!(&quot;client received&quot;);
                  }
                  Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                  err =&gt; {
                      err?;
                  }
              }
          }
      }
      _ =&gt; unreachable!(),
  }
<span class="boring">}
</span></code></pre></pre>
<p>我们匹配每一个 <code>event</code> 的 <code>token</code>，这里的 <code>token</code> 就是我用来注册的那些 <code>token</code>。比如我在上面注册了 <code>server</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start listening for incoming connections
poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge()).unwrap();

<span class="boring">}
</span></code></pre></pre>
<p>第二个参数就是 <code>token</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SERVER_ACCEPT: Token = Token(0);
<span class="boring">}
</span></code></pre></pre>
<p>这样当 <code>event.token() == SERVER_ACCEPT</code> 时，就说明这个事件跟我们注册的 <code>server</code> 有关，于是我们试图 <code>accept</code> 一个新的连接并把它注册进 <code>poll</code>，使用的 <code>token</code> 是 <code>SERVER</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (handler, addr) = server.accept()?;
println!(&quot;accept from addr: {}&quot;, &amp;addr);
poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
server_handler = Some(handler);
<span class="boring">}
</span></code></pre></pre>
<p>这样我们之后如果发现 <code>event.token() == SERVER</code>，我们就认为它和注册的 <code>handler</code> 有关：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if event.readiness().is_writable() {
    if let Some(ref mut handler) = &amp;mut server_handler {
        match handler.write(SERVER_HELLO) {
            Ok(_) =&gt; {
                println!(&quot;server wrote&quot;);
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
            err =&gt; {
                err?;
            }
        }
    }
}
if event.readiness().is_readable() {
    let mut hello = [0; 4];
    if let Some(ref mut handler) = &amp;mut server_handler {
        match handler.read_exact(&amp;mut hello) {
            Ok(_) =&gt; {
                assert_eq!(CLIENT_HELLO, &amp;hello);
                println!(&quot;server received&quot;);
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
            err =&gt; {
                err?;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这时候我们还需要判断 <code>event.readiness()</code>，这就是 <code>register</code> 函数的第三个参数，叫做 <code>interest</code>，顾名思义，就是“感兴趣的事”。它的类型是 <code>Ready</code>，一共四种，<code>readable, writable, error 和 hup</code>，可进行并运算。</p>
<p>在上面我们给 <code>handler</code> 注册了 <code>Ready::readable() | Ready::writable()</code>，所以 <code>event</code> 可能是 <code>readable</code> 也可能是 <code>writable</code>，所以我们要经过判断来执行相应的逻辑。注意这里的判断是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ... {
    ...
}

if ... {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>而非</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ... {
    ...
} else if ... {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>因为一个事件可能同时是 <code>readable</code> 和 <code>writable</code>。</p>
<h4 id="容错性原则"><a class="header" href="#容错性原则">容错性原则</a></h4>
<p>大概逻辑先讲到这儿，这里先讲一下 <code>mio</code> 的“容错性原则”，即不能完全相信 <code>event</code>。</p>
<p>可以看到我上面有一段代码是这么写的 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match event.token() {
     SERVER_ACCEPT =&gt; {
         let (handler, addr) = server.accept()?;
         println!(&quot;accept from addr: {}&quot;, &amp;addr);
         poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
         server_handler = Some(handler);
     }
<span class="boring">}
</span></code></pre></pre>
<p><code>server.accept()</code> 返回的是 <code>io::Result&lt;(TcpStream, SocketAddr)&gt;</code>。如果我们选择完全相信 <code>event</code> 的话，在这里 <code>unwrap()</code> 并没有太大问题 —— 如果真的有一个新的连接就绪，<code>accept()</code> 产生的 <code>io::Result</code> 是我们无法预料且无法处理的，我们应该抛给调用者或者直接 <code>panic</code>。</p>
<p>但问题就是，我们可以认为 <code>event</code> 的伪消息是可预料的，可能并没有一个新的连接准备就绪，这时候我们 <code>accept()</code> 会引发 <code>WouldBlock Error</code>。但我们不应该认为 <code>WouldBlock</code> 是一种错误 —— 这是一种友善的提醒。<code>server</code> 告诉我们：“并没有新的连接，请下次再来吧。”，所以在这里我们应该忽略（可以打个 <code>log</code>）它并重新进入循环。</p>
<p>像我后面写的那样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.write(CLIENT_HELLO) {
   Ok(_) =&gt; {
       println!(&quot;client wrote&quot;);
   }
   Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
   err =&gt; {
       err?;
   }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="poll-option"><a class="header" href="#poll-option">Poll Option</a></h4>
<p>好了，现在我们可以运行：</p>
<pre><code class="language-bash">[async-io-demo] cargo run --example tcp
</code></pre>
<p>terminal 里打印出了</p>
<pre><code class="language-bash">client wrote
accept from addr: 127.0.0.1:53205
client wrote
server wrote
server received
...
</code></pre>
<p>我们可以发现，在短短的 <code>10 millis</code> 内（<code>let timeout = Duration::from_millis(10);</code>），<code>server</code> 和 <code>client</code> 分别进行了数十次的读写！</p>
<p>如果我们不想进行这么多次读写呢？比如，我们只想让 <code>server</code> 写一次。在网络比较通畅的情况下，<code>client</code> 和 <code>server</code> 几乎一直是可写的，所以 <code>Poll::poll</code> 在数微秒内就返回了。</p>
<p>这时候就要看 <code>register</code> 的第四个参数了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge()).unwrap();

<span class="boring">}
</span></code></pre></pre>
<p><code>PollOpt::edge()</code> 的类型是 <code>PollOpt</code>，一共有 <code>level, edge, oneshot</code> 三种，他们有什么区别呢？</p>
<p>比如在我上面的代码里，</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if event.readiness().is_readable() {
    let mut hello = [0; 4];
    match client.read_exact(&amp;mut hello) {
        Ok(_) =&gt; {
            assert_eq!(SERVER_HELLO, &amp;hello);
            println!(&quot;client received&quot;);
        }
        Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
        err =&gt; {
            err?;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我在收到一个 <code>readable readiness</code> 时，只读了四个字节。如果这时候缓冲区里有八字节的数据，那么：</p>
<ul>
<li>如果我注册时使用 <code>PollOpt::level()</code>，我在下次 <code>poll</code> 时 <strong>一定</strong> 还能收到一次 <code>readable readiness event</code> （只要我没有主动执行 <code>set_readiness(Read::empty())</code>）；</li>
<li>如果我注册时使用 <code>PollOpt::edge()</code>，我在下次 <code>poll</code> 时 <strong>不一定</strong> 还能收到一次 <code>readable readiness event</code>；</li>
</ul>
<p>所以，使用 <code>PollOpt::edge()</code> 时有一个“排尽原则（<code>Draining readiness</code>）”，即每次触发 <code>event</code> 时一定要操作到资源耗尽返回 <code>WouldBlock</code>，即上面的代码要改成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if event.readiness().is_readable() {
    let mut hello = [0; 4];
    loop {
        match client.read_exact(&amp;mut hello) {
            Ok(_) =&gt; {
                assert_eq!(SERVER_HELLO, &amp;hello);
                println!(&quot;client received&quot;);
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; break,
            err =&gt; {
                err?;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>那么，<code>oneshot</code> 又是怎样的行为呢？让我们回到上面的问题，如果我们只想让 <code>handler</code> 写一次，怎么办 —— 注册时使用 <code>PollOpt::oneshot()</code>，即</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (handler, addr) = server.accept()?;
println!(&quot;accept from addr: {}&quot;, &amp;addr);
poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::oneshot())?;
server_handler = Some(handler);
<span class="boring">}
</span></code></pre></pre>
<p>这样的话，你只能收到一次 <code>SERVER</code> 事件，除非你使用 <code>Poll::reregister</code> 重新注册 <code>handler</code>。</p>
<blockquote>
<p><code>Poll::reregister</code> 可以更改 <code>PollOpt</code> 和 <code>interest</code></p>
</blockquote>
<h4 id="still-block"><a class="header" href="#still-block">Still Block</a></h4>
<p>其实上面这个 <code>demo</code> 还存在一个问题，即我们在回调代码块中使用了同步的 <code>IO</code> 操作 <code>println!</code>。我们要尽可能避免在回调的代码块里使用耗时的 <code>IO</code> 操作。</p>
<p>考虑到文件 <code>IO</code> (包括 <code>Stdin, Stdout, Stderr</code>) 速度很慢，我们只需要把所有的文件 <code>IO</code> 交给一个线程进行即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::{Sender, Receiver, channel, SendError};

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

impl Fs {
    pub fn new() -&gt; Self {
        let (sender, receiver) = channel();
        std::thread::spawn(move || {
            loop {
                match receiver.recv() {
                    Ok(task) =&gt; {
                        match task {
                            Task::Println(ref string) =&gt; println!(&quot;{}&quot;, string),
                            Task::Exit =&gt; return
                        }
                    },
                    Err(_) =&gt; {
                        return;
                    }
                }
            }
        });
        Fs { task_sender: sender }
    }

    pub fn println(&amp;self, string: String) {
        self.task_sender.send(Task::Println(string)).unwrap()
    }
}

pub enum Task {
    Exit,
    Println(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>之后，可以使用 <code>Fs::println</code> 替换所有的 <code>println!</code>。</p>
<h4 id="自定义事件"><a class="header" href="#自定义事件">自定义事件</a></h4>
<p>上面我们实现异步 <code>println</code> 比较简单，这是因为 <code>println</code> 并没有返回值，不需要进行后续操作。设想一下，如果要我们实现 <code>open</code> 和 <code>ready_to_string</code>，先异步地 <code>open</code> 一个文件，然后异步地 <code>read_to_string</code>，最后再异步地 <code>println</code>, 我们要怎么做？</p>
<p>最简单的写法是回调，像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/fs.rs

use crossbeam_channel::{unbounded, Sender};
use std::fs::File;
use std::io::Read;
use std::boxed::FnBox;
use std::thread;
use failure::Error;

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

pub struct FsHandler {
    io_worker: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
    executor: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
}

pub fn fs_async() -&gt; (Fs, FsHandler) {
    let (task_sender, task_receiver) = unbounded();
    let (result_sender, result_receiver) = unbounded();
    let io_worker = std::thread::spawn(move || {
        loop {
            match task_receiver.recv() {
                Ok(task) =&gt; {
                    match task {
                        Task::Println(ref string) =&gt; println!(&quot;{}&quot;, string),
                        Task::Open(path, callback, fs) =&gt; {
                            result_sender
                                .send(TaskResult::Open(File::open(path)?, callback, fs))?
                        }
                        Task::ReadToString(mut file, callback, fs) =&gt; {
                            let mut value = String::new();
                            file.read_to_string(&amp;mut value)?;
                            result_sender
                                .send(TaskResult::ReadToString(value, callback, fs))?
                        }
                        Task::Exit =&gt; {
                            result_sender
                                .send(TaskResult::Exit)?;
                            break;
                        }
                    }
                }
                Err(_) =&gt; {
                    break;
                }
            }
        }
        Ok(())
    });
    let executor = std::thread::spawn(move || {
        loop {
            let result = result_receiver.recv()?;
            match result {
                TaskResult::ReadToString(value, callback, fs) =&gt; callback.call_box((value, fs))?,
                TaskResult::Open(file, callback, fs) =&gt; callback.call_box((file, fs))?,
                TaskResult::Exit =&gt; break
            };
        };
        Ok(())
    });

    (Fs { task_sender }, FsHandler { io_worker, executor })
}

impl Fs {
    pub fn println(&amp;self, string: String) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Println(string))?)
    }

    pub fn open&lt;F&gt;(&amp;self, path: &amp;str, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::Open(path.to_string(), Box::new(callback), self.clone()))?)
    }

    pub fn read_to_string&lt;F&gt;(&amp;self, file: File, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::ReadToString(file, Box::new(callback), self.clone()))?)
    }

    pub fn close(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Exit)?)
    }
}

impl FsHandler {
    pub fn join(self) -&gt; Result&lt;(), Error&gt; {
        self.io_worker.join().unwrap()?;
        self.executor.join().unwrap()
    }
}

type FileCallback = Box&lt;FnBox(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;
type StringCallback = Box&lt;FnBox(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;

pub enum Task {
    Exit,
    Println(String),
    Open(String, FileCallback, Fs),
    ReadToString(File, StringCallback, Fs),
}

pub enum TaskResult {
    Exit,
    Open(File, FileCallback, Fs),
    ReadToString(String, StringCallback, Fs),
}

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// examples/fs.rs

use asyncio::fs::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = &quot;Hello, World!&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open(&quot;./examples/test.txt&quot;, |file, fs| {
        fs.read_to_string(file, |value, fs| {
            assert_eq!(TEST_FILE_VALUE, &amp;value);
            fs.println(value)?;
            fs.close()
        })
    })?;
    fs_handler.join()?;
    Ok(())
}
</code></pre></pre>
<p>测试</p>
<pre><code class="language-bash">[async-io-demo] cargo run --example fs
</code></pre>
<p>这样写在逻辑上的确是对的，但是负责跑 <code>callback</code> 的 <code>executor</code> 线程其实被负责 <code>io</code> 的线程阻塞住了（<code>result_receiver.recv()</code>）。那我们能不能在 <code>executor</code> 线程里跑一个事件循环，以达到不被 <code>io</code> 线程阻塞的目的呢？（即确定 <code>result_receiver</code> 中有 <code>result</code> 时，<code>executor</code> 才会进行 <code>result_receiver.recv()</code>）.</p>
<p>这就到了体现 <code>mio</code> 强大可拓展性的时候：注册用户态的事件队列。</p>
<p>把上面的代码稍加修改，就成了这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/fs_mio.rs

use crossbeam_channel::{unbounded, Sender, TryRecvError};
use std::fs::File;
use std::io::{Read};
use std::boxed::FnBox;
use std::thread;
use failure::Error;
use std::time::Duration;
use mio::*;

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

pub struct FsHandler {
    io_worker: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
    executor: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
}

const FS_TOKEN: Token = Token(0);

pub fn fs_async() -&gt; (Fs, FsHandler) {
    let (task_sender, task_receiver) = unbounded();
    let (result_sender, result_receiver) = unbounded();
    let poll = Poll::new().unwrap();
    let (registration, set_readiness) = Registration::new2();
    poll.register(&amp;registration, FS_TOKEN, Ready::readable(), PollOpt::oneshot()).unwrap();
    let io_worker = std::thread::spawn(move || {
        loop {
            match task_receiver.recv() {
                Ok(task) =&gt; {
                    match task {
                        Task::Println(ref string) =&gt; println!(&quot;{}&quot;, string),
                        Task::Open(path, callback, fs) =&gt; {
                            result_sender
                                .send(TaskResult::Open(File::open(path)?, callback, fs))?;
                            set_readiness.set_readiness(Ready::readable())?;
                        }
                        Task::ReadToString(mut file, callback, fs) =&gt; {
                            let mut value = String::new();
                            file.read_to_string(&amp;mut value)?;
                            result_sender
                                .send(TaskResult::ReadToString(value, callback, fs))?;
                            set_readiness.set_readiness(Ready::readable())?;
                        }
                        Task::Exit =&gt; {
                            result_sender
                                .send(TaskResult::Exit)?;
                            set_readiness.set_readiness(Ready::readable())?;
                            break;
                        }
                    }
                }
                Err(_) =&gt; {
                    break;
                }
            }
        }
        Ok(())
    });

    let executor = thread::spawn(move || {
        let mut events = Events::with_capacity(1024);
        'outer: loop {
            poll.poll(&amp;mut events, Some(Duration::from_secs(1)))?;
            for event in events.iter() {
                match event.token() {
                    FS_TOKEN =&gt; {
                        loop {
                            match result_receiver.try_recv() {
                                Ok(result) =&gt; {
                                    match result {
                                        TaskResult::ReadToString(value, callback, fs) =&gt; callback.call_box((value, fs))?,
                                        TaskResult::Open(file, callback, fs) =&gt; callback.call_box((file, fs))?,
                                        TaskResult::Exit =&gt; break 'outer
                                    }
                                }
                                Err(e) =&gt; {
                                    match e {
                                        TryRecvError::Empty =&gt; break,
                                        TryRecvError::Disconnected =&gt; Err(e)?
                                    }
                                }
                            }
                        }
                        poll.reregister(&amp;registration, FS_TOKEN, Ready::readable(), PollOpt::oneshot())?;
                    }
                    _ =&gt; unreachable!()
                }
            }
        };
        Ok(())
    });
    (Fs { task_sender }, FsHandler { io_worker, executor })
}

impl Fs {
    pub fn println(&amp;self, string: String) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Println(string))?)
    }

    pub fn open&lt;F&gt;(&amp;self, path: &amp;str, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::Open(path.to_string(), Box::new(callback), self.clone()))?)
    }

    pub fn read_to_string&lt;F&gt;(&amp;self, file: File, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::ReadToString(file, Box::new(callback), self.clone()))?)
    }

    pub fn close(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Exit)?)
    }
}

impl FsHandler {
    pub fn join(self) -&gt; Result&lt;(), Error&gt; {
        self.io_worker.join().unwrap()?;
        self.executor.join().unwrap()
    }
}

type FileCallback = Box&lt;FnBox(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;
type StringCallback = Box&lt;FnBox(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;

pub enum Task {
    Exit,
    Println(String),
    Open(String, FileCallback, Fs),
    ReadToString(File, StringCallback, Fs),
}

pub enum TaskResult {
    Exit,
    Open(File, FileCallback, Fs),
    ReadToString(String, StringCallback, Fs),
}

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// examples/fs-mio.rs

use asyncio::fs_mio::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = &quot;Hello, World!&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open(&quot;./examples/test.txt&quot;, |file, fs| {
        fs.read_to_string(file, |value, fs| {
            assert_eq!(TEST_FILE_VALUE, &amp;value);
            fs.println(value)?;
            fs.close()
        })
    })?;
    fs_handler.join()?;
    Ok(())
}
</code></pre></pre>
<p>可以注意到，上面的代码发生的改变就是，<code>executor</code> 不再被 <code>result_receiver.recv</code> 阻塞，而变成了注册事件（<code>registration</code>）后等待 <code>Poll::poll</code> 返回事件；只有等到了新的事件，才会进行 <code>result_receiver.try_recv</code>。同时，<code>io_worker</code> 线程在 <code>send result</code> 之后会执行 <code>set_readiness.set_readiness(Ready::readable())?;</code>，以通知 <code>executor</code> 线程对相应结果做处理。</p>
<p>这样的话，<code>executor</code> 就不会被 <code>io worker</code> 阻塞了，因为我们可以把所有的事件都注册到 <code>executor</code> 上，<code>mio::Poll</code> 会同时监听多个事件（比如把 <code>fs</code> 和 <code>tcp</code> 结合起来）。</p>
<p>测试</p>
<pre><code class="language-bash">[async-io-demo] cargo run --example fs-mio
</code></pre>
<h4 id="callback-is-evil"><a class="header" href="#callback-is-evil">Callback is evil</a></h4>
<p>既然文件 <code>IO</code> 的 <code>executor</code> 不再会被 <code>io worker</code> 线程阻塞了，那我们来试试让 <code>fs</code> 和 <code>tcp</code>  共用一个 <code>poll</code> 然后建立一个简单的文件服务器吧。</p>
<p>但可以先等等，因为我已经开始觉得写 <code>callback</code> 有点难受了 —— 如果我们还想处理错误的话，会觉得更难受，像这样</p>
<pre><pre class="playground"><code class="language-rust">use asyncio::fs_mio::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = &quot;Hello, World!&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open(&quot;./examples/test.txt&quot;, 
        |file, fs| {
            fs.read_to_string(file, 
                |value, fs| {
                    assert_eq!(TEST_FILE_VALUE, &amp;value);
                    fs.println(value, 
                        |err| {
                            ...
                        }
                    );
                    fs.close()
                },
                |err| {
                    ...
                }
            )
        },
        |err| {
            ...
        }
    )?;
    fs_handler.join()?;
    Ok(())
}
</code></pre></pre>
<p>而且对 <code>rust</code> 来说，更加艰难的是闭包中的生命周期问题（闭包几乎不能通过捕获来借用环境变量）。这就意味着，如果我要借用环境中的某个变量，我要么 <code>clone</code> 它（如果它实现了 <code>Clone</code> 的话），要么把它作为闭包参数传入（意味着你要根据需要改每一层回调函数的签名，这太屎了）。</p>
<p>考虑到各种原因，<code>rust</code> 最终选择用 <code>coroutine</code> 作为异步 <code>IO</code> 的 <code>API</code> 抽象。</p>
<h3 id="coroutine"><a class="header" href="#coroutine">coroutine</a></h3>
<p>这里所说的 <code>coroutine</code> 是指基于 <code>rust generator</code> 的 <code>stackless coroutine</code> 而非早期被 <code>rust</code> 抛弃的 <code>green thread(stackful coroutine)</code>。</p>
<h4 id="generator"><a class="header" href="#generator">generator</a></h4>
<p><code>rust</code> 大概在今年五月份引入了 <code>generator</code>，但到现在还是 unstable 的 —— 虽说也没多少人用 stable（误</p>
<p>一个典型的斐波那契 <code>generator</code> 如下</p>
<pre><pre class="playground"><code class="language-rust">// examples/fab.rs

#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = fab(5);
    loop {
        match unsafe { gen.resume() } {
            GeneratorState::Yielded(value) =&gt; println!(&quot;yield {}&quot;, value),
            GeneratorState::Complete(ret) =&gt; {
                println!(&quot;return {}&quot;, ret);
                break;
            }
        }
    }
}

fn fab(mut n: u64) -&gt; impl Generator&lt;Yield=u64, Return=u64&gt; {
    move || {
        let mut last = 0u64;
        let mut current = 1;
        yield last;
        while n &gt; 0 {
            yield current;
            let tmp = last;
            last = current;
            current = tmp + last;
            n -= 1;
        }
        return last;
    }
}
</code></pre></pre>
<p>由于 <code>generator</code> 的“中断特性”，我们很自然的可以想到，如果用 <code>generator</code> 搭配 <code>mio</code>，给每个 <code>generator</code> 分配一个 <code>token</code>，然后 <code>poll mio</code> 的事件循环，收到一个唤醒事件就 <code>resume</code> 相应的 <code>generator</code>；每个 <code>generator</code> 在要阻塞的时候拿自己的 <code>token</code> 注册一个唤醒事件然后 <code>yield</code>，不就实现了“同步代码”的异步 <code>IO</code> 吗？</p>
<p>这样看来原理上来说已经稳了，但 <code>rust</code> 异步 <code>IO</code> 的天空依旧漂浮着两朵乌云。</p>
<h4 id="自引用"><a class="header" href="#自引用">自引用</a></h4>
<p>第一朵乌云和 <code>rust</code> 自身的内存管理机制有关。</p>
<p>如果你写出这样的 <code>generator</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn self_ref_generator() -&gt; impl Generator&lt;Yield=u64, Return=()&gt; {
    || {
        let x: u64 = 1;
        let ref_x: &amp;u64 = &amp;x;
        yield 0;
        yield *ref_x;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>rust</code> 一定会给你抛个错然后告诉你 &quot;borrow may still be in use when generator yields&quot;。编译器没有教你怎么修正可能会让你有些恐慌，去不存在的搜索引擎上查了查，你发现这和 <code>generator</code> 的实现有关。</p>
<p>前文中提到，<code>rust generator</code> 是 <code>stackless</code> 的，即它并不会保留一个完整的栈，而是根据不同的状态保留需要的变量。如果你把上面的代码改成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_ref_generator() -&gt; impl Generator&lt;Yield=u64, Return=()&gt; {
    || {
        let x: u64 = 1;
        let ref_x: &amp;u64 = &amp;x;
        yield *ref_x;
        yield 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在第一次 <code>yield</code> 结束之后，编译器会发现 <code>generator</code> 唯一需要保留的是字面量 <code>0</code>，所以这段代码可以顺利编译通过。但是，对于前面的 <code>generator</code>，第一次 <code>yield</code> 过后，编译器发现你需要同时保留 <code>x</code> 和它的引用 <code>ref_x</code>，这样的话 <code>generator</code> 就会变成类似这样的结构（仅供参考）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SomeGenerator&lt;'a&gt; {
    ...
    SomeState {
        _yield: u64,
        x: u64
        ref_x: &amp;'a u64
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>这就是 <code>rust</code> 中“臭名昭著” 的自引用，下面这段代码会发生什么呢</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        let mut a = A{b: 1, ref_b: None};
		a.ref_b = Some(&amp;a.b);
        a
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>你会发现它编译不过，当然这是很合理的，栈上的 a 变量拷贝出去之后其成员 b 的引用会失效，<code>rust</code>的生命周期机制帮你规避了这个问题。但即使你改成这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::{BorrowMut};

struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn boxed() -&gt; Box&lt;Self&gt; {
        let mut a = Box::new(A{b: 1, ref_b: None});
        let mut_ref: &amp;mut A = a.borrow_mut();
		mut_ref.ref_b = Some(&amp;mut_ref.b);
        a
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样按道理来说是没问题的，因为 a 的实体已经在堆上了，即使你拷贝它在栈上的引用，也不会改变其成员 b 的地址，引用一直是有效的 —— 但问题是，你没法跟编译器解释这事，编译器认为函数里面的 <code>&amp;mut_ref.b</code>只能活到函数结束，这样含有这个引用的 a 自然也不能 move 出来。</p>
<p>那你可能会想，那我就在外面再取引用就好了</p>
<pre><pre class="playground"><code class="language-rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        A{b: 1, ref_b: None}
    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = Some(&amp;a.b);
}
</code></pre></pre>
<p>这样的确没啥毛病，但是，你会发现自引用不仅阻止了 move，还阻止了你对 A 可变引用。。比如这样就编译不过</p>
<pre><pre class="playground"><code class="language-rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        A{b: 1, ref_b: None}
    }

    fn mute(&amp;mut self) {

    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = Some(&amp;a.b);
    a.mute();
}
</code></pre></pre>
<p>但远古的 <code>Future::poll</code> 签名就长这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>而直到现在 <code>Generator::resume</code> 的签名还是这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn resume(&amp;mut self) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这样的话自引用会导致 <code>generator</code> 无法实现 <code>Generator</code> 和 <code>Future</code> </p>
<p>在这种情况下，我们可以使用 <code>NonNull</code>来避过编译器的检查</p>
<pre><pre class="playground"><code class="language-rust">use std::ptr::NonNull;

struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;
}

impl A {
    fn new() -&gt; Self {
        A{b: 1, ref_b: NonNull::dangling()}
    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = NonNull::from(&amp;a.b);
}
</code></pre></pre>
<p>这样的确没有了烦人的生命周期约束，但也意味着你要自己保证内存安全 —— 绝对不能 move，也不能对其可变引用使用 <code>mem::replace</code> 或 <code>mem::swap</code> ，这样非常不妙。</p>
<h4 id="pin"><a class="header" href="#pin">Pin</a></h4>
<p>那有没有办法通过其它方式来保证能保证它不能被 move 或者取可变引用呢？这就是 <code>pin</code>的应用场景了。<code>pin</code>具体的内容可以看这篇 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">RFC</a>，本文只是简要说明一下。</p>
<p><code>rust</code> 默认给大部分类型实现了 <code>trait std::marker::Unpin</code>，这只是一个标记，表示这个类型 move 是安全的，这时候，<code>Pin&lt;'a, T&gt;</code> 跟 <code>&amp;'a mut T</code> 没有区别，你也可以安全地通过 <code>Pin::new(&amp;mut T)</code> 和 <code>Pin::as_mut(self: &amp;mut Pin&lt;T&gt;)</code>相互转换。</p>
<p>但对于不能安全 move 的类型，比如上面的 <code>A</code>，我们得先把它标记为 <code>!Unpin</code>，安全的标记方法是给它一个 <code>!Unpin</code>的成员，比如 <code>Pinned</code>。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(pin)]
use std::marker::{Pinned};

use std::ptr::NonNull;

struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;,
    _pin: Pinned,
}

impl A {
    fn new() -&gt; Self {
        A {
            b: 1,
            ref_b: NonNull::dangling(),
            _pin: Pinned,
        }
    }
}

fn main() {
    let mut a = A::new();
    let mut pinned = unsafe { Pin::new_unchecked(&amp;mut a) };
    let ref_b = NonNull::from(&amp;pinned.b);
    let mut_ref: Pin&lt;&amp;mut A&gt; = pinned.as_mut();
    unsafe {Pin::get_mut_unchecked(mut_ref).ref_b = ref_b};
    let unmoved = pinned;
    assert_eq!(unmoved.ref_b, NonNull::from(&amp;unmoved.b));
}
</code></pre></pre>
<p>从 <code>!Unpin</code> 的类型构建 <code>Pin</code> 总是 <code>unsafe</code> 的，它们通过 <code>Pin::new_unchecked</code> 和 <code>Pin::get_mut_unchecked</code> 相互转换。当然，我们在构建时是可以保证它是 <code>safe</code> ，我们只要完成这两个 <code>unsafe</code>的操作，就可以保证：</p>
<ul>
<li>永远不能 <code>safe</code> 地获得可变引用： <code>Pin::get_mut_unchecked</code> 是 <code>unsafe</code> 的</li>
<li>永远不能 <code>safe</code> 地 move：因为 <code>Pin</code> 只拥有可变引用，且由于<code>Pin::get_mut_unchecked</code> 是 <code>unsafe</code> 的，你不能 <code>safe</code> 地对其可变引用使用 <code>mem::replace</code> 或 <code>mem::swap</code></li>
</ul>
<p>当然，如果你不想在构建时使用 <code>unsafe</code>或者想获得 <code>a</code> 的所有权以便在函数间传递，你可以使用 <code>Box::pinned</code>从而把它分配在堆上</p>
<pre><pre class="playground"><code class="language-rust">struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;,
    _pin: Pinned,
}

impl A {
    fn boxed() -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let mut boxed = Box::pinned(A {
            b: 1,
            ref_b: NonNull::dangling(),
            _pin: Pinned,
        });
        let ref_b = NonNull::from(&amp;boxed.b);
        let mut_ref: Pin&lt;&amp;mut A&gt; = boxed.as_mut();
        unsafe { Pin::get_mut_unchecked(mut_ref).ref_b = ref_b };
        boxed
    }
}

fn main() {
    let boxed = A::boxed();
    let unmoved = boxed;
    assert_eq!(unmoved.ref_b, NonNull::from(&amp;unmoved.b));
}
</code></pre></pre>
<p>有了 <code>Pin</code> 之后，新版 <code>Future</code> 的定义就是这样的了</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, lw: &amp;LocalWaker) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="合理的抽象"><a class="header" href="#合理的抽象">合理的抽象</a></h4>
<p>既然已经打算钦定了 <code>coroutine</code> 作为异步 <code>IO</code> 的 <code>API</code> 抽象，那应该把哪些东西加入标准库、哪些东西加入语法支持、哪些东西交给第三方实现呢？让开发者手动调用 <code>unsafe</code> 的 <code>Generator::resume</code> 终归不是很妙，也不好把 <code>mio</code> 作为唯一的底层异步 <code>IO</code> 实现（如果这样的话不如把 <code>mio</code> 也并入标准库）。</p>
<p>现在的 <code>rust</code> 提供了 <code>async</code> 的语法支持（以前是用过程宏的实现的）、<code>await!</code>的标准库宏支持，标准库 <code>std::future</code> 的 <code>trait Future</code> 和 <code>struct GenFuture</code> ， 标准库 <code>std::task</code> 的  <code>enum Poll&lt;T&gt;, struct LocalWaker, struct Waker </code> 和 <code>trait UnsafeWaker</code>。</p>
<p>你需要给你的 <code>MyWaker</code> 实现 <code>trait UnsafeWaker</code>，用 <code>mio</code> 的话就用 <code>SetReadiness</code>，<code>unsafe fn wake(&amp;self)</code> 用 <code>SetReadiness::set_readiness</code> 实现。然后把 <code>MyWaker</code> 包在 <code>Waker, LocalWaker</code> 里面。</p>
<h5 id="pollt"><a class="header" href="#pollt">Poll&lt;T&gt;</a></h5>
<p><code>Poll&lt;T&gt;</code> 的定义为</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="await"><a class="header" href="#await">await!</a></h5>
<p><code>await!</code> 宏只能在 <code>async</code> 函数或者块里面用，传入一个 <code>Future</code></p>
<p><code>await!(future)</code>会被展开成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    if let Poll::Ready(x) = ::future::poll_with_tls(unsafe{
        Pin::new_unchecked(&amp;mut future)
    }) {
        break x;
    }
    yield
}
<span class="boring">}
</span></code></pre></pre>
<p><code>::future::poll_with_tls</code> 即 <code>thread-local waker</code>，就是你传给这个 <code>GenFuture::poll</code> 的 <code>LocalWaker</code>，</p>
<h5 id="async"><a class="header" href="#async">async</a></h5>
<p><code>async</code>则会把 <code>Generator</code> 包装成 <code>Future(GenFuture)</code> 。</p>
<p><code>GenFuture</code> 的相关定义如下</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GenFuture&lt;T: Generator&lt;Yield = ()&gt;&gt;(T);

impl&lt;T: Generator&lt;Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

impl&lt;T: Generator&lt;Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
    type Output = T::Return;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, lw: &amp;LocalWaker) -&gt; Poll&lt;Self::Output&gt; {
        set_task_waker(lw, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {
            GeneratorState::Yielded(()) =&gt; Poll::Pending,
            GeneratorState::Complete(x) =&gt; Poll::Ready(x),
        })
    }
}

pub fn from_generator&lt;T: Generator&lt;Yield = ()&gt;&gt;(x: T) -&gt; impl Future&lt;Output = T::Return&gt; {
    GenFuture(x)
}
<span class="boring">}
</span></code></pre></pre>
<p>这里可以看到，<code>GenFuture</code> 在每次调用 <code>self.0.resume</code> 之前会 <code>set_task_waker</code>，通过一个 <code>thread_local</code> 的变量中转，从而 <code>generator</code> 里面的 <code>future::poll</code> 能通过 <code>poll_with_tls</code> 拿到这个 <code>LocalWaker</code>。</p>
<p>所以，下面的代码</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn async_recv(string_channel: Receiver&lt;String&gt;) -&gt; String {
    await!(string_channel.recv_future())
}
<span class="boring">}
</span></code></pre></pre>
<p>会被类似地展开为这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn async_recv(string_channel: Receiver&lt;String&gt;) -&gt; impl Future&lt;Output = T::Return&gt; {
	from_generator(move || {
        let recv_future = string_channel.recv_future();
        loop {
            if let Poll::Ready(x) = ::future::poll_with_tls(unsafe{
                Pin::new_unchecked(&amp;mut recv_future)
            }) {
                break x;
            }
            yield
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="non-blocking-coroutine"><a class="header" href="#non-blocking-coroutine">non-blocking coroutine</a></h4>
<p>掌握了上文的基础知识后，我们就可以开始实践了。</p>
<p>coroutine 本身并不意味着“非阻塞”，你完全可以在两次 <code>yield</code> 之间调用阻塞 <code>IO</code> 的 <code>API</code> 从而导致阻塞。 非阻塞的关键在于，在将要阻塞的时候（比如某个 <code>API</code> 返回了 <code>io::ErrorKind::WouldBlock</code>），在 <code>GenFuture::poll</code> 中用底层异步接口注册一个事件和唤醒回调（<code>waker</code>）然后自身休眠（<code>yield</code>），底层异步调度在特定事件发生的时候回调唤醒这个 <code>Future</code>。</p>
<p>下面我参照 <code>romio</code> 的异步调度实现了 <code>Executor</code> <code>block_on, spawn, TcpListener</code> 和 <code>TcpStream</code>，代码较长，建议 <code>clone</code> 后用编辑器看。（请注意区分 <code>Poll(mio::Poll)</code> 与 <code>task::Poll</code> 以及 <code>net::{TcpListener, TcpStream}(mio::net::{TcpListener, TcpStream})</code> 与 <code>TcpListener, TcpStream</code>）</p>
<p><a href="https://github.com/Hexilee/async-io-demo/blob/master/src/executor.rs">src/executor.rs</a></p>
<h5 id="executor"><a class="header" href="#executor">Executor</a></h5>
<p><code>Executor</code> 中包含 <code>mio::Poll</code>，<code>main task waker</code> 及用来管理 <code>task</code> 和 <code>source</code> 的 <code>Slab</code> 各一个。其本身并没有实现什么特别的方法，主要是初始化为 <code>thread_local</code> 的 <code>EXECUTOR</code> 供其它函数借用。</p>
<h5 id="block_on"><a class="header" href="#block_on">block_on</a></h5>
<p><code>block_on</code> 函数会阻塞当前线程，传入参数是一个 <code>future: Future&lt;Output=T&gt;</code>，被称为 <code>main task</code>；返回值类型是 <code>T</code>。该函数一般在最外层被调用。</p>
<p><code>block_on</code> 会引用 <code>thread_local EXECUTOR</code>，主要逻辑是调用 <code>mio::Poll::poll</code> 来响应事件。<code>block_on</code> 把 <code>0 - MAX_RESOURCE_NUM(1 &lt;&lt; 31)</code> 个 <code>Token</code> 分为三类。</p>
<ul>
<li>
<p><code>main task token</code></p>
<p>收到 <code>Token</code> 为 <code>MAIN_TASK_TOKEN</code> 的事件即表示需要唤醒 <code>main task</code>，执行 <code>main_task.poll</code>，返回 <code>task::Poll::Ready(T)</code> 则 <code>block_on</code> 函数返回。</p>
</li>
<li>
<p><code>task token</code></p>
<p>奇数 <code>token</code> 表示由 <code>spawn</code> 函数分发的其它任务需要被唤醒，执行相应的 <code>task.poll</code>，<code>token</code> 和该事件在 <code>EXECUTOR.tasks</code> 中的 <code>index</code> 一一映射。</p>
</li>
<li>
<p><code>source token</code></p>
<p>偶数 <code>token</code> 表示由 <code>register_source</code> 函数注册的 <code>source</code>需要被分发，执行相应 <code>source</code> 的 <code>waker()</code> 以唤醒分发它们的 <code>task</code>。</p>
</li>
</ul>
<h5 id="spawn"><a class="header" href="#spawn">spawn</a></h5>
<p>分发任务</p>
<h5 id="tcplistener"><a class="header" href="#tcplistener">TcpListener</a></h5>
<p>包装了 <code>mio::net::TcpListener</code>，<code>accept</code> 方法返回一个 <code>Future</code>。</p>
<h5 id="tcpstream"><a class="header" href="#tcpstream">TcpStream</a></h5>
<p>包装了 <code>mio::net::TcpStream</code>, <code>read</code>和 <code>write</code> 方法均返回 <code>Future</code>。</p>
<h5 id="echo-server"><a class="header" href="#echo-server">echo-server</a></h5>
<p>实现了 <code>executor</code> 之后，我们可以就写一个简单的 <code>echo-server</code> 了</p>
<pre><pre class="playground"><code class="language-rust">// examples/async-echo

#![feature(async_await)]
#![feature(await_macro)]

#[macro_use]
extern crate log;

use asyncio::executor::{block_on, spawn, TcpListener};
use failure::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    env_logger::init();
    block_on(
        async {
            let mut listener = TcpListener::bind(&amp;&quot;127.0.0.1:7878&quot;.parse()?)?;
            info!(&quot;Listening on 127.0.0.1:7878&quot;);
            while let Ok((mut stream, addr)) = await!(listener.accept()) {
                info!(&quot;connection from {}&quot;, addr);
                spawn(
                    async move {
                        let client_hello = await!(stream.read())?;
                        let read_length = client_hello.len();
                        let write_length =
                            await!(stream.write(client_hello))?;
                        assert_eq!(read_length, write_length);
                        stream.close();
                        Ok(())
                    },
                )?;
            };
            Ok(())
        },
    )?
}

</code></pre></pre>
<pre><code class="language-bash">RUST_LOG=info cargo run --example async-echo
</code></pre>
<p>可以用 <code>telnet</code> 连上试试看。</p>
<h3 id="后记"><a class="header" href="#后记">后记</a></h3>
<p>当然最后还留了一个 demo，就是把文件 <code>IO</code> 也封装为 <code>coroutine</code> 的非阻塞 <code>IO</code>，实现在 <code>src/fs_future.rs</code> 中，这时可以运行本文开头给的 example 了。</p>
<pre><code class="language-bash">RUST_LOG=info cargo run --example file-server
</code></pre>
<p>用 <code>telnet</code> 测试</p>
<pre><code class="language-bash">[~] telnet 127.0.0.1 7878                                                                  
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Please enter filename: examples/test.txt
Hello, World!
Connection closed by foreign host.
</code></pre>
<p>读者有兴趣的话可以看一下 <a href="https://github.com/Hexilee/async-io-demo/blob/master/src/fs_future.rs">src/fs_future.rs</a> 中的实现，这里就不细说，接下来我们再谈谈现在 <code>coroutine API</code> 的不足。</p>
<p>我目前发现的主要问题就是不能在 <code>Future::poll</code> 中使用 <code>try</code>，导致出现 <code>Result</code> 的地方只能 <code>match</code>，希望之后会有比较好的解决方案（比如给 <code>task::Poll&lt;Result&lt;R, E&gt;&gt;</code> 实现 <code>Try</code>）。</p>
<p>第二个问题是 <code>Waker</code> 最里面装的是 <code>UnsafeWaker</code>的 <code>NonNull</code> 指针，当然我能理解 <code>rust</code> 团队有性能等其它方面的考虑，但如果用 <code>mio</code> 的 <code>set_readiness</code> 封装出 <code>MyWaker</code> 的话，<code>clone</code> 完全不需要 <code>NonNull</code>，而且我在实际编码时因为这个出过空指针错误。。希望以后能提供一个更安全的选择。</p>
<h1 id="转图解-rust-所有权与生命周期"><a class="header" href="#转图解-rust-所有权与生命周期">「转」图解 Rust 所有权与生命周期</a></h1>
<blockquote>
<p>转载：<a href="https://github.com/RustMagazine/rust_magazine_2021">RustMagazine 2021 期刊</a> -&gt; <a href="https://github.com/RustMagazine/rust_magazine_2021/blob/main/src/chapter_1/rust_ownership.md">图解 Rust 所有权与生命周期</a></p>
</blockquote>
</br>
<h2 id="1引言"><a class="header" href="#1引言">1.引言</a></h2>
<p><strong>所有权</strong>与<strong>生命周期</strong>是  <code>Rust</code>  语言非常核心的内容。其实不仅仅是 <code>Rust</code> 有这两个概念，在<code>C/C++</code> 中也一样是存在的。而几乎所有的内存安全问题也源于对所有权和生命周期的错误使用。只要是不采用垃圾回收来管理内存的程序语言，都会有这个问题。只是 <code>Rust</code> 在语言级明确了这两个概念，并提供了相关的语言特性让用户可以显式控制所有权的转移与生命周期的声明。同时编译器会对各种错误使用进行检查，提高了程序的内存安全性。</p>
<p>所有权和生命周期其涉及的语言概念很多，本文主要是对梳理出与“所有权与生命周期”相关的概念，并使用  <code>UML</code> 的类图表达概念间的关系，帮助更好的理解和掌握。</p>
<p><strong>图例说明</strong></p>
<p>本文附图都是 <code>UML</code> 类图，<code>UML</code> 类图可以用来表示对概念的分析。表达概念之间的依赖、继承、聚合、组成等关系。图中的每一个矩形框都是一个语义概念，有的是抽象的语言概念，有的是 <code>Rust</code> 库中的结构和 <code>Trait</code>。</p>
<p>所有图中使用的符号也只有最基础的几个。图 1 对符号体系做简单说明，主要解释一下表达概念之间的关系的符号语言。</p>
<div align=center>
    <img width="544" height="306" src="lang/rust/./img/rust_ownership_1.jpg">
</div>
<center>图 1UML 符号</center>
<p><strong>依赖关系：</strong></p>
<p>依赖是 <code>UML</code> 中最基础的关系语义。 以带箭头的虚线表示，<code>A</code> 依赖与 <code>B</code> 表达如下图。直观理解可以是 <code>A</code> “看的见” <code>B</code>，而 <code>B</code> 可以对 <code>A</code> 一无所知。比如在代码中 结构体 <code>A</code> 中有 结构体 <code>B</code> 的成员变量，或者 <code>A</code> 的实现代码中有 <code>B</code> 的局部变量。这样如果找不到 <code>B</code>，<code>A</code> 是无法编译通过的。</p>
<p><strong>关联关系：</strong></p>
<p>一条实线连接表示两个类型直接有关联，有箭头表示单向&quot;可见&quot;,无箭头表示相互之间可见。关联关系也是一种依赖，但是更具体。有时候两个类型之间的关联关系太复杂，需要用一个类型来表达，叫做关联类型，如例图中的 <code>H</code>.</p>
<p><strong>聚合与组成：</strong></p>
<p>聚合与组成都是表示的是整体和部分的关系。差别在于“聚合”的整体与部分可以分开，部分可以在多个整体之间共享。而“组成”关系中整体对部分有更强的独占性，部分不能被拆开，部分与整体有相同的生命周期。</p>
<p><strong>继承与接口实现：</strong></p>
<p>继承与接口实现都是一种泛化关系，<code>C</code> 继承自 <code>A</code>，表示 <code>A</code> 是更泛化的概念。<code>UML</code> 中各种关系语义也可以用 <code>UML</code> 自身来表达，如图 2：“关联”和“继承”都是“依赖”的具体体现方式。</p>
<div align=center>
    <img width="544" height="306" src="lang/rust/./img/rust_ownership_2.jpg">
</div>
<center>图 2用 UML表达UML自身</center>
<p><strong>总图</strong></p>
<p>图 3 是本文的总图，后续各节分局部介绍。</p>
<img src="lang/rust/./img/rust_ownership_3.png">
<center>图 3Rust 所有权与生命周期总图</center>
<h2 id="2所有权与生命周期期望解决的问题"><a class="header" href="#2所有权与生命周期期望解决的问题">2.所有权与生命周期期望解决的问题</a></h2>
<p>我们从图中间部分开始看起，所谓“所有权”是指对一个变量拥有了一块“内存区域”。这个内存区域，可以在堆上，可以在栈上，也可以在代码段，还有些内存地址是直接用于 <code>I/O</code> 地址映射的。这些都是内存区域可能存在的位置。</p>
<p>在高级语言中，这个内存位置要在程序中要能被访问，必然就会与一个或多个变量建立关联关系（低级语言如汇编语言，可以直接访问内存地址）。也就是说，通过这一个或多个变量，就能访问这个内存地址。</p>
<p>这就引出三个问题：</p>
<ol>
<li>内存的不正确访问引发的内存安全问题</li>
<li>由于多个变量指向同一块内存区域导致的数据一致性问题</li>
<li>由于变量在多个线程中传递，导致的数据竞争的问题</li>
</ol>
<p>由第一个问题引发的内存安全问题一般有 5 个典型情况：</p>
<ul>
<li>使用未初始化的内存</li>
<li>对空指针解引用</li>
<li>悬垂指针(使用已经被释放的内存)</li>
<li>缓冲区溢出</li>
<li>非法释放内存(释放未分配的指针或重复释放指针)</li>
</ul>
<img src="lang/rust/./img/rust_ownership_4.jpg">
<center>图 4变量绑定与内存安全的基本概念</center>
<p>这些问题在 <code>C/C++</code> 中是需要开发者非常小心的自己处理。 比如我们可以写一段 <code>C++</code> 代码，把这五个内存安全错误全部犯一遍。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

struct Point {
	int x;
	int y;
};

Point* newPoint(int x,int y) {
	Point p { .x=x,.y=y };
	return &amp;p; //悬垂指针
}

int main() {
	int values[3]= { 1,2,3 };
	std::cout&lt;&lt;values[0]&lt;&lt;&quot;,&quot;&lt;&lt;values[3]&lt;&lt;std::endl; //缓冲区溢出

	Point *p1 = (Point*)malloc(sizeof(Point));
	std::cout&lt;&lt;p1-&gt;x&lt;&lt;&quot;,&quot;&lt;&lt;p1-&gt;y&lt;&lt;std::endl; //使用未初始化内存

	Point *p2 = newPoint(10,10); //悬垂指针
	delete p2; //非法释放内存

	p1 = NULL;
	std::cout&lt;&lt;p1-&gt;x&lt;&lt;std::endl; //对空指针解引用
	return 0;
}
</code></pre>
<p>这段代码是可以编译通过的，当然，编译器还是会给出警告信息。这段代码也是可以运行的，也会输出信息，直到执行到最后一个错误处“对空指针解引用时”才会发生段错误退出。</p>
<p><code>Rust</code> 的语言特性为上述问题提供了解决方案，如下表所示：</p>
<table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody>
<tr><td><div style="width: 200px">使用未初始化的内存</div></td><td>编译器禁止变量读取未赋值变量</td></tr>
<tr><td><div style="width: 200px">对空指针解引用</div></td><td>使用 Option<T> 枚举替代空指针</td></tr>
<tr><td><div style="width: 200px">悬垂指针</div></td><td>生命周期标识与编译器检查</td></tr>
<tr><td><div style="width: 200px">缓冲区溢出</div></td><td>编译器检查，拒绝超越缓冲区边界的数据访问</td></tr>
<tr><td><div style="width: 200px">非法释放内存</div></td><td>语言级的 RAII 机制，只有唯一的所有者才有权释放内存</td></tr>
<tr><td><div style="width: 200px">多个变量修改同一块内存区域</div></td><td>允许多个变量借用所有权，但是同一时间只允许一个可变借用</td></tr>
<tr><td><div style="width: 200px">变量在多个线程中传递时的安全问题</div></td><td>对基本数据类型用 Sync 和 Send 两个 Trait 标识其线程安全特性，即能否转移所有权或传递可变借用，把这作为基本事实。再利用泛型限定语法和 Trait impl 语法描述出类型线程安全的规则。编译期间使用类似规则引擎的机制，基于基本事实和预定义规则为用户代码中的跨线程数据传递做推理检查。</td></tr>
</tbody></table>
<h2 id="3变量绑定与所有权的赋予"><a class="header" href="#3变量绑定与所有权的赋予">3.变量绑定与所有权的赋予</a></h2>
<p><code>Rust</code> 中为什么叫“变量绑定”而不叫“变量赋值&quot;。我们先来看一段 <code>C++</code> 代码，以及对应的 <code>Rust</code> 代码。</p>
<p>C++:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
int main()
{
	int a = 1;
	std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;   /* 输出 0x62fe1c */
	a = 2;
	std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;   /* 输出 0x62fe1c */
}
</code></pre>
<p>Rust:</p>
<pre><code class="language-Rust">fn main() {
	let a = 1;
	println!(&quot;a:{}&quot;,a);     // 输出1
	println!(&quot;&amp;a:{:p}&quot;,&amp;a); // 输出0x9cf974
	//a=2;                  // 编译错误，不可变绑定不能修改绑定的值
	let a = 2;              // 重新绑定
	println!(&quot;&amp;a:{:p}&quot;,&amp;a); // 输出0x9cfa14地址发生了变化
	let mut b = 1;          // 创建可变绑定
	println!(&quot;b:{}&quot;,b);     // 输出1
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfa6c
	b = 2;
	println!(&quot;b:{}&quot;,b);     // 输出2
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfa6c地址没有变化
	let b = 2;              // 重新绑定新值
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfba4地址发生了变化
}
</code></pre>
<p>我们可以看到，在 <code>C++</code> 代码中，变量 <code>a</code> 先赋值为 1，后赋值为 2，但其地址没有发生变化。<code>Rust</code> 代码中，<code>a</code> 是一个不可变绑定，执行<code>a=2</code>动作被编译器拒绝。但是可以使用 <code>let</code> 重新绑定，但这时 <code>a</code> 的地址跟之前发生了变化，说明 a 被绑定到了另一个内存地址。<code>b</code> 是一个可变绑定，可以使用<code>b = 2</code>重新给它指向的内存赋值，<code>b</code> 的地址不变。但使用 <code>let</code> 重新绑定后，<code>b</code> 指向了新的内存区域。</p>
<p>可以看出，&quot;赋值&quot; 是将值写入变量关联的内存区域，&quot;绑定&quot; 是建立变量与内存区域的关联关系，<code>Rust</code> 里，还会把这个内存区域的所有权赋予这个变量。</p>
<p>不可变绑定的含义是：将变量绑定到一个内存地址，并赋予所有权，通过该变量只能读取该地址的数据，不能修改该地址的数据。对应的，可变绑定就可以通过变量修改关联内存区域的数据。从语法上看，有 <code>let</code> 关键字是绑定, 没有就是赋值。</p>
<p>这里我们能看出 <code>Rust</code> 与 <code>C++</code> 的一个不同之处。<code>C++</code> 里是没有“绑定”概念的。<code>Rust</code> 的变量绑定概念是一个很关键的概念，它是所有权的起点。有了明确的绑定才有了所有权的归属，同时解绑定的时机也确定了资源释放的时机。</p>
<p>所有权规则：</p>
<ul>
<li>每一个值都有其所有者变量</li>
<li>同一时间所有者变量只能有一个</li>
<li>所有者离开作用域，值被丢弃(释放/析构)</li>
</ul>
<p>作为所有者，它有如下权利：</p>
<ul>
<li>控制资源的释放</li>
<li>出借所有权</li>
<li>转移所有权</li>
</ul>
<h2 id="4所有权的转移"><a class="header" href="#4所有权的转移">4.所有权的转移</a></h2>
<p>所有者的重要权利之一就是“转移所有权”。这引申出三个问题：</p>
<ol>
<li>为什么要转移？</li>
<li>什么时候转移？</li>
<li>什么方式转移？</li>
</ol>
<p>相关的语言概念如下图。</p>
<img src="lang/rust/./img/rust_ownership_5.jpg">
<center>图 5所有权转移</center>
<p><strong>为什么要转移所有权？</strong>
我们知道，C/C++/Rust 的变量关联了某个内存区域，但变量总会在表达式中进行操作再赋值给另一个变量，或者在函数间传递。实际上期望被传递的是变量绑定的内存区域的内容，如果这块内存区域比较大，复制内存数据到给新的变量就是开销很大的操作。所以需要把所有权转移给新的变量，同时当前变量放弃所有权。所以归根结底，转移所有权还是为了性能。</p>
<p><strong>所有权转移的时机总结下来有以下两种情况：</strong></p>
<ol>
<li>位置表达式出现在值上下文时转移所有权</li>
<li>变量跨作用域传递时转移所有权</li>
</ol>
<p>第一条规则是一个精确的学术表达，涉及到位置表达式，值表达式，位置上下文，值上下文等语言概念。它的简单理解就是各种各样的赋值行为。能明确指向某一个内存区域位置的表达式是位置表达式，其它的都是值表达式。各种带有赋值语义的操作的左侧是位置上下文，右侧是值上下文。</p>
<p>当位置表达式出现在值上下文时，其程序语义就是要把这边位置表达式所指向的数据赋给新的变量，所有权发生转移。</p>
<p>第二条规则是“变量跨作用域时转移所有权”。</p>
<p>图上列举出了几种常见的跨作用域行为，能涵盖大多数情况，也有简单的示例代码</p>
<ul>
<li>变量被花括号内使用</li>
<li>match 匹配</li>
<li>if let 和 While let</li>
<li>移动语义函数参数传递</li>
<li>闭包捕获移动语义变量</li>
<li>变量从函数内部返回</li>
</ul>
<p>为什么变量跨作用域要转移所有权？在 <code>C/C++</code> 代码中，是否转移所有权是程序员自己隐式或显式指定的。</p>
<p>试想，在 <code>C/C++</code> 代码中，函数 <code>Fun1</code> 在栈上创建一个 类型 <code>A</code> 的实例 <code>a</code>， 把它的指针 <code>&amp;a</code> 传递给函数 <code>void fun2(A* param)</code> 我们不会希望 <code>fun2</code> 释放这个内存，因为 <code>fun1</code> 返回时，栈上的空间会自动被释放。</p>
<p>如果 <code>fun1</code> 在堆上创建 <code>A</code> 的实例 <code>a</code>， 把它的指针 <code>&amp;a</code> 传递给函数 <code>fun2(A* param)</code>,那么关于 <code>a</code> 的内存空间的释放，<code>fun1</code> 和 <code>fun2</code> 之间需要有个商量，由谁来释放。<code>fun1</code> 可能期望由 <code>fun2</code> 来释放，如果由 <code>fun2</code> 释放，则 <code>fun2</code> 并不能判断这个指针是在堆上还是栈上。归根结底，还是谁拥有 <code>a</code> 指向内存区的所有权问题。 <code>C/C++</code> 在语言层面上并没有强制约束。<code>fun2</code> 函数设计的时候，需要对其被调用的上下文做假定，在文档中对对谁释放这个变量的内存做约定。这样编译器实际上很难对错误的使用方式给出警告。</p>
<p><code>Rust</code> 要求变量在跨越作用域时明确转移所有权，编译器可以很清楚作用域边界内外哪个变量拥有所有权，能对变量的非法使用作出明确无误的检查，增加的代码的安全性。</p>
<p><strong>所有权转移的方式有两种：</strong></p>
<ul>
<li>移动语义-执行所有权转移</li>
<li>复制语义-不执行转移，只按位复制变量</li>
</ul>
<p>这里我把 ”复制语义“定义为所有权转移的方式之一，也就是说“不转移”也是一种转移方式。看起来很奇怪。实际上逻辑是一致的，因为触发复制执行的时机跟触发转移的时机是一致的。只是这个数据类型被打上了 <code>Copy</code> 标签 <code>trait</code>, 在应该执行转移动作的时候，编译器改为执行按位复制。</p>
<p><code>Rust</code> 的标准库中为所有基础类型实现的 <code>Copy Trait</code>。</p>
<p>这里要注意，标准库中的</p>
<pre><code class="language-Rust"> impl&lt;T: ?Sized&gt; Copy for &amp;T {}
</code></pre>
<p>为所有引用类型实现了 <code>Copy</code>, 这意味着我们使用引用参数调用某个函数时，引用变量本身是按位复制的。标准库没有为可变借用 <code>&amp;mut T</code> 实现“Copy” <code>Trait</code> , 因为可变借用只能有一个。后文讲闭包捕获变量的所有权时我们可以看到例子。</p>
<h2 id="5所有权的借用"><a class="header" href="#5所有权的借用">5.所有权的借用</a></h2>
<p>变量拥有一个内存区域所有权，其所有者权利之一就是“出借所有权”。</p>
<p>与出借所有权相关的概念关系如图 6</p>
<img src="lang/rust/./img/rust_ownership_6.jpg">
<center>图 6出借所有权</center>
<p>拥有所有权的变量借出其所有权有“引用”和“智能指针”两种方式：</p>
<ul>
<li>
<p>引用（包含可变借用和不可变借用)</p>
</li>
<li>
<p>智能指针</p>
<ul>
<li>独占式智能指针 <code>Box&lt;T&gt;</code></li>
<li>非线程安全的引用计数智能指针 <code>Rc&lt;T&gt;</code></li>
<li>线程安全的引用计数智能指针 <code>Arc&lt;T&gt;</code></li>
<li>弱指针 <code>Weak&lt;T&gt;</code></li>
</ul>
</li>
</ul>
<p>引用实际上也是指针，指向的是实际的内存位置。</p>
<p>借用有两个重要的安全规则：</p>
<ol>
<li>代表借用的变量，其生命周期不能比被借用的变量(所有者)的生命周期长</li>
<li>同一个变量的可变借用只能有一个</li>
</ol>
<p>第一条规则就是确保不出现“悬垂指针”的内存安全问题。如果这条规则被违反，例如：变量 <code>a</code> 拥有存储区域的所有权，变量 <code>b</code> 是 <code>a</code> 的某种借用形式，如果 <code>b</code> 的生命周期比 <code>a</code> 长，那么 <code>a</code> 被析构后存储空间被释放，而 <code>b</code> 仍然可以使用，则 <code>b</code> 就成为了悬垂指针。</p>
<p>第二条是不允许有两个可变借用，避免出现数据一致性问题。</p>
<pre><code class="language-Rust">Struct Foo{v:i32}
fn main(){
    let mut f = Foo{v:10};
    let im_ref = &amp;f;        // 获取不可变引用
    let mut_ref = &amp; mut f;  // 获取可变引用
    //println!(&quot;{}&quot;,f.v);
    //println!(&quot;{}&quot;,im_ref.v);
    //println!(&quot;{}&quot;,mut_ref.v);
}
</code></pre>
<p>变量 <code>f</code> 拥有值的所有权，<code>im_ref</code> 是其不可变借用，<code>mut_ref</code> 是其可变借用。以上代码是可以编译过去的，但是这几个变量都没有被使用，这种情况下编译器并不禁止你同时拥有可变借用和不可变借用。最后的三行被注释掉的代码(6,7,8)使用了这些变量。打开一行或多行这些注释的代码，编译器会报告不同形式的错误：</p>
<table><thead><tr><th>开放注释行</th><th>编译器报告</th></tr></thead><tbody>
<tr><td>6</td><td>正确</td></tr>
<tr><td>7</td><td>第 5 行错误：不能获得 f 的可变借用，因为已经存在不可变借用</td></tr>
<tr><td>8</td><td>正确</td></tr>
<tr><td>6, 7</td><td>第 5 行错误：不能获得 f 的可变借用，因为已经存在不可变借用</td></tr>
<tr><td>6,8</td><td>第 6 行错误：不能获得 f 的不可变借用，因为已经存在可变借用</td></tr>
</tbody></table>
<p><strong>对&quot;借用&quot; 的抽象表达</strong></p>
<p><code>Rust</code> 的核心包中有两个泛型 <code>trait</code> ，<a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">core::borrow::Borrow</a> 与 <a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html">core::borrow::BorrowMut</a>，可以用来表达&quot;借用&quot;的抽象含义，分别代表可变借用和不可变借用。
前面提到，“借用”有多种表达形式 <code>（&amp;T,Box&lt;T&gt;，Rc&lt;T&gt; 等等）</code>，在不同的使用场景中会选择合适的借用表达方式。它们的抽象形式就可以用 <a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">core::borrow::Borrow</a> 来代表. 从类型关系上， <code>Borrow</code> 是&quot;借用&quot; 概念的抽象形式。从实际应用上，某些场合我们希望获得某个类型的“借用”，同时希望能支持所有可能的“借用”形式，<code>Borrow Trait</code> 就有用武之地。</p>
<p>Borrow 的定义如下：</p>
<pre><code class="language-Rust">pub trait Borrow&lt;Borrowed: ?Sized&gt; {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
</code></pre>
<p>它只有一个方法，要求返回指定类型的引用。</p>
<p><code>Borrow</code> 的文档中有提供例子</p>
<pre><code class="language-Rust">use std::borrow::Borrow;

fn check&lt;T: Borrow&lt;str&gt;&gt;(s: T) {
    assert_eq!(&quot;Hello&quot;, s.borrow());
}

fn main(){
    let s: String = &quot;Hello&quot;.to_string(); 
    check(s);

    lets: &amp;str = &quot;Hello&quot;; 
    check(s);
}
</code></pre>
<p><code>check</code> 函数的参数表示它希望接收一个 “str”类型的任何形式的“借用”，然后取出其中的值与 “Hello”进行比较。</p>
<p>标准库中为 <code>String</code> 类型实现了 <code>Borrow&lt;str&gt;</code>,代码如下</p>
<pre><code class="language-Rust">impl Borrow&lt;str&gt; for String{
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str{
        &amp;self[..]
    }
}
</code></pre>
<p>所以 <code>String</code> 类型可以作为 <code>check</code> 函数的参数。</p>
<p>从图上可以看出，标准库为所有类型 <code>T</code> 实现了 <code>Borrow Trait</code>, 也为 <code>&amp;T</code> 实现了 <code>Borrow Trait</code>。</p>
<p>代码如下 ，这如何理解。</p>
<pre><code class="language-Rust">impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for T {
    fn borrow(&amp;self) -&gt; &amp;T { // 是 fn borrow(self: &amp;Self）的缩写，所以 self 的类型就是 &amp;T
        self
    }
}

impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for &amp;T {
    fn borrow(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
</code></pre>
<p>这正是 <code>Rust</code> 语言很有意思的地方，非常巧妙的体现了语言的一致性。既然 <code>Borrow&lt;T&gt;</code> 的方法是为了能获取 <code>T</code> 的引用，那么类型 <code>T</code> 和 <code>&amp;T</code> 当然也可以做到这一点。在 <code>Borrow for T</code> 的实现中，</p>
<p><code>fn borrow(&amp;self)-&gt;&amp;T</code> 是 <code>fn borrow(self: &amp;Self)-&gt;&amp;T</code> 的缩写，所以 <code>self</code> 的类型就是 <code>&amp;T</code>,可以直接被返回。在 <code>Borrow for &amp;T</code> 的实现中，<code>fn borrow(&amp;self)-&gt;&amp;T</code> 是 <code>fn borrow(self: &amp;Self)-&gt;&amp;T</code> 的缩写，所以 <code>self</code> 的类型就是 <code>&amp;&amp;T</code>, 需要被两次解引用得到 <code>T</code>, 再返回其引用。</p>
<p>智能指针 <code>Box&lt;T&gt;</code>,<code>Rc&lt;T&gt;</code>,<code>Arc&lt;T&gt;</code>,都实现了 <code>Borrow&lt;T&gt;</code> ，其获取 <code>&amp;T</code> 实例的方式都是两次解引用在取引用。<code>Weak&lt;T&gt;</code> 没有实现 <code>Borrow&lt;T&gt;</code>, 它需要升级成 <code>Rc&lt;T&gt;</code> 才能获取数据。</p>
<h2 id="6生命周期参数"><a class="header" href="#6生命周期参数">6.生命周期参数</a></h2>
<p>变量的生命周期主要跟变量的作用域有关，在大部分程序语言中都是隐式定义的。<code>Rust</code> 中能显式声明变量的生命周期参数，这是非常独特的设计，其语法特性在其他语言也是不太可能见到的。以下是生命周期概念相关的图示。</p>
<img src="lang/rust/./img/rust_ownership_7.jpg">
<center>图 7生命周期</center>
<p><strong>生命周期参数的作用</strong></p>
<p>生命周期参数的核心作用就是解决悬垂指针问题。就是让编译器帮助检查变量的生命周期，防止出现变量指向的内存区域被释放后，变量仍然可以使用的问题。那么什么情况下会让编译器无法判断生命周期，而必须引入一个特定语法来对生命周期进行标识？</p>
<p>我们来看看最常见的悬垂指针问题，函数以引用方式返回函数内部的局部变量：</p>
<pre><code class="language-Rust">struct V{v:i32}
 
fn bad_fn() -&gt; &amp;V{  //编译错误：期望一个命名的生命周期参数
    let a = V{v:10};
    &amp;a
}
let  res = bad_fn();
</code></pre>
<p>这个代码是一个典型的悬垂指针错误，<code>a</code> 是函数内的局部变量，函数返回后 <code>a</code> 就被销毁，把 <code>a</code> 的引用赋值给 <code>res</code> ，如果能执行成功，<code>res</code> 绑定的就是未定义的值。</p>
<p>但编译器并不是报告悬垂指针错误，而是说返回类型 <code>&amp;V</code> 没有指定生命周期参数。<code>C++</code> 的类似代码编译器会给出悬垂指针的警告（警告内容:局部变量的地址被返回了）。</p>
<p>那我们指定一个生命周期参数看看：</p>
<pre><code class="language-Rust">fn bad_fn&lt;'a&gt;() -&gt; &amp;'a V{
    let a = V{v:10};
    let ref_a = &amp;a;
    ref_a   //编译错误：不能返回局部变量的引用
}
</code></pre>
<p>这次编译器报告的是悬垂指针错误了。那么编译器的分析逻辑是什么？</p>
<p>首先我们明确一下 <font color=#fa8919>'a 在这里的精确语义到底是什么？</font></p>
<p>函数将要返回的引用会代表一个内存数据，这个数据有其生命周期范围，<code>'a</code> 参数是对这个生命周期范围提出的要求。就像 <code>&amp;V</code> 是对返回值类型提的要求类似，<strong>'a 是对返回值生命周期提的要求</strong>。编译器需要检查的就是实际返回的数据，其生命是否符合要求。</p>
<p>那么 <font color=#fa8919>'a 参数对返回值的生命周期到底提出了什么要求？</font></p>
<p>我们先区分一下&quot;函数上下文&quot;和“调用者上下文”，函数上下文是指函数体内部的作用域范围，调用者上下文是指该函数被调用的位置。上述的悬垂指针错误其实并不会影响函数上下文范围的程序执行，出问题的地方是调用者上下文拿到一个无效引用并使用时，会出现不可预测的错误。</p>
<p>函数返回的引用会在“调用者上下文”中赋予某个变量，如：</p>
<pre><code class="language-Rust">let res = bod_fn();
</code></pre>
<p><code>res</code> 获得了返回的引用, 函数内的 <code>ref_a</code> 引用会按位复制给变量 <code>res</code> （标准库中 <code>impl&lt;T: ?Sized&gt; Copy for &amp;T {}</code> 指定了此规则）<code>res</code> 会指向 函数内 <code>res_a</code> 同样的数据。为了保证将来在调用者上下文不出悬垂指针，编译器真正要确保的是 <code>res</code> 所指向的数据的生命周期，不短于 <code>res</code> 变量自己的生命周期。否则如果数据的生命周期短，先被释放，<code>res</code> 就成为悬垂指针。</p>
<p>可以把这里的 <code>'a</code> 参数理解为调用者上下文中接收函数返回值的变量 <code>res</code> 的生命周期，那么 <code>'a</code> 对函数体内部返回引用的要求是：<strong>返回引用所指代数据的生命周期不短于 'a ，也就是不短于调用者上下文接收返回值的变量的生命周期。</strong></p>
<p>上述例子中函数内 <code>ref_a</code> 指代的数据生命周期就是函数作用域，函数返回前，数据被销毁，生命周期小于调用者上下文的 <code>res</code>, 编译器根据 返回值的生命周期要求与实际返回值做比较，发现了错误。</p>
<p>实际上，返回的引用或者是静态生命周期，或者是根据函数输入的引用参数通过运算变换得来的，否则都是这个结果，因为都是对局部数据的引用。</p>
<p><strong>静态生命周期</strong></p>
<p>看函数</p>
<pre><code class="language-Rust">fn get_str&lt;'a&gt;() -&gt; &amp;'a str {
    let s = &quot;hello&quot;;
    s
}
</code></pre>
<p>这个函数可以编译通过，返回的引用虽然不是从输入参数推导，不过是静态生命周期，可以通过检查。</p>
<p>因为静态生命周期可以理解为“无穷大”的语义，实际是跟进程的生命周期一致，也就是在程序运行期间始终有效。</p>
<p><code>Rust</code> 的字符串字面量是存储在程序代码中，程序加载后在代码空间，始终有效。可以通过一个简单试验验证这一点：</p>
<pre><code class="language-Rust">let s1=&quot;Hello&quot;;
println!(&quot;&amp;s1:{:p}&quot;, &amp;s1);//&amp;s1:0x9cf918

let s2=&quot;Hello&quot;;
println!(&quot;&amp;s2:{:p}&quot;,&amp;s2);//&amp;s2:0x9cf978
//s1,s2是一样的值但是地址不一样，是两个不同的引用变量

let ptr1: *const u8 = s1.as_ptr();
println!(&quot;ptr1:{:p}&quot;, ptr1);//ptr1:0x4ca0a0

let ptr2: *const u8 = s2.as_ptr();
println!(&quot;ptr2:{:p}&quot;, ptr2);//ptr2:0x4ca0a0
</code></pre>
<p><code>s1</code>,<code>s2</code> 的原始指针都指向同一个地址，说明编译器为 &quot;Hello&quot; 字面量只保存了一份拷贝，所有引用都指向它。</p>
<p><code>get_str</code> 函数中静态生命周期长于返回值要求的<code>'a</code>，所以是合法的。</p>
<p>如果把 <code>get_str</code> 改成</p>
<pre><code class="language-Rust">fn get_str&lt;'a&gt;() -&gt; &amp;'static str
</code></pre>
<p>即把对返回值生命周期的要求改为无穷大，那就只能返回静态字符串引用了。</p>
<p><strong>函数参数的生命周期</strong></p>
<p>前面的例子为了简单起见，没有输入参数，这并不是一个典型的情况。大多数情况下，函数返回的引用是根据输入的引用参数通过运算变换而来。比如下面的例子：</p>
<pre><code class="language-Rust">fn  remove_prefix&lt;'a&gt;(content:&amp;'a str,prefix:&amp;str) -&gt; &amp;'a str{
    if content.starts_with(prefix){
        let start:usize = prefix.len();
        let end:usize = content.len();
        let sub = content.get(start..end).unwrap();
        sub
    }else{
        content
    }
}
let  s = &quot;reload&quot;;
let sub = remove_prefix(&amp;s0,&quot;re&quot;);
println!(&quot;{}&quot;,sub); // 输出: load
</code></pre>
<p><code>remove_prefix</code> 函数从输入的 <code>content</code> 字符串中判断是否有 <code>prefix</code> 代表的前缀。 如果有就返回 <code>content</code> 不包含前缀的切片，没有就返回 <code>content</code> 本身。</p>
<p>无论如何这个函数都不会返回前缀 <code>prefix</code> ，所以 <code>prefix</code> 变量不需要指定生命周期。</p>
<p>函数两个分支返回的都是通过 <code>content</code> 变量变换出来的，并作为函数的返回值。所以 <code>content</code> 必须标注生命周期参数，编译器要根据 <code>content</code> 的生命周期参数与返回值的要求进行比较，判断是否符合要求。即：<strong>实际返回数据的生命周期，大于或等于返回参数要求的生命周期。</strong></p>
<p>前面说到，我们把返回参数中指定的生命周期参数 <code>'a</code> 看做调用者上下文中接收返回值的变量的生命周期，在这个例子中就是字符串引用 <code>sub</code>，<font color=#fa8919>那么输入参数中的 'a 代表什么意思 ？</font></p>
<p>这在 <code>Rust</code> 语法设计上是一个很让人困惑的地方，输入参数和输出参数的生命周期都标志为 <code>'a</code> ，似乎是要求两者的生命周期要求一致，但实际上并不是这样。</p>
<p>我们先看看如果输入参数的生命周期跟输出参数期待的不一样是什么情况，例如下面两个例子：</p>
<pre><code class="language-Rust">fn echo&lt;'a, 'b&gt;(content: &amp;'b str) -&gt; &amp;'a str {
    content //编译错误：引用变量本身的生命周期超过了它的借用目标
}
fn longer&lt;'a, 'b&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len()
        { s1 }
    else
        { s2 }//编译错误：生命周期不匹配
}
</code></pre>
<p><code>echo</code> 函数输入参数生命周期标注为 <code>'b</code> , 返回值期待的是 <code>'a</code> .编译器报错信息是典型的“悬垂指针”错误。不过内容似乎并不明确。编译器指出查阅详细信息 <a href="https://doc.rust-lang.org/error-index.html#E0312">--explain E0312</a> ，这里的解释是&quot;借用内容的生命周期与期待的不一致&quot;。这个错误描述就与实际的错误情况是相符合的了。</p>
<p><code>longer</code> 函数两个参数分别具有生命周期 <code>'a</code> 和 <code>'b</code> , 返回值期待 <code>'a</code> ,当返回 <code>s2</code> 时，编译器报告生命周期不匹配。把 <code>longer</code> 函数中的生命周期 <code>'b</code> 标识为比 <code>'a</code> 长，就可以正确编译了。</p>
<pre><code class="language-Rust">fn longer&lt;'a, 'b: 'a&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len()
        { s1 }
    else
        { s2 }//编译通过
}
</code></pre>
<p>回到我们前面的问题，<font color=#fa8919>那么输入参数中的 'a 代表什么意思 ？</font></p>
<p>我们知道编译器在函数定义上下文中所做的生命周期检查就是要确保”<strong>实际返回数据的生命周期，大于或等于返参数要求的生命周期</strong>“。当输入参数给出与返回值一样的生命周期参数 <code>'a</code> 时，实际上是人为地向编译器保证：<strong>在调用者上下文中，实际给出的函数输入参数的生命周期，不小于将来用于接收返回值的变量的生命周期。</strong></p>
<p>当有两个生命周期参数 <code>'a</code> <code>'b</code> , 而 <code>'b</code> 大于 <code>'a</code>，当然 也保证了在调用者上下文 <code>'b</code> 代表的输入参数生命周期也足够长。</p>
<p>在函数定义中，编译器并不知道将来实际调用这个函数的上下文是怎么样的。生命周期参数相当是函数上下文与调用者上下文之间关于参数生命周期的协议。</p>
<p>就像函数签名中的类型声明一样，类型声明约定了与调用者之间输入输出参数的类型，编译器编译函数时，会检查函数体返回的数据类型与声明的返回值是否一致。同样对与参数与返回值的生命周期，函数也会检查函数体中返回的变量生命周期与声明的是否一致。</p>
<p>前面说的是编译器在“<strong>函数定义上下文的生命周期检查</strong>”机制，这只是生命周期检查的一部分，还有另一部分就是“<strong>调用者上下文对生命周期的检查</strong>”机制。两者检查的规则如下：</p>
<p><strong>函数定义上下文的生命周期检查：</strong></p>
<p>函数签名中返回值的生命周期标注可以是输入标注的任何一个，只要保证由输入参数推导出来的返回的临时变量的生命周期，比函数签名中返回值标注的生命周期相等或更长。这样保证了调用者上下文中，接收返回值的变量，不会因为输入参数失效而成为悬垂指针。</p>
<p><strong>调用者上下文对生命周期的检查：</strong></p>
<p>调用者上下文中，接收函数返回借用的变量 <code>res</code> ，其生命周期不能长于返回的借用的生命周期(实际是根据输入借用参数推导出来的)。否则 <code>res</code> 会在输入参数失效后成为悬垂指针。</p>
<p>前面 <code>remove_prefix</code> 函数编译器已经校验合格，那么我们在调用者上下文中构建如下例子</p>
<pre><code class="language-Rust">let res: &amp;str;
{
    let s = String::from(&quot;reload&quot;);
    res = remove_prefix(&amp;s, &quot;re&quot;) //编译错误：s 的生命周期不够长
}
println!(&quot;{}&quot;, res);
</code></pre>
<p>这个例子中 <code>remove_prefix</code> 被调用这一行，编译器会报错 “s 的生命周期不够长”。代码中的 大括号创建了一个新的词法作用域，导致 <code>res</code> 的生命周期比大括号内部的 <code>s</code> 更长。这不符合函数签名中对生命周期的要求。函数签名要求输入参数的生命周期不短于返回值要求的生命周期。</p>
<p><strong>结构体定义中的生命周期</strong></p>
<p>结构体中有引用成员时，就会有潜在的悬垂指针问题，需要标识生命周期参数来让编译器帮助检查。</p>
<pre><code class="language-Rust">struct G&lt;'a&gt;{ m:&amp;'a str}
 
fn get_g() -&gt; () {
    let g: G;
    {
        let  s0 = &quot;Hi&quot;.to_string();
        let  s1 = s0.as_str();              //编译错误：借用值存活时间不够长
        g = G{ m: s1 };
    }
    println!(&quot;{}&quot;, g.m);
}
</code></pre>
<p>上面的例子中，结构体 <code>G</code> 包含了引用成员，不指定生命周期参数是无法编译的。函数 <code>get_g</code> 演示了在使用者上下文中如何出现生命周期不匹配的情况。</p>
<p>结构体的生命周期定义就是要保证在一个结构体实例中，其引用成员的生命周期不短于结构体实例自身的生命周期。否则如果结构体实例存活期间，其引用成员的数据先被销毁，那么访问这个引用成员时就构成了对悬垂指针的访问。</p>
<p>实际上结构体的生命周期参数可以和函数生命周期参数做类比，成员的生命周期相当函数的输入参数的生命周期，结构体整体的生命周期相当函数返回值的生命周期。这样所有之前对函数生命周期参数的分析一样可以适用。</p>
<p>如果结构体有方法成员会返回引用参数，方法同样需要填写生命周期参数。返回的引用来源可以是方法的输入引用参数，也可以是结构体的引用成员。在做生命周期分析的时候，可以把“方法的输入引用参数”和“结构体的引用成员”都看做普通函数的输入参数，这样前面对普通函数参数和返回值的生命周期分析方法可以继续套用。</p>
<p><strong>泛型的生命周期限定</strong></p>
<p>前文说过生命周期参数跟类型限定很像，比如在代码</p>
<pre><code class="language-Rust">fn longer&lt;'a&gt;(s1:&amp;'a str, s2:&amp;'a str) -&gt; &amp;'a str
 
struct G&lt;'a&gt;{ m:&amp;'a str }
</code></pre>
<p>中，<code>'a</code> 出现的位置参数类型旁边，一个对参数的静态类型做限定，一个对参数的动态时间做限定。<code>'a</code> 使用前需要先声明，声明的位置与模板参数的位置一样，在 <code>&lt;&gt;</code> 括号内，也是用来放泛型的类型参数的地方。</p>
<p>那么，<font color=#fa8919>把类型换成泛型可以吗，语义是什么？使用场景是什么？</font></p>
<p>我们看看代码例子：</p>
<pre><code class="language-Rust">use std::cmp::Ordering;

#[derive(Eq, PartialEq, PartialOrd, Ord)]
struct G&lt;'a, T:Ord&gt;{ m: &amp;'a T }
 
#[derive(Eq, PartialEq, PartialOrd, Ord)]
struct Value{ v: i32 }
 
fn longer&lt;'a, T:Ord&gt;(s1: &amp;'a T, s2: &amp;'a T) -&gt; &amp;'a T {
    if s1 &gt; s2 { s1 } else { s2 }
}
 
fn main(){
    let v0 = Value{ v:12 };
    let v1 = Value{ v:15 };
    let res_v = longer(&amp;v0, &amp;v1);
    println!(&quot;{}&quot;, res_v.v);//15
     
    let g0 = G{ m: &amp;v0 };
    let g1 = G{ m: &amp;v1 };
    let res_g = longer(&amp;g0, &amp;g1);//15
    println!(&quot;{}&quot;, res_g.m.v);
}
</code></pre>
<p>这个例子扩展了 <code>longer</code> 函数，可以对任何实现了 <code>Ord trait</code> 的类型进行操作。 <code>Ord</code> 是核心包中的一个用于实现比较操作的内置 <code>trait</code>. 这里不细说明。<code>longer</code> 函数跟前一个版本比较，只是把 <code>str</code> 类型换成了泛型参数 <code>T</code>, 并给 <code>T</code> 增加了类型限定 <code>T:Ord</code>.</p>
<p>结构体 <code>G</code> 也扩展成可以容纳泛型 <code>T</code>,但要求 <code>T</code> 实现了 <code>Ord trait</code>.</p>
<p>从代码及执行结果看，跟 把 <code>T</code> 当成普通类型一样，没有什么特别，生命周期参数依然是他原来的语义。</p>
<p>但实际上 &quot;<code>&amp;'a T</code>&quot; 还隐含另一层语义：<strong>如果 <code>T</code> 内部含有引用成员，那么其中的引用成员的生命周期要求不短于 <code>T</code> 实例的生命周期。</strong></p>
<p>老规矩，我们来构造一个反例。结构体 <code>G</code> 内部包含一个泛型的引用成员，我们将 <code>G</code> 用于 <code>longer</code> 函数，但是让 <code>G</code> 内部的引用成员生命周期短于 <code>G</code>。代码如下：</p>
<pre><code class="language-Rust">fn  main(){
    let v0 = Value{ v:12 };
    let v1_ref: &amp;Value;      // 将 v1 的引用定义在下面大括号之外，有意延长变量的生命周期范围
    let res_g: &amp;G&lt;Value&gt;;

    {
        let v1 = Value{ v:15 };
        v1_ref = &amp;v1;      //编译错误：v1的生命周期不够长。
        let res_v = longer(&amp;v0,v1_ref);
        println!(&quot;{}&quot;,res_v.v);
    }

    let g0 = G{ m:&amp;v0 };
    let g1 = G{ m:v1_ref };   // 这时候 v1_ref 已经是悬垂指针
    res_g = longer(&amp;g0, &amp;g1);
    println!(&quot;{}&quot;, res_g.m.v);
}
</code></pre>
<p>变量 <code>g1</code> 自身的生命周期是满足 <code>longer</code> 函数要求的，但是其内部的引用成员，生命周期过短。</p>
<p>这个范例是在“调用者上下文”检查时触发的，对泛型参数的生命周期限定比较难设计出在“函数定义或结构体定义上下文”触发的范例。毕竟 <code>T</code> 只是类型指代，定义时还没有具体类型。</p>
<p>实际上要把在 “<code>struct G&lt;'a,T&gt;{m:&amp;'a T}</code>中，<code>T</code> 的所有引用成员的生命周期不短于<code>'a</code> ”这个语义准确表达，应该写成：</p>
<pre><code class="language-Rust">struct G&lt;'a,T:'a&gt;{m:&amp;'a T}
</code></pre>
<p>因为 <code>T:'a</code> 才是这个语义的明确表述。但是第一种表达方式也是足够的(我用反证法证明了这一点)。所以编译器也接受第一种比较简化的表达形式。</p>
<p>总而言之，泛型参数的生命周期限定是两层含义，一层是泛型类型当做一个普通类型时一样的含义，一层是对泛型内部引用成员的生命周期约束。</p>
<p><strong>Trait 对象的生命周期</strong></p>
<p>看如下代码</p>
<pre><code class="language-Rust">trait Foo{}
struct Bar{v:i32}
struct Qux&lt;'a&gt;{m:&amp;'a  i32}
struct Baz&lt;'a,T&gt;{v:&amp;'a T}
 
impl Foo for Bar{}
impl&lt;'a&gt; Foo for Qux&lt;'a&gt;{}
impl&lt;'a,T&gt; Foo for Baz&lt;'a,T&gt;{}
</code></pre>
<p>结构体 <code>Bar</code>,<code>Qux</code>,<code>Baz</code> 都实现了 <code>trait Foo</code>, 那么 <code>&amp;Foo</code> 类型可以接受这三个结构体的任何一个的引用类型。</p>
<p>我们把 <code>&amp;Foo</code> 称为 <code>Trait</code> 对象。</p>
<p><code>Trait</code> 对象可以理解为类似其它面向对象语言中，指向接口或基类的指针或引用。其它<code>OO</code>语言指向基类的指针在运行时确定其实际类型。<code>Rust</code> 没有类继承，指向 <code>trait</code> 的指针或引用起到类似的效果，运行时被确定具体类型。所以编译期间不知道大小。</p>
<p><code>Rust</code> 的 <code>Trait</code> 不能有非静态数据成员，所以 <code>Trait</code> 本身就不会出现引用成员的生命周期小于对象自身，所以 <code>Trait</code> 对象默认的生命周期是静态生命周期。我们看下面三个函数：</p>
<pre><code class="language-Rust">fn check0() -&gt; &amp;'static Foo { // 如果不指定 'static , 编译器会报错，要求指定生命周期命参数, 并建议 'static
    const b:Bar = Bar{v:0};
    &amp;b
}
fn check1&lt;'a&gt;() -&gt; &amp;'a Foo { //如果不指定 'a , 编译器会报错
    const b:Bar = Bar{v:0};
    &amp;b
}
fn check2(foo:&amp;Foo) -&gt; &amp;Foo {//生命周期参数被省略，不要求静态生命周期
    foo
}
fn check3(foo:&amp;'static Foo) -&gt; &amp;'static Foo {
    foo
}
fn main(){
    let bar= Bar{v:0};
    check2(&amp;bar);                               //能编译通过，说明 chenk2 的输入输出参数都不是静态生命周期
    //check3(&amp;bar);                          //编译错误：bar的生命周期不够长
    const bar_c:Bar =Bar{v:0};
    check3(&amp;bar_c);                         // check3 只能接收静态参数
}
</code></pre>
<p><code>check0</code> 和 <code>check1</code> 说明将 <code>Trait</code> 对象的引用作为 函数参数返回时，跟返回其他引用类型一样，都需要指定生命周期参数。函数 <code>check2</code> 的生命周期参数只是被省略了(编译器可以推断)，但这个函数里的 <code>Trait</code> 对象并不是静态生命周期，这可以从 <code>main</code> 函数内能成功执行 <code>check2(bar)</code> 分析出来，因为 <code>bar</code> 不是静态生命周期.</p>
<p>实际上在运行时，<code>Trait</code> 对象总会动态绑定到一个实现了该 <code>Trait</code> 的具体结构体类型(如 <code>Bar</code>,<code>Qux</code>,<code>Baz</code> 等)，这个具体类型的在其上下文中有它的生命周期，可以是静态的，更多情况下是非静态生命周期 <code>'a</code> ，那么 <code>Trait</code> 对象的生命周期也是 <code>'a</code>.</p>
<table><thead><tr><th></th><th>结构体或成员生命周期</th><th>Trait 对象生命周期</th></tr></thead><tbody>
<tr><td>Foo</td><td>无</td><td>'static</td></tr>
<tr><td>Bar</td><td>'a</td><td>'a</td></tr>
<tr><td>Qux&lt;'a&gt;{m:&amp;'a str}</td><td>'a</td><td>'a</td></tr>
<tr><td>Baz&lt;'a,T&gt;{v:&amp;'a T}</td><td>'a</td><td>'a</td></tr>
</tbody></table>
<pre><code class="language-Rust">fn qux_update&lt;'a&gt;(qux: &amp;'a mut Qux&lt;'a&gt;, new_value: &amp;'a i32)-&gt;&amp;'a Foo {
    qux.v = new_value;
    qux
}

let value = 100;
let mut qux = Qux{v: &amp;value};
let new_value = 101;
let muted: &amp;dyn Foo = qux_update(&amp; mut qux, &amp;new_value);
qux_update 函数的智能指针版本如下：
 
fn qux_box&lt;'a&gt;(new_value: &amp;'a  i32) -&gt; Box&lt;Foo +'a&gt; {
    Box::new(Qux{v:new_value})
}
 
let new_value = 101;
let boxed_qux:Box&lt;dyn Foo&gt; = qux_box(&amp;new_value);
</code></pre>
<p>返回的智能指针中，<code>Box</code> 装箱的类型包含了引用成员，也需要给被装箱的数据指定生命周期，语法形式是在被装箱的类型位置增加生命周期参数，用 &quot;+&quot; 号连接。</p>
<p>这两个版本的代码其实都说明一个问题，就是 <code>Trait</code> 虽然默认是静态生命周期，但实际上，其生命周期是由具体实现这个 <code>Trait</code> 的结构体的生命周期决定，推断方式跟之前叙述的函数参数生命周期并无太大区别。</p>
<h2 id="7智能指针的所有权与生命周期"><a class="header" href="#7智能指针的所有权与生命周期">7.智能指针的所有权与生命周期</a></h2>
<p>如图 6，在 <code>Rust</code> 中引用和智能指针都算是“指针”的一种形态，所以他们都可以实现 <a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">std::borrow::Borrow</a> <code>Trait</code>。一般情况下，我们对栈中的变量获取引用，栈中的变量存续时间一般比较短，当前的作用域退出时，作用域范围内的栈变量就会被回收。如果我们希望变量的生命周期能跨越当前的作用域，甚至在线程之间传递，最好是把变量绑定的数据区域创建在堆上。</p>
<p>栈上的变量其作用域在编译期间就是明确的，所以编译器能够确定栈上的变量何时会被释放，结合生命周期参数生命，编译器能找到绝大部分对栈上变量的错误引用。</p>
<p>堆上变量其的内存管理比栈变量要复杂很多。在堆上分配一块内存之后，编译器无法根据作用域来判断这块内存的存活时间，必须由使用者显式指定。<code>C</code> 语言中就是对于每一块通过 <code>malloc</code> 分配到的内存，需要显式的使用 <code>free</code> 进行释放。<code>C++</code>中是 <code>new / delete</code>。但是什么时候调用 <code>free</code> 或 <code>delete</code> 就是一个难题。尤其当代码复杂，分配内存的代码和释放内存的代码不在同一个代码文件，甚至不在同一个线程的时候，仅仅靠人工跟踪代码的逻辑关系来维护分配与释放就难免出错。</p>
<p>智能指针的核心思想是让系统自动帮我们决定回收内存的时机。其主要手段就是“<strong>将内存分配在堆上，但指向该内存的指针变量本身是在栈上，这样编译器就可以捕捉指针变量离开作用域的时机。在这时决定内存回收动作，如果该指针变量拥有内存区的所有权就释放内存，如果是一个引用计数指针就减少计数值，计数为 0 就回收内存</strong>”。</p>
<p><code>Rust</code> 的 <code>Box&lt;T&gt;</code> 为独占所有权指针，<code>Rc&lt;T&gt;</code>为引用计数指针，但其计数过程不是线程安全的，<code>Arc&lt;T&gt;</code>提供了线程安全的引用计数动作,可以跨线程使用。</p>
<p>我们看 <code>Box&lt;T&gt;</code> 的定义</p>
<pre><code class="language-Rust">pub struct Box&lt;T: ?Sized&gt;(Unique&lt;T&gt;);
pub struct Unique&lt;T: ?Sized&gt;{
    pointer: *const T,
    _marker: PhantomData&lt;T&gt;,
} 
</code></pre>
<p><code>Box</code> 本身是一个元组结构体，包装了一个 <code>Unique&lt;T&gt;</code>， <code>Unique&lt;T&gt;</code>内部有一个原生指针。</p>
<p><em>(注：Rust 最新版本的 Box<T> 实现还可以通过泛型参数指定内存分配器，让用户可以自己控制实际内存的分配。还有为什么通过 Unique<T>多层封装，这涉及智能指针实现的具体问题，这里不详述。）</em></p>
<p><code>Box</code> 没有实现 <code>Copy Trait</code>,它在所有权转移时会执行移动语意。</p>
<p>示例代码：</p>
<pre><code class="language-Rust">Struct Foo {v:i32}
fn inc(v:&amp; mut Foo) -&gt; &amp;Foo {//省略了生命周期参数
    v.v = v.v + 1;
    v
}
//返回Box指针不需要生命周期参数，因为Box指针拥有了所有权，不会成为悬垂指针
fn inc_ptr(mut foo_ptr:Box&lt;Foo&gt;) -&gt; Box&lt;Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    foo_ptr.v = foo_ptr.v + 1;
    println!(&quot;ininc_ptr：{:p}-{:p}&quot;, &amp;foo_ptr, &amp;*foo_ptr);
    foo_ptr
}
fn main() {
    let foo_ptr1 = Box::new(Foo{v:10});
    println!(&quot;foo_ptr1：{:p}-{:p}&quot;, &amp;foo_ptr1, &amp;*foo_ptr1);
    let mut foo_ptr2 = inc_ptr(foo_ptr1);
    //println!(&quot;{}&quot;,foo_ptr1.v);//编译错误，f0_ptr所有权已经丢失
    println!(&quot;foo_ptr2：{:p}-{:p}&quot;, &amp;foo_ptr2, &amp;*foo_ptr2);
     
    inc(foo_ptr2.borrow_mut());//获得指针内数据的引用，调用引用版本的inc函数
    println!(&quot;{}&quot;,foo_ptr2.v);
}
</code></pre>
<p><code>inc</code> 为引用版本，<code>inc_ptr</code> 是指针版本。改代码的输出为：</p>
<pre><code>foo_ptr1：0x8dfad0-0x93a5e0
in inc_ptr：0x8df960-0x93a5e0
foo_ptr2：0x8dfb60-0x93a5e0
12
</code></pre>
<p>可以看到 <code>foo_ptr1</code> 进入函数 <code>inc_ptr</code> 时,执行了一次所有权转移，函数返回时又执行了一次。所以三个 <code>Box&lt;Foo&gt;</code> 的变量地址都不一样，但是它们内部的数据地址都是一样的，指向同一个内存区。</p>
<p><code>Box</code> 类型自身是没有引用成员的，但是如果 <code>T</code> 包含引用成员，那么其相关的生命周期问题会是怎样的？</p>
<p>我们把 <code>Foo</code> 的成员改成引用成员试试，代码如下：</p>
<pre><code class="language-Rust">use std::borrow::BorrowMut;
struct Foo&lt;'a&gt;{v:&amp;'a mut i32}
    fn inc&lt;'a&gt;(foo:&amp;'a mut Foo&lt;'a&gt;) -&gt;&amp;'a Foo&lt;'a&gt; {//生命周期不能省略
    *foo.v=*foo.v + 1; // 解引用后执行加法操作
    foo
}
fn inc_ptr(mut foo_ptr:Box&lt;Foo&gt;) -&gt; Box&lt;Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    *foo_ptr.v = *foo_ptr.v + 1; / 解引用后执行加法操作
    println!(&quot;ininc_ptr：{:p}-{:p}&quot;, &amp;foo_ptr, &amp;*foo_ptr);
    foo_ptr
}
fn main(){
    let mut value = 10;
    let foo_ptr1 = Box::new(Foo{v:&amp; mut value});
    println!(&quot;foo_ptr1：{:p}-{:p}&quot;, &amp;foo_ptr1, &amp;*foo_ptr1);
    let mut foo_ptr2 = inc_ptr(foo_ptr1);
    //println!(&quot;{}&quot;,foo_ptr1.v);//编译错误，f0_ptr所有权已经丢失
    println!(&quot;foo_ptr2：{:p}-{:p}&quot;, &amp;foo_ptr2, &amp;*foo_ptr2);
     
    let foo_ref = inc(foo_ptr2.borrow_mut());//获得指针内数据的引用，调用引用版本的inc函数
    //println!(&quot;{}&quot;,foo_ptr2.v);//编译错误，无法获取foo_ptr2.v的不可变借用，因为已经存在可变借用
    println!(&quot;{}&quot;, foo_ref.v);
}
</code></pre>
<p>引用版本的 <code>inc</code> 函数生命周期不能再省略了。因为返回 <code>Foo</code> 的引用时，有两个生命周期值，一个是<code>Foo</code> 实例的生命周期，一个是 <code>Foo</code> 中引用成员的生命周期，编译器无法做推断，需要指定。但是智能指针版本 <code>inc_ptr</code> 函数的生命周期依然不用指定。<code>Foo</code> 的实例被智能指针包装，生命周期由 <code>Box</code> 负责管理。</p>
<p>如果 <code>Foo</code> 是一个 <code>Trait</code> ，而实现它的结构体有引用成员，那么 <code>Box&lt;Foo&gt;</code> 的生命周期会有什么情况。示例代码如下：</p>
<pre><code class="language-Rust">trait Foo{
    fn inc(&amp;mut self);
    fn value(&amp;self)-&gt;i32;
}

struct Bar&lt;'a&gt;{v:&amp;'a mut i32}

impl&lt;'a&gt; Foo for Bar&lt;'a&gt; {
    fn inc(&amp;mut self){
        *(self.v)=*(self.v)+1
    }
    fn value(&amp;self)-&gt;i32{
        *self.v
    }
}

fn inc(foo:&amp; mut dyn Foo)-&gt;&amp; dyn Foo {//生命周期参数被省略
    foo.inc();
    foo
}

fn inc_ptr(mut foo_ptr:Box&lt;dyn Foo&gt;) -&gt; Box&lt; dyn Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    foo_ptr.inc();
    foo_ptr
}

fn main() {
}
</code></pre>
<p>引用版本和智能指针版本都没生命周期参数，可以编译通过。不过 <code>main</code> 函数里是空的，也就是没有使用这些函数，只是定义编译通过了。我先试试使用引用版本：</p>
<pre><code class="language-Rust">fn main(){
    let mut value = 10;
    let mut foo1= Bar{v:&amp; mut value};
    let foo2 =inc(&amp;mut foo1);
    println!(&quot;{}&quot;, foo2.value());  // 输出 11
}
</code></pre>
<p>可以编译通过并正常输出。再试智能指针版本：</p>
<pre><code class="language-Rust">fn main(){
    let mut value = 10;
    let foo_ptr1 = Box::new(Bar{v:&amp;mut value});   //编译错误：value生命周期太短
    let mut foo_ptr2 = inc_ptr(foo_ptr1); //编译器提示：类型转换需要value为静态生命周期
}
</code></pre>
<p>编译失败。提示的错误信息是 <code>value</code> 的生命周期太短，需要为 <code>'static</code> 。因为 <code>Trait</code> 对象（ <code>Box&lt; dyn Foo&gt;</code>）默认是静态生命周期，编译器推断出返回数据的生命周期太短。去掉最后一行 <code>inc_ptr</code> 是可以正常编译的。</p>
<p>如果将 <code>inc_ptr</code> 的定义加上生命周期参数上述代码就可以编译通过。修改后的 <code>inc_ptr</code> 如下：</p>
<pre><code class="language-Rust">fn inc_ptr&lt;'a&gt;(mut foo_ptr:Box&lt;dyn Foo+'a&gt;) -&gt; Box&lt;dyn Foo+'a&gt; {
    foo_ptr.inc();
    foo_ptr
}
</code></pre>
<p>为什么指针版本不加生命周期参数会出错，而引用版没有生命周期参数却没有问题？</p>
<p>因为引用版是省略了生命周期参数，完整写法是：</p>
<pre><code class="language-Rust">fn inc&lt;'a&gt;(foo:&amp;'a mut dyn Foo)-&gt;&amp;'a dyn Foo {
    foo.inc();
    foo
}
</code></pre>
<h2 id="8-闭包与所有权"><a class="header" href="#8-闭包与所有权">8. 闭包与所有权</a></h2>
<p>这里不介绍闭包的使用，只说与所有权相关的内容。闭包与普通函数相比，除了输入参数，还可以捕获上线文中的变量。闭包还支持一个 <code>move</code> 关键字，来强制转移捕获变量的所有权。</p>
<p>我们先来看 <code>move</code> 对输入参数有没有影响：</p>
<pre><code class="language-Rust">//结构 Value 没有实现Copy Trait
struct Value{x:i32}
 
//没有作为引用传递参数，所有权被转移
let mut v = Value{x:0};
let fun = |p:Value| println!(&quot;in closure:{}&quot;, p.x);
fun(v);
//println!(&quot;callafterclosure:{}&quot;,point.x);//编译错误：所有权已经丢失
 
//作为闭包的可变借用入参，闭包定义没有move,所有权没有转移
let mut v = Value{x:0};
let fun = |p:&amp;mut Value| println!(&quot;in closure:{}&quot;, p.x);
fun(&amp; mut v);
println!(&quot;call after closure:{}&quot;, v.x);
 
//可变借用作为闭包的输入参数，闭包定义增加move,所有权没有转移
let mut v = Value{x:0};
let fun = move |p:&amp; mut Value| println!(&quot;in closure:{}&quot;, p.x);
fun(&amp; mut v);
println!(&quot;call after closure:{}&quot;, v.x);
</code></pre>
<p>可以看出，变量作为输入参数传递给闭包时，所有权转移规则跟普通函数是一样的，<strong>move 关键字对闭包输入参数的引用形式不起作用，输入参数的所有权没有转移。</strong></p>
<p>对于闭包捕获的上下文变量，所有权是否转移就稍微复杂一些。</p>
<p>下表列出了 10 多个例子，每个例子跟它前后的例子都略有不同，分析这些差别，我们能得到更清晰的结论。</p>
<img src="lang/rust/./img/rust_ownership_9.jpg">
<p>首先要明确被捕获的变量是哪个，这很重要。比如例 8 中，<code>ref_v</code> 是 <code>v</code> 的不可变借用，闭包捕获的是 <code>ref_v</code> ，那么所有权转移的事情跟 <code>v</code> 没有关系，<code>v</code> 不会发生与闭包相关的所有权转移事件。</p>
<p>明确了被捕获的变量后，是否转移所有权受三个因素联合影响：</p>
<ol>
<li>变量被捕获的方式（值，不可变借用，可变借用）</li>
<li>闭包是否有 move 限定</li>
<li>被捕获变量的类型是否实现了 &quot;Copy&quot; Trait</li>
</ol>
<p>是用伪代码描述是否转移所有权的规则如下：</p>
<pre><code>if 捕获方式 == 值传递 {
    if 被捕获变量的类型实现了 &quot;Copy&quot;
        不转移所有权 // 例 ：9
    else
        转移所有权 // 例 ：1
    }
}
else { // 捕获方式是借用
    if 闭包没有 move 限定
        不转移所有权 // 例：2,3,6,10,12
    else { // 有 move
        if 被捕获变量的类型实现了 &quot;Copy&quot;
            不转移所有权 // 例: 8
        else
            转移所有权 // 例: 4,5,7,11,13,14
    }
}
</code></pre>
<p>先判断捕获方式，如果是值传递，相当于变量跨域了作用域，触发转移所有权的时机。<code>move</code> 是对借用捕获起作用，要求对借用捕获也触发所有权转移。是否实现 &quot;Copy&quot; 是最后一步判断。 前文提到，我们可以把 <code>Copy Trait</code> 限定的位拷贝语义当成一种转移执行的方式。<code>Copy Trait</code> 不参与转移时机的判定，只在最后转移执行的时候起作用。</p>
<ul>
<li>例 1 和(例 2、例 3) 的区别在于捕获方式不同。</li>
<li>(例 2、例 3) 和例 4 的区别在于 move 关键字。</li>
<li>例 6 和例 7 的区别 演示了 move 关键字对借用方式捕获的影响。</li>
<li>例 8 说明了捕获不可变借用变量，无论如何都不会转移，因为不可变借用实现了 Copy.</li>
<li>例 8 和例 11 的区别就在于例 11 捕获的 &quot;不可变借用&quot;没有实现 &quot;Copy&quot; Trait 。</li>
<li>例 10 和例 11 是以“不可变借用的方式”捕获了一个“可变借用变量”</li>
<li>例 12，13，14 演示了对智能指针的效果，判断逻辑也是一致的。</li>
</ul>
<p><code>C++11</code> 的闭包需要在闭包声明中显式指定是按值还是按引用捕获，<code>Rust</code> 不一样。<code>Rust</code> 闭包如何捕获上下文变量，不取决与闭包的声明，取决于闭包内部如何使用被捕获的变量。实际上编译器会尽可能以借用的方式去捕获变量（例，除非实在不行，如例 1.)</p>
<p>这里刻意没有提及闭包背后的实现机制，即 <code>Fn</code>,<code>FnMut</code>,<code>FnOnce</code> 三个 <code>Trait</code>。因为我们只用闭包语法时是看不到编译器对闭包的具体实现的。所以我们仅从闭包语法本身去判断所有权转移的规则。</p>
<h2 id="9多线程环境下的所有权问题"><a class="header" href="#9多线程环境下的所有权问题">9.多线程环境下的所有权问题</a></h2>
<p>我们把前面的例 1 再改一下，上下文与闭包的实现都没有变化，但是闭包在另一个线程中执行。</p>
<pre><code class="language-Rust">let v = Value{x:1};
let child = thread::spawn(||{  // 编译器报错，要求添加 move 关键字
    let p = v;
    println!(&quot;inclosure:{}&quot;,p.x)
});
child.join();
</code></pre>
<p>这时，编译器报错，要求给闭包增加 <code>move</code> 关键字。也就是说，闭包作为线程的入口函数时，强制要求对被捕获的上下文变量执行移动语义。下面我们看看多线程环境下的所有权系统。</p>
<p>前面的讨论都不涉及变量在跨线程间的共享，一旦多个线程可以访问同一个变量时，情况又复杂了一些。这里有两个问题，一个仍然是内存安全问题，即“悬垂指针”等 5 个典型的内存安全问题，另一个是线程的执行顺序导致执行结果不可预测的问题。这里我们只关注内存安全问题。</p>
<p>首先，多个线程如何共享变量？前面的例子演示了启动新线程时，通过闭包捕获上下文中的变量来实现多个线程共享变量。这是一个典型的形式，我们以这个形式为基础来阐述多线程环境下的所有权问题。</p>
<p>我们来看例子代码：</p>
<pre><code class="language-Rust">//结构 Value 没有实现Copy Trait
struct Value{x:i32}
 
let v = Value{x:1};
let child = thread::spawn(move||{
    let p = v;
    println!(&quot;in closure:{}&quot;,p.x)
});
child.join();
//println!(&quot;{}&quot;,v.x);//编译错误：所有权已经丢失
</code></pre>
<p>这是前面例子的正确实现，变量 <code>v</code> 被传递到另一个线程(闭包内)，执行了所有权转移</p>
<pre><code class="language-Rust">//闭包捕获的是一个引用变量，无论如何也拿不到所有权。那么多线程环境下所有引用都可以这么传递吗？
let v = Value{x:0};
let ref_v = &amp;v;
let fun = move ||{
    let p = ref_v;
    println!(&quot;inclosure:{}&quot;,p.x)
};
fun();
println!(&quot;callafterclosure:{}&quot;,v.x);//编译执行成功
</code></pre>
<p>这个例子中，闭包捕获的是一个变量的引用，<code>Rust</code> 的引用都是实现了 <code>Copy Trait</code>，会被按位拷贝到闭包内的变量 <code>p.p</code> 只是不可变借用，没有获得所有权，但是变量 <code>v</code> 的不可变借用在闭包内外进行了传递。那么把它改成多线程方式会如何呢？这是多线程下的实现和编译器给出的错误提示：</p>
<pre><code class="language-Rust">let  v:Value = Value{x:1};
let ref_v = &amp;v;           // 编译错误：被借用的值 v0 生命周期不够长
let child = thread::spawn(move||{
    let p = ref_v;
    println!(&quot;in closure:{}&quot;,p.x)
});                                // 编译器提示：参数要求 v0 被借用时为 'static 生命周期
child.join();
</code></pre>
<p>编译器的核心意思就是 <code>v</code> 的生命周期不够长。当 <code>v</code> 的不可变借用被传递到闭包中，并在另一个线程中使用时，主线程继续执行， <code>v</code> 随时可能超出作用域范围被回收，那么子线程中的引用变量就变成了悬垂指针。 如果 <code>v</code> 为静态生命周期，这段代码就可以正常编译执行。即把第一行改为：</p>
<pre><code class="language-Rust">const  v:Value = Value{x:1};
</code></pre>
<p>当然只能传递静态生命周期的引用实际用途有限，多数情况下我们还是希望能把非静态的数据传递给另一个线程。可以采用 <code>Arc&lt;T&gt;</code>来包装数据。 <code>Arc&lt;T&gt;</code> 是引用计数的智能指针，指针计数的增减操作是线程安全的原子操作，保证计数的变化是线程安全的。</p>
<pre><code class="language-Rust">//线程安全的引用计数智能指针Arc可以在线程间传递
let v1 = Arc::new(Value{x:1});
let arc_v = v1.clone();
let child = thread::spawn(move||{
    let p = arc_v;
    println!(&quot;Arc&lt;Value&gt;in closure:{}&quot;,p.x)
});
child.join();
//println!(&quot;Arc&lt;Value&gt;inclosure:{}&quot;,arc_v.x);//编译错误，指针变量的所有权丢失
</code></pre>
<p>如果把上面的 <code>Arc&lt;T&gt;</code> 换成 <code>Rc&lt;T&gt;</code> ,编译器会报告错误，说&quot;<code>Rc&lt;T&gt;</code> 不能在线程间安全的传递&quot;。</p>
<p>通过上面的例子我们可以总结出来一点，因为闭包定义中的 <code>move</code> 关键字，以闭包启动新线程时，被闭包捕获的变量本身的所有权必然会发生转移。无论捕获的变量是 &quot;值变量&quot;还是引用变量或智能指针（上述例子中 <code>v</code>,<code>ref_v</code>,<code>arc_v</code> 本身的所有权被转移）。但是对于引用或指针，它们所指代的数据的所有权并不一定被转移。</p>
<p>那么对于上面的类型 <code>struct Value{x:i32}</code>, <strong>它的值可以在多个线程间传递</strong>(转移所有权)，它的<strong>多个不可变借用可以在多个线程间同时存在</strong>。同时 <code>&amp;Value</code> 和 <code>Arc&lt;Value&gt;</code> 可以在多个线程间传递（转移引用变量或指针变量自身的所有权），但是 <code>Rc&lt;T&gt;</code> 不行。</p>
<p>要知道，<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 只是 <code>Rust</code> 标准库(<code>std</code>)实现的，甚至不在核心库(<code>core</code>)里。也就是说，它们并不是 <code>Rust</code> 语言机制的一部分。那么，<font color=#fa8919>编译器是如何来判断 Arc<T> 可以安全的跨线程传递，而 Rc<T> 不行呢？</font></p>
<p><code>Rust</code> 核心库 的 <code>marker.rs</code> 文件中定义了两个标签 <code>Trait</code>:</p>
<pre><code class="language-Rust">pub unsafe auto trait Sync{}
pub unsafe auto trait Send{}
</code></pre>
<p>标签 <code>Trait</code> 的实现是空的，但编译器会分析某个类型是否实现了这个标签 <code>Trait</code>.</p>
<ul>
<li>如果一个类型 <code>T</code>实现了“<strong>Sync</strong>”，其含义是 <code>T</code> 可以安全的通过引用可以在多个线程间被共享。</li>
<li>如果一个类型 <code>T</code>实现了“<strong>Send</strong>”，其含义是 <code>T</code> 可以安全的跨线程边界被传递。</li>
</ul>
<p>那么上面的例子中的类型，<code>Value</code> ，<code>&amp;Value</code>，<code>Arc&lt;Value&gt;</code> 类型一定都实现了“<code>Send</code>”<code>Trait</code>. 我们看看如何实现的。</p>
<p><code>marker.rs</code> 文件还定义了两条规则：</p>
<pre><code class="language-Rust">unsafe impl&lt;T:Sync + ?Sized&gt; Send for &amp;T{}
unsafe impl&lt;T:Send + ?Sized&gt; Send for &amp; mut T{}
</code></pre>
<p>其含义分别是：</p>
<ul>
<li>如果类型 T 实现了“<strong>Sync</strong>”，则自动为类型 <code>&amp;T</code> 实现“<strong>Send</strong>”.</li>
<li>如果类型 T 实现了“<strong>Send</strong>”，则自动为类型 <code>&amp;mut T</code> 实现“<strong>Send</strong>”.</li>
</ul>
<p>这两条规则都可以直观的理解。比如：对第一条规则 <code>T</code> 实现了 “<strong>Sync</strong>”, 意味则可以在很多个线程中出现同一个 <code>T</code> 实例的 <code>&amp;T</code> 类型实例。如果线程 <code>A</code> 中先有 <code>&amp;T</code> 实例，线程 <code>B</code> 中怎么得到 <code>&amp;T</code> 的实例呢？必须要有在线程 <code>A</code> 中通过某种方式 <code>send</code> 过来，比如闭包的捕获上下文变量。而且 <code>&amp;T</code> 实现了 &quot;<code>Copy</code>&quot; <code>Trait</code>, 不会有所有权风险，数据是只读的不会有数据竞争风险，非常安全。逻辑上也是正确的。<font color=#fa8919>那为什么还会别标记为 unsafe ?</font> 我们先把这个问题暂时搁置，来看看为智能指针设计的另外几条规则。</p>
<pre><code class="language-Rust">impl &lt;T:?Sized&gt;!marker::Send for Rc&lt;T&gt;{}
impl &lt;T:?Sized&gt;!marker::Sync for Rc&lt;T&gt;{}
impl&lt;T:?Sized&gt;!marker::Send for Weak&lt;T&gt;{}
impl&lt;T:?Sized&gt;!marker::Sync for Weak&lt;T&gt;{}
unsafe impl&lt;T:?Sized+Sync+Send&gt;Send  for Arc&lt;T&gt;{}
unsafe impl&lt;T:?Sized+Sync+Send&gt;Sync for Arc&lt;T&gt;{}
</code></pre>
<p>这几条规则明确指定 <code>Rc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 不能实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”。</p>
<p>同时规定如果类型 <code>T</code> 实现了 “<strong>Sync</strong>”和 “<strong>Send</strong>”，则自动为 <code>Arc&lt;T&gt;</code> 实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”。<code>Arc&lt;T&gt;</code> 对引用计数增减是原子操作，所以它的克隆体可以在多个线程中使用(即可以为 <code>Arc&lt;T&gt;</code> 实现”<strong>Sync</strong>”和“<strong>Send</strong>”)，但为什么其前提条件是要求 <code>T</code> 也要实现&quot;<strong>Sync</strong>”和 “<strong>Send</strong>”呢。</p>
<p>我们知道，<code>Arc&lt;T&gt;</code>实现了 <code>std::borrow</code>，可以通过 <code>Arc&lt;T&gt;</code>获取 <code>&amp;T</code> 的实例，多个线程中的 <code>Arc&lt;T&gt;</code> 实例当然也可以获取到多个线程中的 <code>&amp;T</code> 实例，这就要求 <code>T</code> 必须实现“<strong>Sync</strong>”。<code>Arc&lt;T&gt;</code> 是引用计数的智能指针，任何一个线程中的 <code>Arc&lt;T&gt;</code>的克隆体都有可能成为最后一个克隆体，要负责内存的释放，必须获得被 <code>Arc&lt;T&gt;</code>指针包装的 <code>T</code> 实例的所有权，这就要求 <code>T</code> 必须能跨线程传递，必须实现 “<strong>Send</strong>”。</p>
<p><code>Rust</code> 编译器并没有为 <code>Rc&lt;T&gt;</code>或 <code>Arc&lt;T&gt;</code> 做特殊处理，甚至在语言级并不知道它们的存在，编译器本身只是根据类型是否实现了 “<strong>Sync</strong>”和 “<strong>Send</strong>”标签来进行推理。实际上可以认为编译器实现了一个检查变量跨线程传递安全性的规则引擎，编译器为基本类型直接实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”，这作为“公理”存在，然后在标准库代码中增加一些“定理”，也就是上面列举的那些规则。用户自己实现的类型可以自己指定是否实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”，多数情况下编译器会根据情况默认选择是否实现。代码编译时编译器就可以根据这些公理和规则进行推理。这就是 <code>Rust</code> 编译器支持跨线程所有权安全的秘密。</p>
<p>对于规则引擎而言，&quot;公理&quot;和&quot;定理&quot;是不言而喻无需证明的，由设计者自己声明，设计者自己保证其安全性，编译器只保证只要定理和公理没错误，它的推理也没错误。所以的&quot;公理&quot;和&quot;定理&quot;都标注为 <code>unsafe</code>,提醒声明着检查其安全性，用户也可以定义自己的&quot;定理&quot;，有自己保证安全。反而否定类规则 （实现 <code>!Send</code> 或 <code>!Sync</code>）不用标注为 <code>unsafe</code> , 因为它们直接拒绝了变量跨线程传递，没有安全问题。</p>
<p>当编译器确定 “<strong>Sync</strong>”和 “<strong>Send</strong>”适合某个类型时，会自动为其实现此。</p>
<p>比如编译器默认为以下类型实现了 <code>Sync</code> ：</p>
<ul>
<li>[u8] 和 [f64] 这样的基本类型都是 [Sync]，</li>
<li>包含它们的简单聚合类型（如元组、结构和名号）也是[Sync] 。</li>
<li>&quot;不可变&quot; 类型（如 &amp;T）</li>
<li>具有简单继承可变性的类型，如 Box <T>、Vec<T></li>
<li>大多数其他集合类型（如果泛型参数是 [Sync]，其容器就是 [Sync]。</li>
</ul>
<p>用户也可以手动使用 <code>unsafe</code> 的方式直接指定。</p>
<p>下图是与跨线程所有权相关的概念和类型的 <code>UML</code> 图。</p>
<img src="lang/rust/./img/rust_ownership_8.jpg">
<center>图 8与多线程相关的所有权转移</center><h1 id="rust-异步执行器"><a class="header" href="#rust-异步执行器">Rust 异步执行器</a></h1>
<p><a href="https://jblog.andbit.net/2019/11/10/rust-async-execution/">原文</a></p>
<p>作为从事大量并发工作(尤其是在 <a href="https://fanout.io/">Fanout</a> 的网络工作)的老牌 C/C++ 程序员，<a href="https://www.rust-lang.org/">Rust</a> 编程语言及其最近的<a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">异步</a>功能引起了我的兴趣 (intrigued)。</p>
<p>像 C/C++ 一样，Rust 没有运行时。有趣的是，即使引入了异步也同样如此。使用<code>async</code>和<code>await</code>关键字可以并发的运行代码。你需要使用自己的运行时(如：Tokio 或 async-std) 与语言的核心元素进行交互。</p>
<p>但是，你也可以实现自己的运行时！在过去的几个月中，我一直在学习所有的实现细节。在本文中，我将描述如何仅使用标准库来执行 Rust 的异步函数。</p>
<p>关于 异步以及 future 其他文章已经写了很多，因此本文主要关注于如何构建执行程序。</p>
<h2 id="语言-vs-运行时"><a class="header" href="#语言-vs-运行时">语言 vs 运行时</a></h2>
<p>Rust 提供了一下几种基本特性：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/future/trait.Future.html">Future</a> 特征：允许逐步执行某项操作。</li>
<li><code>async</code>关键字：重写你的代码以实现<code>Future</code>。</li>
<li><code>await</code>关键字：允许在生成的异步代码中使用其他的<code>Future</code>实例。</li>
</ul>
<p>就是这样。值得注意的是，Rust 在你使用<code>async</code>关键字生成<code>Future</code>之外并没有提供<code>Future</code>的具体实现。</p>
<p>为了使用 Rust 的异步特性做一些有用的事情，你将需要一些<code>Future</code>实现(仅使用生成的<code>Future</code>是没有意义的)，以及一种执行<code>Future</code>实例的方法。</p>
<p>我个人认为这是一个出色的设计。Rust 能够提供相当不错的异步语法，而不用提交给特定的运行时。</p>
<p>请注意，尽管听起来好像语言本身没有提供太多的功能，但是其内置的异步代码生成却是一个具有<a href="https://tmandry.gitlab.io/blog/posts/optimizing-await-1/">挑战性的问题</a>。</p>
<h2 id="实现一个-future"><a class="header" href="#实现一个-future">实现一个 Future</a></h2>
<p>下面是对<code>Future</code>特征的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以手动实现一个<code>Future</code>。举个例子：下面这个 Future 可以产生一个整数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::task::{Context, Poll};

struct IntFuture {
    x: i32,
}

impl Future for IntFuture {
    type Output = i32;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;i32&gt; {
        Poll::Ready(self.x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>或者你可以通过<code>async</code>关键字来构建具有同样功能的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn int_future(x: i32) -&gt; i32 {
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>在以上两种情况下，我们最终都具有满足<code>Future&lt;Output = i32&gt;</code>的类型：</p>
<pre><pre class="playground"><code class="language-rust">fn eat&lt;F: Future&lt;Output = i32&gt;&gt;(_: F) {}

fn main() {
    eat(IntFuture { x: 42 });
    eat(int_future(42));
}
</code></pre></pre>
<h2 id="嵌入的-future"><a class="header" href="#嵌入的-future">嵌入的 future</a></h2>
<p>如果你有一个异步函数的调用链，举个例子：一个 HTTP 请求的异步函数调用 TCP I/O 的异步函数，它将被编译为单个封装的<code>Future</code>。对这个 future 进行轮询将导致对其内部的 future 进行轮询。进行轮询的任何操作都不会对内部 future 有任何感知。</p>
<p>举个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_audience() -&gt; &amp;'static str {
    &quot;world&quot;
}

async fn make_greeting() -&gt; String {
    let audience = get_audience().await;

    format!(&quot;hello {}&quot;, audience)
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的代码中，如果调用<code>make_greeting()</code>来获取一个 future，轮询这个 future 将会依次轮询由<code>get_audience()</code>生成的 future，但这可以视为<code>make_greeting()</code>的实现细节。</p>
<p>所有这一切都说明：在执行 future 时，我们实际上只需要考虑最顶层的 future 即可。</p>
<h2 id="调用-poll"><a class="header" href="#调用-poll">调用 poll</a></h2>
<p>创建一个<code>Future</code>有点简单。轮询 future，也没有太多内容。我们再来看一下<code>poll()</code>的签名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>我们需要一个<code>Pin</code>和一个<code>Context</code>。你可能要问，这些到底是什么？</p>
<h2 id="pin-1"><a class="header" href="#pin-1">Pin</a></h2>
<p><code>Pin</code>是一种表示某些内存不会被移动的方式。通常，可以将结构从一个内存位置移动到另一个内存位置，而不会出现任何问题。这是因为 Rust 禁止在<code>safe</code>代码中进行自引用。举个例子，一个结构可以存储在栈上，然后被移动到堆上的<code>Box</code>中，并且 Rust 可以通过简单的复制字节来执行移动操作。然而，Rust 异步最伟大的成就之一就是可以在 await 点之间进行借用，这需要稍微调整规则。异步生成的 future 需要具有在使用 await 时保留对其内部内存引用的能力，因此需要确保其内存不会在<code>poll()</code>调用之间移动。</p>
<p>这里使用<code>Pin</code>的方式有点不直观。<code>poll()</code>函数消耗<code>Pin</code>。这意味着为了轮询一个 future，每次轮询的时候你都需要实例化一个新的<code>Pin</code>。看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut f = IntFuture { x: 42 };

let mut cx = ... // we'll talk about this later

let p = unsafe { Pin::new_unchecked(&amp;mut f) };

match p.poll(&amp;mut cx) {
    Poll::Ready(x) =&gt; println!(&quot;got int: {}&quot;, x),
    Poll::Pending =&gt; println!(&quot;future not ready&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>(请注意：有趣的是<code>Pin</code>可以被用作<code>self</code>类型。看起来 Rust 虽然将<code>self</code>限制为<code>T</code>，<code>&amp;T</code>以及<code>&amp;mut T</code>，还允许使用<a href="https://doc.rust-lang.org/reference/items/associated-items.html#methods">固定列表</a>中的其他类型)。</p>
<p>一旦通过<code>poll()</code>方法消耗并消毁了<code>Pin</code>，你是否就不打算保留固定的内存了？没有！对<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html#safety">文档</a>的质疑，“这个值一旦固定，就必须永远固定”。事实上，这就是为什么构建<code>Pin</code>是 unsafe 的原因。unsafe 的部分是你最终会丢失<code>Pin</code>，但是尽管没有<code>Pin</code>保护你了，你仍然需要坚持固定 (pinning) 合约。</p>
<h2 id="context-和-waker"><a class="header" href="#context-和-waker">Context 和 Waker</a></h2>
<p>当前，<code>Context</code>唯一要做的就是提供对<code>Waker</code>的访问。<code>Waker</code>用于指示如果<code>poll()</code>返回了<code>Poll::Pending</code>，则应在何时再次轮询 future。<code>poll()</code>采用<code>Context</code>而不是简单的<code>Waker</code>是为了实现扩展。在更高版本的 Rust 中，其他内容可能会添加到<code>Context</code>上。</p>
<p>构建<code>Context</code>需要一些努力。它唯一 (sole) 的构造函数<a href="https://doc.rust-lang.org/std/task/struct.Context.html#method.from_waker">Context::from_waker</a> 需要一个<code>Waker</code>。<code>Waker</code> 唯一的构造函数 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html#method.from_raw">Waker::from_raw</a> 需要一个<code>RawWaker</code>。并且<code>RawWaker</code>唯一的构造函数 <a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html#method.new">RawWaker::new</a> 需要一个<code>RawWakerVTable</code>。</p>
<p>让我们实现一个迷你版，不带任何操作的<code>RawWakerVTable</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::task::{RawWaker, RawWakerVTable};

unsafe fn vt_clone(data: *const ()) -&gt; RawWaker {
    RawWaker::new(data, &amp;VTABLE)
}

unsafe fn vt_wake(_data: *const ()) {
}

unsafe fn vt_wake_by_ref(_data: *const ()) {
}

unsafe fn vt_drop(_data: *const ()) {
}

static VTABLE: RawWakerVTable = RawWakerVTable::new(
    vt_clone,
    vt_wake,
    vt_wake_by_ref,
    vt_drop
);
<span class="boring">}
</span></code></pre></pre>
<p>然后我们可以像这样构建一个<code>Waker</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rw = RawWaker::new(&amp;(), &amp;VTABLE);

let w = unsafe { Waker::from_raw(rw) };
<span class="boring">}
</span></code></pre></pre>
<p>所有的这些 vtable 都是为了允许我们提供自己的唤醒行为。<code>RawWaker</code> 只是一个数据指针和一个 vtable。<code>Waker</code>对此进行了封装，并实现了熟悉的 Rust 特征，如<code>Clone</code>和<code>Drop</code>。<code>Waker</code>构造函数是 unsafe 的，因此 vtable 函数可能需要对原始指针进行解引用。</p>
<p>你可能想知道为什么 Rust 使用此自定义的 vtable 而不是使<code>Waker</code>成为特征。我相信这样做是为了使<code>Waker</code>可以被拥有，同时避免了堆分配。使用特征可能需要在某处添加<code>Box</code>。</p>
<p>最后，我们可以构建一个<code>Context</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut cx = Context::from_waker(&amp;w);
<span class="boring">}
</span></code></pre></pre>
<p>当然，在真实的应用中我们需要<code>Waker</code>做些什么。我们将在后面讨论这个问题。</p>
<h2 id="这次是真的调用-poll-了"><a class="header" href="#这次是真的调用-poll-了">这次是真的调用 poll() 了</a></h2>
<p>既然我们知道如何构建一个<code>Pin</code>和一个<code>Context</code>，我们可以调用<code>poll()</code>了。以下是轮询一个 future 程序的完整源代码：</p>
<pre><pre class="playground"><code class="language-rust">use std::future::Future;
use std::pin::Pin;
use std::task::{Poll, Context, Waker, RawWaker, RawWakerVTable};

unsafe fn vt_clone(data: *const ()) -&gt; RawWaker {
    RawWaker::new(data, &amp;VTABLE)
}

unsafe fn vt_wake(_data: *const ()) {
}

unsafe fn vt_wake_by_ref(_data: *const ()) {
}

unsafe fn vt_drop(_data: *const ()) {
}

static VTABLE: RawWakerVTable = RawWakerVTable::new(
    vt_clone,
    vt_wake,
    vt_wake_by_ref,
    vt_drop
);

async fn get_greeting() -&gt; &amp;'static str {
    &quot;hello world&quot;
}

fn main() {
    let mut f = get_greeting();

    let rw = RawWaker::new(&amp;(), &amp;VTABLE);
    let w = unsafe { Waker::from_raw(rw) };
    let mut cx = Context::from_waker(&amp;w);

    let p = unsafe { Pin::new_unchecked(&amp;mut f) };
    assert_eq!(p.poll(&amp;mut cx), Poll::Ready(&quot;hello world&quot;));
}
</code></pre></pre>
<h2 id="触发-waker"><a class="header" href="#触发-waker">触发 Waker</a></h2>
<p>让我们来创建一个知道如何唤醒自己的 future。</p>
<p>以下是计时器的实现。可以以期望的持续时间构建它。第一次轮询时，它会产生一个线程并返回<code>Poll::Pending</code>。下次轮询时，它将返回<code>Poll::Ready</code>。线程休眠然后调用<code>wake()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time;
use std::thread;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct TimerFuture {
    duration: time::Duration,
    handle: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl TimerFuture {
    fn new(duration: time::Duration) -&gt; Self {
        Self {
            duration,
            handle: None,
        }
    }
}

impl Future for TimerFuture {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;()&gt; {
        match &amp;self.handle {
            None =&gt; {
                let duration = self.duration;
                let waker = cx.waker().clone();
                self.handle = Some(thread::spawn(move || {
                    thread::sleep(duration);
                    waker.wake();
                }));
                Poll::Pending
            },
            Some(_) =&gt; {
                let handle = self.handle.take().unwrap();
                handle.join().unwrap();
                Poll::Ready(())
            },
        }
    }
}

// convenience wrapper for use in async functions
fn sleep(duration: time::Duration) -&gt; TimerFuture {
    TimerFuture::new(duration)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Waker</code>已被克隆，因此我们可以在<code>poll()</code>返回后继续使用它。事实上，我们还可以将其移动到另一个线程。</p>
<p>请注意，在实际的应用程序中，你不希望为每个计时器都生成一个线程。取而代之的是，计时器可能会在某些事件反应堆 (evented reactor) 中注册。不过在此示例中，我们将使其保持简单。</p>
<h2 id="管理不同类型的-future"><a class="header" href="#管理不同类型的-future">管理不同类型的 future</a></h2>
<p>在我们接触执行器之前，我们需要解决最后一个挑战：改变 future 的类型。</p>
<p>不同的 future 可以有不同的<code>Output</code>类型(如：<code>Future&lt;Output = i32&gt;</code>和<code>Future&lt;Output = String&gt;</code>)，因此，<code>poll()</code>也会有不同的返回值。这意味着如果我们要构建一个执行器，我们不能简单的通过将 future 放入类似<code>Vec&lt;Box&lt;dyn Future&gt;&gt;</code>的结构中，即使有可能，我们也无法使用相同的代码对其进行处理。</p>
<p>据我所知，解决方案是为执行器跟踪所有 future 选择一个共同的返回类型(即：顶级 future)。举个例子，你可以决定所有的顶级 future 都没有返回值类型，因此你可以将它们包含在<code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>中。请注意，嵌套的 future 仍然可以具有任意的 (arbitrary) 返回值类型。一个不带返回值的异步函数可以等待一个返回<code>String</code>的 future。之所以可行是因为所有的嵌套 future 都隐藏在外部的 future 中，而执行者只关心外部的 future。</p>
<p>我们的类型问题还不止于此。<code>poll()</code>函数需要其具体类型的固定引用。回忆一下前面大写的<code>Self</code>签名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这意味着即使两个不同的 future 实现都具有相同的<code>Output</code>类型并因此具有相同的特征，我们仍然无法使用非通用的代码来处理它们！</p>
<p>可能需要具体的类型，因此<code>Pin</code>可以保护一块已知大小的区域。无论如何，<code>dyn Future</code>都是没有用的。</p>
<p>解决此问题的一种方式是将细节隐藏在闭包中。我们可以使用单态化 (monomorphization) 为每个具体的 future 实现生成不同的代码，但是让闭包共享相同的函数签名。在下面，我们创建符合特征<code>dyn FnMut(&amp;mut Context) -&gt; Poll&lt;()&gt;</code>(对于带有<code>Output = ()</code>的 future) 的闭包，并将其装箱：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PollFn = dyn FnMut(&amp;mut Context) -&gt; Poll&lt;()&gt;;

struct WrappedFuture {
    poll_fn: Box&lt;PollFn&gt;,
}

impl WrappedFuture {
    pub fn new&lt;F&gt;(mut f: F) -&gt; Self
    where
        F: Future&lt;Output = ()&gt; + 'static
    {
        let c = move |cx: &amp;mut Context| {
            let p: Pin&lt;&amp;mut F&gt; = unsafe { Pin::new_unchecked(&amp;mut f) };
            match p.poll(cx) {
                Poll::Ready(_) =&gt; Poll::Ready(()),
                Poll::Pending =&gt; Poll::Pending,
            }
        };

        Self {
            poll_fn: Box::new(c),
        }
    }

    pub fn poll(&amp;mut self, cx: &amp;mut Context) -&gt; Poll&lt;()&gt; {
        (self.poll_fn)(cx)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>WrappedFuture</code>，我们可以对所有 future 一视同仁：</p>
<pre><pre class="playground"><code class="language-rust">// generates Future&lt;Output = ()&gt;
async fn print_hello() {
    println!(&quot;hello&quot;);
}

// generates Future&lt;Output = ()&gt;
async fn print_goodbye() {
    println!(&quot;goodbye&quot;);
}

fn main() {
    let mut futures: Vec&lt;WrappedFuture&gt; = Vec::new();

    futures.push(WrappedFuture::new(print_hello()));
    futures.push(WrappedFuture::new(print_goodbye()));

    for f in futures.iter_mut() {
        let mut cx = ... // context
        assert_eq!(f.poll(&amp;mut cx), Poll::Ready(()));
    }
}
</code></pre></pre>
<h2 id="一个简单的执行器"><a class="header" href="#一个简单的执行器">一个简单的执行器</a></h2>
<p>为了执行我们的 future，我们需要做以下三件事：</p>
<ul>
<li>在某处跟踪 future</li>
<li>当创建 future 时，对其进行轮询</li>
<li>实现<code>Waker</code>以便我们可以知道何时再次轮询 future</li>
</ul>
<p>下面是一个基础的执行器。它使用两个向量(<code>need_poll</code>和<code>sleeping</code>)对 future 进行跟踪。调用<code>spawn</code>将一个 future 添加到<code>need_poll</code>中。</p>
<p>与其直接使用<code>WrappedFuture</code>，不如使用<code>Arc/Mutex</code>对其进行封装，以便可以在线程之间共享 future。我们声明一个别名(<code>SharedFuture</code>)，以减少噪音。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SharedFuture = Arc&lt;Mutex&lt;WrappedFuture&gt;&gt;;

struct ExecutorData {
    need_poll: Vec&lt;SharedFuture&gt;,
    sleeping: Vec&lt;SharedFuture&gt;,
}

struct Executor {
    data: Arc&lt;(Mutex&lt;ExecutorData&gt;, Condvar)&gt;,
}

impl Executor {
    pub fn new() -&gt; Self {
        let data = ExecutorData {
            need_poll: Vec::new(),
            sleeping: Vec::new(),
        };

        Self {
            data: Arc::new((Mutex::new(data), Condvar::new())),
        }
    }

    pub fn spawn&lt;F&gt;(&amp;self, f: F)
    where
        F: Future&lt;Output = ()&gt; + 'static
    {
        let (lock, _) = &amp;*self.data;

        let mut data = lock.lock().unwrap();

        data.need_poll.push(Arc::new(Mutex::new(WrappedFuture::new(f))));
    }

    pub fn wake(
        data: &amp;mut Arc&lt;(Mutex&lt;ExecutorData&gt;, Condvar)&gt;,
        wf: &amp;SharedFuture
    ) {
        let (lock, cond) = &amp;**data;

        let mut data = lock.lock().unwrap();

        let mut pos = None;
        for (i, f) in data.sleeping.iter().enumerate() {
            if Arc::ptr_eq(f, wf) {
                pos = Some(i);
                break;
            }
        }
        if pos.is_none() {
            // unknown future
            return
        }

        let pos = pos.unwrap();

        let f = data.sleeping.remove(pos);
        data.need_poll.push(f);

        cond.notify_one();
    }

    pub fn exec(&amp;self) {
        loop {
            let (lock, cond) = &amp;*self.data;

            let mut data = lock.lock().unwrap();

            if data.need_poll.is_empty() {
                if data.sleeping.is_empty() {
                    // no tasks, we're done
                    break;
                }

                data = cond.wait(data).unwrap();
            }

            let need_poll = mem::replace(
                &amp;mut data.need_poll,
                Vec::new()
            );

            mem::drop(data);

            let mut need_sleep = Vec::new();

            for f in need_poll {
                let w = MyWaker {
                    data: Arc::clone(&amp;self.data),
                    f: Arc::new(Mutex::new(Some(Arc::clone(&amp;f)))),
                }.into_task_waker();

                let mut cx = Context::from_waker(&amp;w);

                let result = {
                    f.lock().unwrap().poll(&amp;mut cx)
                };
                match result {
                    Poll::Ready(_) =&gt; {},
                    Poll::Pending =&gt; {
                        need_sleep.push(f);
                    },
                }
            }

            let mut data = lock.lock().unwrap();

            data.sleeping.append(&amp;mut need_sleep);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>exec</code>函数循环并轮询 future。首先，它检查是否有 future 需要被轮询。如果没有，它将会等待一个休眠的 future 被唤醒。一旦有要轮询的 future，便对其进行轮询。如果轮询返回了<code>Ready</code>，表示 future 已经完成，我们可以将其释放。如果轮询返回了<code>Pending</code>，我们将 future 移动到<code>sleeping</code>向量中。如果没有剩余的 future，则循环退出。</p>
<p>为了唤醒一个执行器，需要调用<code>Executor::wake</code>。这是一个关联函数，旨在由<code>MyWaker</code>从另一个线程中调用。</p>
<p><code>MyWaker</code>代码如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct MyWaker {
    data: Arc&lt;(Mutex&lt;ExecutorData&gt;, Condvar)&gt;,
    f: Arc&lt;Mutex&lt;Option&lt;SharedFuture&gt;&gt;&gt;,
}

impl MyWaker {
    ...

    fn wake(mut self) {
        self.wake_by_ref();
    }

    fn wake_by_ref(&amp;mut self) {
        let f: &amp;mut Option&lt;SharedFuture&gt; = &amp;mut self.f.lock().unwrap();
        if f.is_some() {
            let f: SharedFuture = f.take().unwrap();
            Executor::wake(&amp;mut self.data, &amp;f);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>唤醒器的实现旨在一次性使用，但是必须是可克隆的。这就是为什么内部<code>SharedFuture</code>由<code>Option</code>以及<code>Arc/Mutex</code>封装的原因。特定 future 的唤醒器集合可以安全共享单个<code>Option&lt;SharedFuture&gt;</code>的访问权限。在集合中的任何一个唤醒器上调用<code>wake()</code>时，都会唤醒 future，并将选项设置为<code>None</code>。</p>
<p>为了让我们的唤醒器实现可用，我们需要将其集成到 vtable 中，以便可以由<code>Waker</code>对其进行控制：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyWaker {
    ...

    fn into_task_waker(self) -&gt; Waker {
        let w = Box::new(self);
        let rw = RawWaker::new(Box::into_raw(w) as *mut (), &amp;VTABLE);
        unsafe { Waker::from_raw(rw) }
    }

    ...
}

unsafe fn vt_clone(data: *const ()) -&gt; RawWaker {
    let w = (data as *const MyWaker).as_ref().unwrap();
    let new_w = Box::new(w.clone());

    RawWaker::new(Box::into_raw(new_w) as *mut (), &amp;VTABLE)
}

unsafe fn vt_wake(data: *const ()) {
    let w = Box::from_raw(data as *mut MyWaker);
    w.wake();
}

unsafe fn vt_wake_by_ref(data: *const ()) {
    let w = (data as *mut MyWaker).as_mut().unwrap();
    w.wake_by_ref();
}

unsafe fn vt_drop(data: *const ()) {
    Box::from_raw(data as *mut MyWaker);
}
<span class="boring">}
</span></code></pre></pre>
<p>基本上，以上 unsafe 代码将 vtable 函数连接到<code>MyWaker</code>的常规 Rust 方法，以处理克隆 (clone) 和销毁 (drop) 操作。</p>
<p>很明显，这不是最复杂的 (sophisticated) 执行器，但它足以作为示例。</p>
<h2 id="使用执行器"><a class="header" href="#使用执行器">使用执行器</a></h2>
<p>让我们来试试看！<code>sleep</code>函数是我们之前定义的<code>TimerFuture</code>的封装。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let e = Executor::new();

    e.spawn(async {
        println!(&quot;a&quot;);
        sleep(time::Duration::from_millis(200)).await;
        println!(&quot;c&quot;);
    });

    e.spawn(async {
        sleep(time::Duration::from_millis(100)).await;
        println!(&quot;b&quot;);
        sleep(time::Duration::from_millis(200)).await;
        println!(&quot;d&quot;);
    });

    e.exec();
}
</code></pre></pre>
<p>以下输出如预期的一样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a
b
c
d
<span class="boring">}
</span></code></pre></pre>
<p>完整的代码见<a href="https://github.com/jkarneges/rust-executor-example">这里</a>。</p>
<h1 id="rust-中的宏带有示例的教程"><a class="header" href="#rust-中的宏带有示例的教程">Rust 中的宏：带有示例的教程</a></h1>
<p><a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/">原文</a></p>
<p><img src="lang/rust/./img/macro_in_rust.webp" alt="macro in rust" /></p>
</br>
<p>在本篇教程中，我们将介绍有关 Rust 宏的全部内容，包括 Rust 中宏的引入以及在示例中演示如何使用 Rust 宏。</p>
<p>我们将包含一下内容：</p>
<ul>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E4%BB%80%E4%B9%88%E6%98%AF-Rust-%E4%B8%AD%E7%9A%84%E5%AE%8F%EF%BC%9F">什么是 Rust 中的宏？</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#Rust-%E5%AE%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">Rust 宏的类型</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#Rust-%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F">Rust 中的声明式宏</a>
<ul>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E5%88%9B%E5%BB%BA%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F">创建声明式宏</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#Rust-%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E8%A7%A3%E6%9E%90">Rust 中声明式宏的高级解析</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E6%AE%B5">解析结构体的名称和字段</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E8%A7%A3%E6%9E%90%E5%85%83%E6%95%B0%E6%8D%AE">从结构体中解析元数据</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F%E7%9A%84%E9%99%90%E5%88%B6">声明式宏的限制</a></li>
</ul>
</li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#Rust-%E4%B8%AD%E7%9A%84%E8%BF%87%E7%A8%8B%E5%AE%8F">Rust 中的过程宏</a>
<ul>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E5%B1%9E%E6%80%A7%E5%BC%8F%E5%AE%8F">属性式宏</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E5%AE%8F">自定义派生宏</a></li>
<li><a href="lang/rust/11-Rust%E4%B8%AD%E7%9A%84%E5%AE%8F:%E5%B8%A6%E6%9C%89%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%95%99%E7%A8%8B.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%AE%8F">函数式宏</a></li>
</ul>
</li>
</ul>
<h2 id="什么是-rust-中的宏"><a class="header" href="#什么是-rust-中的宏">什么是 Rust 中的宏？</a></h2>
<p>Rust 对宏提供了出色的支持。使用宏可以编写代码，该代码可以在编译期间生成其他的代码，这被称为元编程。</p>
<p>宏提供了类似于函数的功能，却没有运行时成本。但是，由于在编译期间扩展了宏，因此存在一些编译时的开销。</p>
<p>Rust 的宏与 C 中的宏有很大的不同。Rust 宏可以应用于 token 树，但是 C 宏只能用于文本替换 (substitution)。</p>
<h2 id="rust-宏的类型"><a class="header" href="#rust-宏的类型">Rust 宏的类型</a></h2>
<p>Rust 宏有两种类型：</p>
<ol>
<li><strong>声明式宏</strong>：使你能够编写类似于在 Rust 代码中作为参数运行的 match 表达式。它使用你提供的代码生成可以替换宏调用的代码。</li>
<li><strong>过程宏</strong>：使你能够在 Rust 代码的抽象语法树 (AST) 上进行操作。过程宏是从一个(或两个)<code>TokenStream</code>到另一个<code>TokenStream</code>的函数，其输出替换宏调用。</li>
</ol>
<p>让我们深入学习声明式宏与过程宏，并探讨一些示例，学习如何在 Rust 中使用宏。</p>
<h2 id="rust-中的声明式宏"><a class="header" href="#rust-中的声明式宏">Rust 中的声明式宏</a></h2>
<p>声明式宏通过<code>macro_rules!</code>来定义。声明式宏的功能性稍微差一些，但是提供了易于使用的接口来创建宏以移除重复的代码。常见的声明式宏如<code>println!</code>。声明式宏提供了类似 match 的接口，在匹配时，宏会被替换为对应的匹配分支内的代码。</p>
<h3 id="创建声明式宏"><a class="header" href="#创建声明式宏">创建声明式宏</a></h3>
<pre><pre class="playground"><code class="language-rust">// use macro_rules! &lt;name of macro&gt;{&lt;Body&gt;}
macro_rules! add{
 // macth like arm for macro
    ($a:expr,$b:expr)=&gt;{
 // macro expand to this code
        {
// $a and $b will be templated using the value/variable provided to macro
            $a+$b
        }
    }
}

fn main(){
 // call to macro, $a=1 and $b=2
    add!(1,2);
}
</code></pre></pre>
<p>这段代码创建了一个可以将两个数相加的宏。<code>[macro_rules!]</code>与宏的名称，<code>add</code>以及宏的主体一起使用。</p>
<p>这个宏并没有将两个数相加，它只是将自己替换成了将两个数相加的代码。宏的每一个分支都携带了对应功能需要的参数，并且有多种类型可以分配给参数。如果<code>add</code>函数也可以采用单个参数，我们可以添加另一个分支：</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add{
 // first arm match add!(1,2), add!(2,3) etc
    ($a:expr,$b:expr)=&gt;{
        {
            $a+$b
        }
    };
// Second arm macth add!(1), add!(2) etc
    ($a:expr)=&gt;{
        {
            $a
        }
    }
}

fn main(){
// call the macro
    let x=0;
    add!(1,2);
    add!(x);
}
</code></pre></pre>
<p>一个宏中可以有多个分支，可以根据不同的参数扩展为不同的代码。每个分支可以采用多个参数，以<code>$</code>符号开头，后跟 token 的类型。</p>
<ul>
<li><code>item</code> - 项，如：函数，结构体，模块等</li>
<li><code>block</code> - 块 (语句或表达式的代码块，被大括号包含)</li>
<li><code>stmt</code> - 语句</li>
<li><code>pat</code> - 模式</li>
<li><code>expr</code> - 表达式</li>
<li><code>ty</code> - 类型</li>
<li><code>ident</code> - 标识符</li>
<li><code>path</code> - 路径(如：<code>foo</code>，<code>::std::mem::replace</code>，<code>transmute::&lt;_, int&gt;</code>，...)</li>
<li><code>meta</code> - 元项 (meta item)，即<code>#[...]</code>和<code>#![...]</code>属性中的内容</li>
<li><code>tt</code> - 单个 token 树</li>
<li><code>vis</code> - 可能为空的可见性 (Visibility) 限定词</li>
<li><code>lifetime</code> - 生命周期</li>
<li><code>literal</code> - 字面量表达式</li>
</ul>
<p>在本例中，我们使用 token 类型为<code>ty</code>的<code>$typ</code>参数作为数据类型，如<code>u8</code>，<code>u16</code>等。在数字相加之前，这个宏会将其转换为指定的类型。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add_as{
// using a ty token type for macthing datatypes passed to maccro
    ($a:expr,$b:expr,$typ:ty)=&gt;{
        $a as $typ + $b as $typ
    }
}

fn main(){
    println!(&quot;{}&quot;,add_as!(0,2,u8));
}
</code></pre></pre>
<p>Rust 宏还支持传入非固定数量的参数。运算符和正则表达式非常类似。<code>*</code>用于 0 个或多个 token 类型，<code>+</code>用于 0 个或 1 个参数。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add_as{
    (
  // repeated block
  $($a:expr)
 // seperator
   ,
// zero or more
   *
   )=&gt;{
       { 
   // to handle the case without any arguments
   0
   // block to be repeated
   $(+$a)*
     }
    }
}

fn main(){
    println!(&quot;{}&quot;,add_as!(1,2,3,4)); // =&gt; println!(&quot;{}&quot;,{0+1+2+3+4})
}
</code></pre></pre>
<p>重复的 token 类型包含在<code>$()</code>中，后面跟一个分隔符以及一个<code>*</code>或者<code>+</code>，表示 token 将要重复的次数。分隔符用来区分彼此的 token。后面跟<code>*</code>或<code>+</code>的<code>$()</code>用于表示重复的代码块。在上面的示例中，<code>+$a</code>是需要重复的代码。</p>
<p>如果你仔细看这段代码，你会发现代码中添加了一个额外的 0 来使语法有效。要删除这个 0 并使<code>add</code>表达式和参数一样，我们需要创建一个名为 <a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html">TT muncher</a> 的新宏。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add{
 // first arm in case of single argument and last remaining variable/number
    ($a:expr)=&gt;{
        $a
    };
// second arm in case of two arument are passed and stop recursion in case of odd number ofarguments
    ($a:expr,$b:expr)=&gt;{
        {
            $a+$b
        }
    };
// add the number and the result of remaining arguments 
    ($a:expr,$($b:tt)*)=&gt;{
       {
           $a+add!($($b)*)
       }
    }
}

fn main(){
    println!(&quot;{}&quot;,add!(1,2,3,4));
}
</code></pre></pre>
<p>TT muncher 递归式的分别处理每个 token。一次处理一个 token 比较容易。这个宏有三个分支：</p>
<ol>
<li>第一个分支处理传入单个参数的情况</li>
<li>第二个分支处理传入两个参数的情况</li>
<li>第三个分支通过传入剩余的参数再次调用<code>add</code>宏</li>
</ol>
<p>宏参数不需要逗号分隔符。多个 token 可以使用不同的 token 类型。举个例子，括号可以与<code>ident</code> token 类型一起使用。Rust 编译器采用匹配的分支，并从参数字符串中提取变量。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ok_or_return{
// match something(q,r,t,6,7,8) etc
// compiler extracts function name and arguments. It injects the values in respective varibles.
    ($a:ident($($b:tt)*))=&gt;{
       {
        match $a($($b)*) {
            Ok(value)=&gt;value,
            Err(err)=&gt;{
                return Err(err);
            }
        }
        }
    };
}

fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{
    if i+j&gt;2 {
        Ok((i,j))
    } else {
        Err(&quot;error&quot;.to_owned())
    }
}

fn main()-&gt;Result&lt;(),String&gt;{
    ok_or_return!(some_work(1,4));
    ok_or_return!(some_work(1,0));
    Ok(())
}
</code></pre></pre>
<p>如果某个操作返回<code>Err</code>或者某个操作的值返回<code>Ok</code>，则<code>ok_or_return</code>宏返回该函数。它将函数作为一个参数并在内部的 match 语句中执行。对于传递给函数的参数，它重复的使用。</p>
<p>通常，需要将几个宏放在同一个宏分组中。在本例中，使用了内部的宏规则。它有助于操作宏输入并编写干净的 TT muncher。</p>
<p>为了创建一个内部规则，添加一个以<code>@</code>开头的规则名作为参数。现在，除非明确将其指定为参数，否则该宏将永远不会匹配内部规则。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ok_or_return{
 // internal rule.
    (@error $a:ident,$($b:tt)* )=&gt;{
        {
        match $a($($b)*) {
            Ok(value)=&gt;value,
            Err(err)=&gt;{
                return Err(err);
            }
        }
        }
    };

// public rule can be called by the user.
    ($a:ident($($b:tt)*))=&gt;{
        ok_or_return!(@error $a,$($b)*)
    };
}

fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{
    if i+j&gt;2 {
        Ok((i,j))
    } else {
        Err(&quot;error&quot;.to_owned())
    }
}

fn main()-&gt;Result&lt;(),String&gt;{
   // instead of round bracket curly brackets can also be used
    ok_or_return!{some_work(1,4)};
    ok_or_return!(some_work(1,0));
    Ok(())
}
</code></pre></pre>
<h3 id="rust-中声明式宏的高级解析"><a class="header" href="#rust-中声明式宏的高级解析">Rust 中声明式宏的高级解析</a></h3>
<p>宏有时会执行需要解析 Rust 语言本身的任务。</p>
<p>将到目前为止我们已经介绍的概念放在一起，创建一个宏，该宏通过使<code>pub</code>关键字作为前缀，将结构体的可见性设置为公开。</p>
<p>首先，我们需要解析 Rust 结构体以获取它的名称，字段以及字段类型。</p>
<h3 id="解析结构体的名称和字段"><a class="header" href="#解析结构体的名称和字段">解析结构体的名称和字段</a></h3>
<p>结构体的声明开头有一个可见性关键字(如<code>pub</code>)，后面跟<code>struct</code>关键字，接着是结构体的名称，最后是结构体的主体。</p>
<p><img src="lang/rust/./img/Parsing-Struct-Name-Field-Diagram.webp" alt="Parsing-Struct-Name-Field-Diagram" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! make_public{
    (
  // use vis type for visibility keyword and ident for struct name
     $vis:vis struct $struct_name:ident { }
    ) =&gt; {
        {
            pub struct $struct_name{ }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>$vis</code>对应可见性，<code>$struct_name</code>对应结构体的名称。为了使结构体是外部可见的，我们需要添加<code>pub</code>关键字并忽略<code>$vis</code>变量。</p>
<p><img src="lang/rust/./img/Make-Struct-Public-with-Keyword.webp" alt="Make-Struct-Public-with-Keyword" /></p>
<p>一个结构体中可能包含多个字段，这些字段可能具有相同或不同的数据类型以及可见性。<code>ty</code> token 类型用于数据类型，<code>vis</code> 用于可见性以及<code>ident</code>用于字段名。我们将使用<code>*</code>来重复表示 0 个或多个字段。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! make_public{
    (
     $vis:vis struct $struct_name:ident {
        $(
 // vis for field visibility, ident for field name and ty for field data type
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*
    }
    ) =&gt; {
        {
            pub struct $struct_name{
                $(
                pub $field_name : $field_type,
                )*
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="从结构体中解析元数据"><a class="header" href="#从结构体中解析元数据">从结构体中解析元数据</a></h3>
<p>通常结构体会有一些附加的元数据或者过程宏，如<code>#[derive(Debug)]</code>。此元数据需要保持不变。解析这个元数据需要使用<code>meta</code>类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! make_public{
    (
     // meta data about struct
     $(#[$meta:meta])* 
     $vis:vis struct $struct_name:ident {
        $(
        // meta data about field
        $(#[$field_meta:meta])*
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*$(,)+
    }
    ) =&gt; {
        { 
            $(#[$meta])*
            pub struct $struct_name{
                $(
                $(#[$field_meta:meta])*
                pub $field_name : $field_type,
                )*
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们的<code>make_public</code>宏已经就绪。为了查看它是如何工作的，我们使用 <a href="https://play.rust-lang.org/">Rust Playground</a> 将宏扩展为已经编译的实际代码。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_public{
    (
     $(#[$meta:meta])* 
     $vis:vis struct $struct_name:ident {
        $(
        $(#[$field_meta:meta])*
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*$(,)+
    }
    ) =&gt; {

            $(#[$meta])*
            pub struct $struct_name{
                $(
                $(#[$field_meta:meta])*
                pub $field_name : $field_type,
                )*
            }
    }
}

fn main(){
    make_public!{
        #[derive(Debug)]
        struct Name{
            n:i64,
            t:i64,
            g:i64,
        }
    }
}
</code></pre></pre>
<p>扩展后的代码如下所示：</p>
<pre><pre class="playground"><code class="language-rust">// some imports

macro_rules! make_public {
    ($ (#[$ meta : meta]) * $ vis : vis struct $ struct_name : ident
     {
         $
         ($ (#[$ field_meta : meta]) * $ field_vis : vis $ field_name : ident
          : $ field_type : ty), * $ (,) +
     }) =&gt;
    {

            $ (#[$ meta]) * pub struct $ struct_name
            {
                $
                ($ (#[$ field_meta : meta]) * pub $ field_name : $
                 field_type,) *
            }
    }
}

fn main() {
        pub struct name {
            pub n: i64,
            pub t: i64,
            pub g: i64,
    }
}
</code></pre></pre>
<h3 id="声明式宏的限制"><a class="header" href="#声明式宏的限制">声明式宏的限制</a></h3>
<p>声明式宏有一些限制。一些与 Rust 宏本身有关，一些是声明式宏所特有的。</p>
<ul>
<li>缺少宏的自动提示与扩展的支持</li>
<li>调试声明式宏非常困难</li>
<li>有限的修改功能</li>
<li>(编译后产生)超大的二进制文件</li>
<li>需要更长的编译时间(声明式宏与过程宏都有这个问题)</li>
</ul>
<h2 id="rust-中的过程宏"><a class="header" href="#rust-中的过程宏">Rust 中的过程宏</a></h2>
<p><a href="https://blog.logrocket.com/procedural-macros-in-rust/">过程宏</a>是宏的更高级的版本。过程宏允许你扩展已存在的 Rust 语法。它接受任意的输入并返回合法的 Rust 代码。</p>
<p>过程宏是一个接受<code>TokenStream</code>作为输入并返回另一个<code>TokenStream</code>作为输出。过程宏操作输入的<code>TokenStream</code>以产生一个输出流。</p>
<p>这里有三种类型的过程宏：</p>
<ol>
<li>属性式宏</li>
<li>派生宏</li>
<li>函数式宏</li>
</ol>
<p>我们将会在下面详细的介绍每一种类型的过程宏。</p>
<h3 id="属性式宏"><a class="header" href="#属性式宏">属性式宏</a></h3>
<p>属性式宏可以让你创建一个依附于某一项的自定义属性，并允许你操作该项。它还可以携带参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[some_attribute_macro(some_argument)]
fn perform_task(){
// some code
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的代码中，<code>some_attribute_macros</code>是一个属性宏，它操作<code>perform_task</code>函数。</p>
<p>为了写一个属性式宏，使用<code>cargo new macro-demo --lib</code>创建一个项目。一旦项目就绪，更新<code>Cargo.toml</code>来告诉项目将要创建一个过程宏。</p>
<pre><code class="language-toml"># Cargo.toml
[lib]
proc-macro = true
</code></pre>
<p>现在我们开始尝试编写过程宏。</p>
<p>过程宏是一个接收<code>TokenStream</code>作为输入，并返回另一个<code>TokenStream</code>的函数。为了编写一个过程宏，我们需要编写一个解析器解析<code>TokenStream</code>。Rust 社区有一个非常棒的库：<a href="https://github.com/dtolnay/syn">syn</a>，用来解析<code>TokenStream</code>。</p>
<p><a href="https://github.com/dtolnay/syn">syn</a> 为 Rust 语法提供了现成的解析器用来解析<code>TokenStream</code>。你也可以通过组合 <a href="https://github.com/dtolnay/syn">syn</a> 提供的更加底层的解析器来解析你的语法。</p>
<p>在<code>Cargo.toml</code>中添加<code>syn</code>和<code>quote</code>：</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
syn = {version=&quot;1.0.57&quot;,features=[&quot;full&quot;,&quot;fold&quot;]}
quote = &quot;1.0.8&quot;
</code></pre>
<p>现在我们可以使用编译器为编写过程宏而提供<code>proc_macro</code>库在<code>lib.rs</code>中编写属性式宏。一个过程宏库不能导出过程宏以外的其他任何东西，并且在 crate 中定义的过程宏不能在该 crate 中使用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
extern crate proc_macro;
use proc_macro::{TokenStream};
use quote::{quote};

// using proc_macro_attribute to declare an attribute like procedural macro
#[proc_macro_attribute]
// _metadata is argument provided to macro call and _input is code to which attribute like macro attaches
pub fn my_custom_attribute(_metadata: TokenStream, _input: TokenStream) -&gt; TokenStream {
    // returing a simple TokenStream for Struct
    TokenStream::from(quote!{struct H{}})
}
<span class="boring">}
</span></code></pre></pre>
<p>为了测试我们添加的宏，通过创建一个名为<code>tests</code>的文件夹并在其中添加<code>attribute_macro.rs</code>文件来创建一个集成测试。在这个文件中，我们测试我们的属性式宏。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/attribute_macro.rs

use macro_demo::*;

// macro converts struct S to struct H
#[my_custom_attribute]
struct S{}

#[test]
fn test_macro(){
// due to macro we have struct H in scope
    let demo=H{};
}
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>cargo test</code>命令运行上面的测试代码。</p>
<p>既然我们理解了过程宏的基本概念，让我们使用<code>syn</code>来操作并解析更高级的<code>TokenStream</code>。</p>
<p>为了学习<code>syn</code>是如何解析并操作<code>TokenStream</code>的，我们以<code>syn</code>的<a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs">Github仓库</a> 的一个示例为例。这个示例创建了一个在值变更时跟踪变量的 Rust 宏。</p>
<p>首先，我们需要弄清楚宏是如何操作它依附的代码的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[trace_vars(a)]
fn do_something(){
  let a=9;
  a=6;
  a=0;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>trace_vars</code>宏传入它需要跟踪的变量名，并且一旦传入的变量<code>a</code>的值发生改变，就会注入了一条打印语句。它跟踪了输入变量的值。</p>
<p>首先，解析属性式宏依附的代码。<code>syn</code>为 Rust 函数语法提供了一个内置的解析器。<code>ItemFn</code>将会解析函数，并且当语法是非法时抛出一个错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn trace_vars(_metadata: TokenStream, input: TokenStream) -&gt; TokenStream {
// parsing rust function to easy to use struct
    let input_fn = parse_macro_input!(input as ItemFn);
    TokenStream::from(quote!{fn dummy(){}})
}
<span class="boring">}
</span></code></pre></pre>
<p>既然我们有了已解析的输入，让我们转到元数据。对于元数据，没有内置的解析器会起作用，因此我们需要使用<code>syn</code>的<code>parse</code>模块编写我们自己的解析器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[trace_vars(a,c,b)] // we need to parse a &quot;,&quot; seperated list of tokens
// code
<span class="boring">}
</span></code></pre></pre>
<p>为了让<code>syn</code>起作用，我们需要实现<code>syn</code>提供的<code>Parse</code>特征。<code>Punctuated</code>被用来创建一个以<code>,</code>分隔的<code>Ident</code>的向量。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Args{
    vars:HashSet&lt;Ident&gt;
}

impl Parse for Args{
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        // parses a,b,c, or a,b,c where a,b and c are Indent
        let vars = Punctuated::&lt;Ident, Token![,]&gt;::parse_terminated(input)?;
        Ok(Args {
            vars: vars.into_iter().collect(),
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一旦我们实现了<code>Parse</code>特征，我们就可以使用<code>parse_macro_input</code>宏来解析元数据了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn trace_vars(metadata: TokenStream, input: TokenStream) -&gt; TokenStream {
    let input_fn = parse_macro_input!(input as ItemFn);
// using newly created struct Args
    let args= parse_macro_input!(metadata as Args);
    TokenStream::from(quote!{fn dummy(){}})
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，当变量的值变更时，我们将修改<code>input_fn</code>以添加<code>println!</code>。为了添加这个功能，我们需要过滤出赋值语句，并在该行之后插入一条打印语句。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Args {
    fn should_print_expr(&amp;self, e: &amp;Expr) -&gt; bool {
        match *e {
            Expr::Path(ref e) =&gt; {
 // variable shouldn't start wiht ::
                if e.path.leading_colon.is_some() {
                    false
// should be a single variable like `x=8` not n::x=0 
                } else if e.path.segments.len() != 1 {
                    false
                } else {
// get the first part
                    let first = e.path.segments.first().unwrap();
// check if the variable name is in the Args.vars hashset
                    self.vars.contains(&amp;first.ident) &amp;&amp; first.arguments.is_empty()
                }
            }
            _ =&gt; false,
        }
    }

// used for checking if to print let i=0 etc or not
    fn should_print_pat(&amp;self, p: &amp;Pat) -&gt; bool {
        match p {
// check if variable name is present in set
            Pat::Ident(ref p) =&gt; self.vars.contains(&amp;p.ident),
            _ =&gt; false,
        }
    }

// manipulate tree to insert print statement
    fn assign_and_print(&amp;mut self, left: Expr, op: &amp;dyn ToTokens, right: Expr) -&gt; Expr {
 // recurive call on right of the assigment statement
        let right = fold::fold_expr(self, right);
// returning manipulated sub-tree
        parse_quote!({
<span class="boring">            left #op #right;
</span>            println!(concat!(stringify!(#left), &quot; = {:?}&quot;), #left);
        })
    }

// manipulating let statement
    fn let_and_print(&amp;mut self, local: Local) -&gt; Stmt {
        let Local { pat, init, .. } = local;
        let init = self.fold_expr(*init.unwrap().1);
// get the variable name of assigned variable
        let ident = match pat {
            Pat::Ident(ref p) =&gt; &amp;p.ident,
            _ =&gt; unreachable!(),
        };
// new sub tree
        parse_quote! {
            let #pat = {
                #[allow(unused_mut)]
                let #pat = #init;
                println!(concat!(stringify!(#ident), &quot; = {:?}&quot;), #ident);
<span class="boring">                ident
</span>            };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的示例中，<code>quote</code>宏用于模版化并编写 Rust。<code>#</code>用来插入变量的值。</p>
<p>现在我们将会对<code>input_fn</code>进行深度优先搜索 (DFS) 并插入一条打印语句。<code>syn</code>提供了一个<code>Fold</code>特征，它可以为任何<code>Item</code>实现 DFS。我们只需要修改与我们要操作的标记类型相对应的特征方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Fold for Args {
    fn fold_expr(&amp;mut self, e: Expr) -&gt; Expr {
        match e {
// for changing assignment like a=5
            Expr::Assign(e) =&gt; {
// check should print
                if self.should_print_expr(&amp;e.left) {
                    self.assign_and_print(*e.left, &amp;e.eq_token, *e.right)
                } else {
// continue with default travesal using default methods
                    Expr::Assign(fold::fold_expr_assign(self, e))
                }
            }
// for changing assigment and operation like a+=1
            Expr::AssignOp(e) =&gt; {
// check should print
                if self.should_print_expr(&amp;e.left) {
                    self.assign_and_print(*e.left, &amp;e.op, *e.right)
                } else {
// continue with default behaviour
                    Expr::AssignOp(fold::fold_expr_assign_op(self, e))
                }
            }
// continue with default behaviour for rest of expressions
            _ =&gt; fold::fold_expr(self, e),
        }
    }

// for let statements like let d=9
    fn fold_stmt(&amp;mut self, s: Stmt) -&gt; Stmt {
        match s {
            Stmt::Local(s) =&gt; {
                if s.init.is_some() &amp;&amp; self.should_print_pat(&amp;s.pat) {
                    self.let_and_print(s)
                } else {
                    Stmt::Local(fold::fold_local(self, s))
                }
            }
            _ =&gt; fold::fold_stmt(self, s),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Fold</code>特征用于对<code>Item</code>进行 DFS。它可以让你对不同的 token 类型执行不同的行为。</p>
<p>现在我们可以使用<code>fold_item_fn</code>在解析的代码中注入打印语句。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn trace_var(args: TokenStream, input: TokenStream) -&gt; TokenStream {
// parse the input
    let input = parse_macro_input!(input as ItemFn);
// parse the arguments
    let mut args = parse_macro_input!(args as Args);
// create the ouput
    let output = args.fold_item_fn(input);
// return the TokenStream
    TokenStream::from(quote!(#output))
}
<span class="boring">}
</span></code></pre></pre>
<p>这个代码示例来自 <a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs">syn examples</a>，这是一个非常出色的学习过程宏的资源。</p>
<h3 id="自定义派生宏"><a class="header" href="#自定义派生宏">自定义派生宏</a></h3>
<p>在 Rust 中自定义派生宏可以自动实现特征。这些宏让你可以通过使用<code>#[derive(Trait)]</code>来实现该特征。</p>
<p><code>syn</code>对派生宏有出色的支持。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Trait)]
struct MyStruct{}
<span class="boring">}
</span></code></pre></pre>
<p>为了在 Rust 中编写自定义派生宏，我们可以使用<code>DeriveInput</code>来解析输入以派生宏。我们也可以使用<code>proc_macro_derive</code>宏来自定义派生宏。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(Trait)]
pub fn derive_trait(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let name = input.ident;

    let expanded = quote! {
        impl Trait for #name {
            fn print(&amp;self) -&gt; usize {
                println!(&quot;{}&quot;,&quot;hello from #name&quot;)
           }
        }
    };

    proc_macro::TokenStream::from(expanded)
}
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>syn</code>可以编写更多高级的派生宏。可以在 <a href="https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs">syn examples</a>中查看本示例。</p>
<h3 id="函数式宏"><a class="header" href="#函数式宏">函数式宏</a></h3>
<p>函数式宏和声明式宏很像，因为它们都通过<code>!</code>进行调用并且看起来都很像函数调用。它们对括号内的代码进行操作。</p>
<p>在 Rust 中，这是如何编写函数式宏的示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro]
pub fn a_proc_macro(_input: TokenStream) -&gt; TokenStream {
    TokenStream::from(quote!(
            fn anwser()-&gt;i32{
                5
            }
))
}
<span class="boring">}
</span></code></pre></pre>
<p>函数式宏不是在运行时执行的，而是在编译时执行的。它们可以用在 Rust 代码中的每一处地方。函数式宏同样接收一个<code>TokenStream</code>并返回一个<code>TokenStream</code>。</p>
<p>使用过程宏的好处包括：</p>
<ul>
<li>使用<code>span</code>更好的进行错误处理</li>
<li>更好的控制输出</li>
<li>社区提供的<code>syn</code>和<code>quote</code></li>
<li>比声明式宏更强大</li>
</ul>
<h2 id="结论-2"><a class="header" href="#结论-2">结论</a></h2>
<p>在 Rust 宏教程中，我们涉及了 Rust 中宏的所有基础概念，定义了声明式宏和过程宏，并学习了如何通过使用各种语法以及社区提供的类库来编写这两种类型的宏。我们还介绍了使用每一种 Rust 宏的优势。</p>
<h1 id="libp2p-教程使用-rust-构建-p2p-应用"><a class="header" href="#libp2p-教程使用-rust-构建-p2p-应用">libp2p 教程：使用 Rust 构建 p2p 应用</a></h1>
<p><a href="https://blog.logrocket.com/libp2p-tutorial-build-a-peer-to-peer-app-in-rust/">原文</a></p>
<p><img src="lang/rust/./img/macro_in_rust.webp" alt="p2p" /></p>
</br>
<p>在过去几年中，由于围绕区块链和加密货币 (cryptocurrencies) 的火热炒作 (hype)，去中心化应用的发展势头风光一时无两。人们对去中心化的兴趣日益浓厚的另一个因素是，人们越来越意识到在数据隐私与垄断 (monopolization) 方面，将大多数网络信息交到一小部分公司手中的弊端 (downside)。</p>
<p>不管怎样，除了 (aside from) 所有的加密与区块链技术外，最近在去中心化软件领域出现了一些非常有趣的进展。</p>
<p>值得关注的包括 <a href="https://ipfs.io/">IPFS</a>；全新的分布式编码平台 <a href="https://radicle.xyz/">Radicle</a>；去中心化社交网络 <a href="https://scuttlebutt.nz/">Scuttlebutt</a>；以及 <a href="https://fediverse.party/">Fediverse</a> 中的其他应用程序，如 <a href="https://joinmastodon.org/">Mastodon</a>。</p>
<p>在这篇教程中，我们将会向你展示如何使用 Rust 和 <a href="https://github.com/libp2p/rust-libp2p">libp2p</a> 来构建一个非常简单的 p2p 应用程序。其中 <a href="https://github.com/libp2p/rust-libp2p">libp2p</a> 是一个非常棒的库，对于不同语言，它处于不同的成熟阶段。</p>
<p>我们将使用简单的命令行界面构建一个烹饪食谱应用程序，使我们能够：</p>
<ul>
<li>创建食谱</li>
<li>发布食谱</li>
<li>列出本地食谱清单</li>
<li>列出我们在网络中发现的其他成员</li>
<li>列出指定成员发布的食谱</li>
<li>列出我们其他成员的所有食谱</li>
</ul>
<p>我们将通过 300 行左右的 Rust 代码来实现所有上述功能。让我们开始吧！</p>
<h2 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h2>
<p>为了继续以下内容，你需要的只是安装最新的 Rust 版本 (1.47+)。</p>
<p>首先，创建一个新的 Rust 工程：</p>
<pre><code class="language-console">cargo new rust-p2p-example
cd rust-p2p-example
</code></pre>
<p>然后，编辑<code>Cargo.toml</code>文件并添加你所需要的依赖：</p>
<pre><code class="language-toml">[dependencies]
libp2p = { version = &quot;0.31&quot;, features = [&quot;tcp-tokio&quot;, &quot;mdns-tokio&quot;] }
tokio = { version = &quot;0.3&quot;, features = [&quot;io-util&quot;, &quot;io-std&quot;, &quot;stream&quot;, &quot;macros&quot;, &quot;rt&quot;, &quot;rt-multi-thread&quot;, &quot;fs&quot;, &quot;time&quot;, &quot;sync&quot;] }
serde = {version = &quot;=1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
once_cell = &quot;1.5&quot;
log = &quot;0.4&quot;
pretty_env_logger = &quot;0.4&quot;
</code></pre>
<p>就像上面所说的一样，我们将会使用 <a href="https://github.com/libp2p/rust-libp2p">libp2p</a> 来开发 p2p 应用的网络部分。更值得一提的是，我们将使其与 tokio 异步运行时配合使用 (use it in concert with)。我们将使用 Serde 作为 Json 的序列化与反序列化器，以及其他用于日志打印以及初始化状态的帮助类库。</p>
<h2 id="什么是-libp2p"><a class="header" href="#什么是-libp2p">什么是 <code>libp2p</code>？</a></h2>
<p><a href="https://libp2p.io/">libp2p</a> 是一个专注于模块化构建 p2p 应用的协议簇。</p>
<p><a href="https://libp2p.io/">libp2p</a> 有多语言的实现类库，如：JavaScript，Go 以及 Rust。这些库都实现了相同的<code>libp2p</code>规范，因此，一个 Go 语言的<code>libp2p</code>客户端可以无缝的与 JavaScript 实现的另一个客户端进行交互，只要它们在选择的协议栈方面兼容即可。这些协议涵盖了从基本网络传输协议到安全层协议以及多路复用的广泛范围。</p>
<p>在本文中我们不会深入讲解<code>libp2p</code>的细节，但是如果你想要更深入的学习，<a href="https://docs.libp2p.io/concepts/">libp2p 官方文档</a>将很好地概述我们在此过程中会遇到的各种概念。</p>
<h2 id="libp2p-是如何工作的"><a class="header" href="#libp2p-是如何工作的"><code>libp2p</code> 是如何工作的</a></h2>
<p>为了查看<code>libp2p</code>的实际效果，我们将从定义一些需要的常量和类型开始构建食谱应用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const STORAGE_FILE_PATH: &amp;str = &quot;./recipes.json&quot;;

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;&gt;;

static KEYS: Lazy&lt;identity::Keypair&gt; = Lazy::new(|| identity::Keypair::generate_ed25519());
static PEER_ID: Lazy&lt;PeerId&gt; = Lazy::new(|| PeerId::from(KEYS.public()));
static TOPIC: Lazy&lt;Topic&gt; = Lazy::new(|| Topic::new(&quot;recipes&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>我们将在名为<code>recipes.json</code>的 JSON 文件中存储本地食谱，应用的可执行程序将与其放在同一目录下。我们将定义一个名为<code>Result</code>的帮助类型，它将有助于传播任意的错误。</p>
<p>然后，我们使用<code>once_cell::Lazy</code>来懒加载一些东西。首要的是，我们使用它来生成密钥对，并从公钥中派生所谓的 (so-called) <code>PeerId</code>。我们还创建了一个<code>Topic</code>，它是<code>libp2p</code>中另一个关键的概念。</p>
<p>这是什么意思呢？简而言之，在整个 p2p 网络中，<code>PeerId</code>是一个特定成员的唯一的标志符。我们从密钥对中派生它以确保它的唯一性。而且这个密钥对可以让我们与网络中其他的成员进行安全通信，确保没有人可以冒充 (impersonate) 我们。</p>
<p>另一方面，<code>Topic</code>是 Floodsub 中的概念，它实现了<code>libp2p</code>中的 <a href="https://github.com/libp2p/specs/tree/master/pubsub">pub/sub</a> 接口。<code>Topic</code>是一种我们可以订阅并发送消息的组件 - 举个例子，只监听 <code>pub/sub</code> 网络中流量的子集。</p>
<p>我们需要为食谱定义一些类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Recipes = Vec&lt;Recipe&gt;;

#[derive(Debug, Serialize, Deserialize)]
struct Recipe {
    id: usize,
    name: String,
    ingredients: String,
    instructions: String,
    public: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>以及一些我们想要发送的消息类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Deserialize)]
enum ListMode {
    ALL,
    One(String),
}

#[derive(Debug, Serialize, Deserialize)]
struct ListRequest {
    mode: ListMode,
}

#[derive(Debug, Serialize, Deserialize)]
struct ListResponse {
    mode: ListMode,
    data: Recipes,
    receiver: String,
}

enum EventType {
    Response(ListResponse),
    Input(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>这个食谱相当简单。它有一个 ID，一个名称，一些配料 (ingredient) 以及烹饪的方法。而且，我们还添加了一个<code>public</code>标记以便区分我们想要分享的食谱以及想要保留的食谱。</p>
<p>正如开头提到的，这里有两种方式可以拉到其他成员的食谱清单：拉取全部获取某一个成员的食谱清单，通过<code>ListMode</code>来表示。</p>
<p><code>ListRequest</code>和<code>ListResponse</code>仅仅是<code>ListMode</code>的封装，以及使用它们的发送时间。</p>
<p><code>EventType</code>枚举用来区分来自其他成员的响应以及我们自己的输入。稍后我们将介绍为什么这种差异很重要。</p>
<h2 id="创建一个libp2p客户端"><a class="header" href="#创建一个libp2p客户端">创建一个<code>libp2p</code>客户端</a></h2>
<p>让我们开始编写 main 函数，以便在 p2p 网络中创建一个成员。</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    pretty_env_logger::init();

    info!(&quot;Peer Id: {}&quot;, PEER_ID.clone());
    let (response_sender, mut response_rcv) = mpsc::unbounded_channel();

    let auth_keys = Keypair::&lt;X25519Spec&gt;::new()
        .into_authentic(&amp;KEYS)
        .expect(&quot;can create auth keys&quot;);
</code></pre></pre>
<p>我们初始化日志并创建了一个异步<code>channel</code>来与应用的其他部分进行通信。稍后，我们将使用此<code>channel</code>将来自<code>libp2p</code>网络栈的响应发送回我们的应用程序以进行处理。</p>
<p>另外，我们为 <a href="https://noiseprotocol.org/">Noise</a> 加密协议创建了一些授权密钥，这些密钥将用于保护网络中的流量。为了达到这个目的，我们创建了一个新的密钥对，然后使用<code>into_authentic</code>函数通过身份密钥对其进行签名。</p>
<p>下一步很重要并涉及<code>libp2p</code>的核心概念：创建所谓的<code>Transport</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let transp = TokioTcpConfig::new()
    .upgrade(upgrade::Version::V1)
    .authenticate(NoiseConfig::xx(auth_keys).into_authenticated())
    .multiplex(mplex::MplexConfig::new())
    .boxed();
<span class="boring">}
</span></code></pre></pre>
<p>transport 是一个面向连接的与其他成员进行通信的网络协议蔟。在同一个应用程序中可能也会使用多个 transport - 举个例子，TCP/IP，Websocket 或者 UDP 同时针对不同的用例进行通信。</p>
<p>在本例中，我们将使用 Tokio 的异步TCP 作为基础。一旦 TCP 连接建立，为了通信安全，我们将使用<code>Noise</code>对其进行<code>upgrade</code>操作。一个基于 web 的示例是在 HTTP 之上使用 TLS 创建安全连接。</p>
<p>我们将使用<code>NoiseConfig::xx</code>的握手模式，这是唯一一个可以与其他<code>libp2p</code>应用交互的选项。</p>
<p><code>libp2p</code>的好处是，我们可以编写一个 Rust 客户端，另一个编写 JavaScript 客户端，只要在两个语言版本的库中都实现了(相同的)协议，它们就可以轻松地进行通信。</p>
<p>最后，我们还对 transport 进行<a href="https://docs.libp2p.io/concepts/stream-multiplexing/">多路复用</a>，它可以让我们在相同的 transport 上复用多个 substream 或者连接。</p>
<p>理论性的东西有点多！但是所有这些都可以在 <a href="https://docs.libp2p.io/">libp2p 文档</a>中找到。这只是创建 p2p transport 众多方法中的其中一种。</p>
<p>下一个概念是<code>NetworkBehaviour</code>。这实际上是<code>libp2p</code>中定义网络和所有成员逻辑的部分 - 举个例子，当接收到事件应该做什么以及应该发送什么事件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut behaviour = RecipeBehaviour {
    floodsub: Floodsub::new(PEER_ID.clone()),
    mdns: TokioMdns::new().expect(&quot;can create mdns&quot;),
    response_sender,
};

behaviour.floodsub.subscribe(TOPIC.clone());
<span class="boring">}
</span></code></pre></pre>
<p>在这里，正如上面所提及的，我们将使用<code>FloodSub</code>协议处理这些事件。我们也使用 <a href="https://tools.ietf.org/html/rfc6762">mDNS</a>，这是一种在本地网络中发现其他成员的协议。我们还会在这放置 channel 中的<code>sender</code>，以便可以使用它将事件传播到应用程序的主要模块中。</p>
<p>现在，我们已经从 behavior 中订阅了在之前创建的<code>FloodSub</code>主题，这意味着我们将接收并可以发送该主题的事件。</p>
<p>我们几乎已经完成了<code>libp2p</code>的设置。我们需要了解的最后一个概念是<code>Swarm</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut swarm = SwarmBuilder::new(transp, behaviour, PEER_ID.clone())
    .executor(Box::new(|fut| {
        tokio::spawn(fut);
    }))
    .build();
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/libp2p/latest/libp2p/index.html#swarm">Swarm</a> 管理使用 transport 创建的连接，并执行我们创建的网络行为(如：触发或接收事件)，并为我们提供一种从外部获取它们的方法。</p>
<p>我们使用 transport，behavior和 PEER_ID 创建了<code>Swarm</code>。<code>执行器</code>告诉<code>Swarm</code>使用<code>Tokio</code>运行时在内部运行，但是我们也可以在这里使用其他的异步运行时。</p>
<p>剩下的唯一一件事就是启动我们的<code>Swarm</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Swarm::listen_on(
    &amp;mut swarm,
    &quot;/ip4/0.0.0.0/tcp/0&quot;
    .parse()
    .expect(&quot;can get a local socket&quot;))
    .expect(&quot;swarm can be started&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>与 TCP 服务器类似，我们仅使用本地 IP 调用<code>listen_on</code>，让操作系统为我们确定端口。这将以之前的所有设置来启动<code>Swarm</code>，但实际上我们还没有定义任何逻辑。</p>
<p>让我们从处理用户输入开始。</p>
<h2 id="在libp2p中处理用户输入"><a class="header" href="#在libp2p中处理用户输入">在<code>libp2p</code>中处理用户输入</a></h2>
<p>对于用户输入，我们仅仅依赖 STDIN。因此在调用<code>Swarm::listen_on</code>之前，我们将会添加：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stdin = tokio::io::BufReader::new(tokio::io::stdin()).lines();
<span class="boring">}
</span></code></pre></pre>
<p>它在 STDIN 之上定义了一个异步 reader，它可以逐行读取字节流。如果我们按下 enter 键，这里将会传入一个新的消息。</p>
<p>下一步我们将创建事件循环，它将会监听来自 STDIN，<code>Swarm</code>以及在上面定义的响应 channel 中的事件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let evt = {
        tokio::select! {
            line = stdin.next_line() =&gt; Some(EventType::Input(line.expect(&quot;can get line&quot;).expect(&quot;can read line from stdin&quot;))),
            event = swarm.next() =&gt; {
                info!(&quot;Unhandled Swarm Event: {:?}&quot;, event);
                None
            },
            response = response_rcv.recv() =&gt; Some(EventType::Response(response.expect(&quot;response exists&quot;))),
        }
    };
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用 Tokio 的<code>select</code>宏来等待几种异步流程，并处理第一个完成的流程。对于<code>Swarm</code>事件我们不做任何处理；这些事件都在之后将看到的<code>RecipeBehaviour</code>中进行处理，但我们仍需要调用<code>swarm.next()</code>以驱动<code>Swarm</code>转发。</p>
<p>让我们添加一些事件处理逻辑来取代上面的<code>...</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(event) = evt {
    match event {
        EventType::Response(resp) =&gt; {
            ...
        }
        EventType::Input(line) =&gt; match line.as_str() {
            &quot;ls p&quot; =&gt; handle_list_peers(&amp;mut swarm).await,
            cmd if cmd.starts_with(&quot;ls r&quot;) =&gt; handle_list_recipes(cmd, &amp;mut swarm).await,
            cmd if cmd.starts_with(&quot;create r&quot;) =&gt; handle_create_recipe(cmd).await,
            cmd if cmd.starts_with(&quot;publish r&quot;) =&gt; handle_publish_recipe(cmd).await,
            _ =&gt; error!(&quot;unknown command&quot;),
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果 evt 是一个事件，我们将会对其进行匹配并判断是否是<code>Response</code>还是<code>Input</code>事件。我们现在先看下<code>Input</code>事件。</p>
<ul>
<li><code>ls p</code> 列出所有的已知成员</li>
<li><code>ls r</code> 列出所有的本地食谱</li>
<li><code>ls r {peerId}</code> 列出指定成员发布的食谱</li>
<li><code>ls r all</code> 列出所有已知成员发布的食谱</li>
<li><code>publish r {recipeId}</code> 发布指定的食谱</li>
<li><code>create r {recipeName}|{recipeIngredients}|{recipeInstructions}</code> 通过给定的数据以及自增的 ID 创建一个新的食谱</li>
</ul>
<p>在这里，列出成员的所有食谱意味着要向所有成员发送一个关于食谱的请求并等待它们的响应，然后展示结果。在 p2p 网络中，这可能要花一点事件因为某些成员可能会在地球的另一端，我们甚至不知道它们是否会对我们进行响应。这和发送一个请求到 HTTP 服务器不一样，举个例子：</p>
<p>先看下列出成员清单的逻辑：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_list_peers(swarm: &amp;mut Swarm&lt;RecipeBehaviour&gt;) {
    info!(&quot;Discovered Peers:&quot;);
    let nodes = swarm.mdns.discovered_nodes();
    let mut unique_peers = HashSet::new();
    for peer in nodes {
        unique_peers.insert(peer);
    }
    unique_peers.iter().for_each(|p| info!(&quot;{}&quot;, p));
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们可以使用<code>mDNS</code>来发现所有的节点，遍历并展示它们。</p>
<p>接下来，让我们创建并发布食谱，在处理 (tackle) 列表命令之前：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_create_recipe(cmd: &amp;str) {
    if let Some(rest) = cmd.strip_prefix(&quot;create r&quot;) {
        let elements: Vec&lt;&amp;str&gt; = rest.split(&quot;|&quot;).collect();
        if elements.len() &lt; 3 {
            info!(&quot;too few arguments - Format: name|ingredients|instructions&quot;);
        } else {
            let name = elements.get(0).expect(&quot;name is there&quot;);
            let ingredients = elements.get(1).expect(&quot;ingredients is there&quot;);
            let instructions = elements.get(2).expect(&quot;instructions is there&quot;);
            if let Err(e) = create_new_recipe(name, ingredients, instructions).await {
                error!(&quot;error creating recipe: {}&quot;, e);
            };
        }
    }
}

async fn handle_publish_recipe(cmd: &amp;str) {
    if let Some(rest) = cmd.strip_prefix(&quot;publish r&quot;) {
        match rest.trim().parse::&lt;usize&gt;() {
            Ok(id) =&gt; {
                if let Err(e) = publish_recipe(id).await {
                    info!(&quot;error publishing recipe with id {}, {}&quot;, id, e)
                } else {
                    info!(&quot;Published Recipe with id: {}&quot;, id);
                }
            }
            Err(e) =&gt; error!(&quot;invalid id: {}, {}&quot;, rest.trim(), e),
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这两种情况下，我们都需要解析字符串以获取被<code>|</code>分隔的数据，如果是<code>public</code>，则需要解析给定的食谱 id，如果给定的输入不合法，则打印一下错误日志。</p>
<p>对于<code>create</code>，我们通过给定的数据调用<code>create_new_recipe</code>函数。让我们查看一下与食谱的本地 JSON 存储交互所需的所有辅助函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_new_recipe(name: &amp;str, ingredients: &amp;str, instructions: &amp;str) -&gt; Result&lt;()&gt; {
    let mut local_recipes = read_local_recipes().await?;
    let new_id = match local_recipes.iter().max_by_key(|r| r.id) {
        Some(v) =&gt; v.id + 1,
        None =&gt; 0,
    };
    local_recipes.push(Recipe {
        id: new_id,
        name: name.to_owned(),
        ingredients: ingredients.to_owned(),
        instructions: instructions.to_owned(),
        public: false,
    });
    write_local_recipes(&amp;local_recipes).await?;

    info!(&quot;Created recipe:&quot;);
    info!(&quot;Name: {}&quot;, name);
    info!(&quot;Ingredients: {}&quot;, ingredients);
    info!(&quot;Instructions:: {}&quot;, instructions);

    Ok(())
}

async fn publish_recipe(id: usize) -&gt; Result&lt;()&gt; {
    let mut local_recipes = read_local_recipes().await?;
    local_recipes
        .iter_mut()
        .filter(|r| r.id == id)
        .for_each(|r| r.public = true);
    write_local_recipes(&amp;local_recipes).await?;
    Ok(())
}

async fn read_local_recipes() -&gt; Result&lt;Recipes&gt; {
    let content = fs::read(STORAGE_FILE_PATH).await?;
    let result = serde_json::from_slice(&amp;content)?;
    Ok(result)
}

async fn write_local_recipes(recipes: &amp;Recipes) -&gt; Result&lt;()&gt; {
    let json = serde_json::to_string(&amp;recipes)?;
    fs::write(STORAGE_FILE_PATH, &amp;json).await?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>最基本的构造代码块是<code>read_local_recipes</code>以及<code>write_local_recipes</code>，它们仅从存储中读取并反序列化食谱，以及序列化食谱并将其写入本地存储。</p>
<p><code>publish_recipe</code>函数从文件中获取所有的食谱，通过给定的 ID 来查询食谱，并将它的<code>public</code>标记设置为 true。</p>
<p>当创建一个食谱时，我们也会从文件中读取所有的食谱，并在最后添加新的食谱，然后将全部数据写回并覆盖原文件。这不是很高效，但是它足够简单且可行。</p>
<h2 id="使用libp2p发送消息"><a class="header" href="#使用libp2p发送消息">使用<code>libp2p</code>发送消息</a></h2>
<p>接下来让我们看下<code>list</code>命令，并探索如何将消息发送给其他成员。</p>
<p>在<code>list</code>命令中，这里可能有三种情况：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_list_recipes(cmd: &amp;str, swarm: &amp;mut Swarm&lt;RecipeBehaviour&gt;) {
    let rest = cmd.strip_prefix(&quot;ls r &quot;);
    match rest {
        Some(&quot;all&quot;) =&gt; {
            let req = ListRequest {
                mode: ListMode::ALL,
            };
            let json = serde_json::to_string(&amp;req).expect(&quot;can jsonify request&quot;);
            swarm.floodsub.publish(TOPIC.clone(), json.as_bytes());
        }
        Some(recipes_peer_id) =&gt; {
            let req = ListRequest {
                mode: ListMode::One(recipes_peer_id.to_owned()),
            };
            let json = serde_json::to_string(&amp;req).expect(&quot;can jsonify request&quot;);
            swarm.floodsub.publish(TOPIC.clone(), json.as_bytes());
        }
        None =&gt; {
            match read_local_recipes().await {
                Ok(v) =&gt; {
                    info!(&quot;Local Recipes ({})&quot;, v.len());
                    v.iter().for_each(|r| info!(&quot;{:?}&quot;, r));
                }
                Err(e) =&gt; error!(&quot;error fetching local recipes: {}&quot;, e),
            };
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>我们解析输入的命令，剥离 (strip) <code>ls r</code>部分，并检查是否还有剩余的部分命令。如果没有，我们仅读取本地的食谱并使用在之前定义的辅助函数将它们打印出来。</p>
<p>如果我们遇到了<code>all</code>关键字，我们将创建一个带有<code>ListMode::ALL</code>集合的<code>ListRequest</code>，将其序列化成 JSON，并在<code>Swarm</code>中使用<code>FloodSub</code>实例将其发布到之前提到的<code>主题</code>中。</p>
<p>如果我们在命令中遇到成员 ID，我们将仅发送带有该成员 ID 的<code>ListMode::One</code>。我们可以检查它是否是一个合法的成员 ID，或者是否是一个我们已经发现的成员 ID，但是为了保持简单：如果其上没有任何监听，则不会做任何处理。</p>
<p>这就是我们要向网络中发送消息所需要的一切。现在的问题是，这些消息会发生什么？它们在哪里被处理？</p>
<p>在本例中的 p2p 应用中，请记住我们既是事件的<code>Sender</code>也是事件的<code>Receiver</code>，因此在我们的实现中，需要处理输入以及响应事件。</p>
<h2 id="使用libp2p对消息进行响应"><a class="header" href="#使用libp2p对消息进行响应">使用<code>libp2p</code>对消息进行响应</a></h2>
<p>我们的<code>RecipeBehaviour</code>终于在这里出现了。先对其进行定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NetworkBehaviour)]
struct RecipeBehaviour {
    floodsub: Floodsub,
    mdns: TokioMdns,
    #[behaviour(ignore)]
    response_sender: mpsc::UnboundedSender&lt;ListResponse&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>behavior 本身仅仅是一个结构体，但是我们使用了<code>libp2p</code>中的<code>NetworkBehaviour</code>派生宏，因此我们不需要手动实现特征的所有函数。</p>
<p>这个派生宏为结构体中所有未声明<code>behaviour(ignore)</code>的成员实现了 <a href="https://docs.rs/libp2p/latest/libp2p/swarm/trait.NetworkBehaviour.html">NetworkBehaviour</a> 特征。在这里我们忽略了 channel，因为它与我们的 behavior 没有直接的关系。</p>
<p>接下来就是为<code>FloodsubEvent</code>和<code>MdnsEvent</code>实现<code>jnject_event</code>函数。</p>
<p>先从<code>mDNS</code>开始：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NetworkBehaviourEventProcess&lt;MdnsEvent&gt; for RecipeBehaviour {
    fn inject_event(&amp;mut self, event: MdnsEvent) {
        match event {
            MdnsEvent::Discovered(discovered_list) =&gt; {
                for (peer, _addr) in discovered_list {
                    self.floodsub.add_node_to_partial_view(peer);
                }
            }
            MdnsEvent::Expired(expired_list) =&gt; {
                for (peer, _addr) in expired_list {
                    if !self.mdns.has_node(&amp;peer) {
                        self.floodsub.remove_node_from_partial_view(&amp;peer);
                    }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当这个处理器接收到一个事件时，将会调用<code>inject_event</code>函数。对于<code>mDNS</code>来说，这里只有两种事件<code>Discovered</code>和<code>Expired</code>，它们将在当我们在网络中发现一个新的成员或者一个成员离开时被触发。在这两种情况下，我们都可以在<code>FloodSub</code>的部分视图中将其添加或移除，该视图是要将消息传播到的节点列表。</p>
<p>对于 pub/sub 事件来说，<code>inject_event</code>有点复杂。我们需要对传入的<code>ListRequest</code>和<code>ListResponse</code>有效负载做出反应。如果我们发送了<code>ListRequest</code>，成员将会接收到一个请求，该请求会拉取它本地发布的食谱，并将其返回。</p>
<p>将它们返回给请求成员的唯一方式就是在网络中发布它们的食谱。由于 pub/sub 是我们唯一的机制，因此我们需要对传入的请求以及响应做出反应。</p>
<p>让我们来看它是如何工作的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NetworkBehaviourEventProcess&lt;FloodsubEvent&gt; for RecipeBehaviour {
    fn inject_event(&amp;mut self, event: FloodsubEvent) {
        match event {
            FloodsubEvent::Message(msg) =&gt; {
                if let Ok(resp) = serde_json::from_slice::&lt;ListResponse&gt;(&amp;msg.data) {
                    if resp.receiver == PEER_ID.to_string() {
                        info!(&quot;Response from {}:&quot;, msg.source);
                        resp.data.iter().for_each(|r| info!(&quot;{:?}&quot;, r));
                    }
                } else if let Ok(req) = serde_json::from_slice::&lt;ListRequest&gt;(&amp;msg.data) {
                    match req.mode {
                        ListMode::ALL =&gt; {
                            info!(&quot;Received ALL req: {:?} from {:?}&quot;, req, msg.source);
                            respond_with_public_recipes(
                                self.response_sender.clone(),
                                msg.source.to_string(),
                            );
                        }
                        ListMode::One(ref peer_id) =&gt; {
                            if peer_id == &amp;PEER_ID.to_string() {
                                info!(&quot;Received req: {:?} from {:?}&quot;, req, msg.source);
                                respond_with_public_recipes(
                                    self.response_sender.clone(),
                                    msg.source.to_string(),
                                );
                            }
                        }
                    }
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们匹配了传入的消息，并试图将其序列化成一个请求或响应。当我们接收到一个响应时，我们仅将带有调用者成员 ID 的响应打印出来，成员 ID 可以通过<code>msg.source</code>获取。当我们接收到一个请求时，我们需要区分<code>ALL</code>和<code>One</code>这两种情况。</p>
<p>对于<code>One</code>，我们检查给定的成员 ID 是否和我们一样 - 该请求其实是针对我们的。如果是，我们将返回发布的食谱，我们同样对<code>ALL</code>这样进行响应。</p>
<p>在这两种情况下，我们都将调用<code>respond_with_public_recipes</code>辅助函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn respond_with_public_recipes(sender: mpsc::UnboundedSender&lt;ListResponse&gt;, receiver: String) {
    tokio::spawn(async move {
        match read_local_recipes().await {
            Ok(recipes) =&gt; {
                let resp = ListResponse {
                    mode: ListMode::ALL,
                    receiver,
                    data: recipes.into_iter().filter(|r| r.public).collect(),
                };
                if let Err(e) = sender.send(resp) {
                    error!(&quot;error sending response via channel, {}&quot;, e);
                }
            }
            Err(e) =&gt; error!(&quot;error fetching local recipes to answer ALL request, {}&quot;, e),
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个辅助函数中，我们使用 Tokio 生成器异步执行 Future，该 Future 将读取所有的本地食谱，并以此创建一个<code>ListResponse</code>，然后通过<code>channel_sender</code>将数据发送给我们的事件循环，在事件循环中，我们将会这样处理：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>EventType::Response(resp) =&gt; {
    let json = serde_json::to_string(&amp;resp).expect(&quot;can jsonify response&quot;);
    swarm.floodsub.publish(TOPIC.clone(), json.as_bytes());
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们注意到“内部”通过<code>Response</code>事件发送，我们将其序列化成 JSON 格式并将其发送到网络中。</p>
<h2 id="使用libp2p进行测试"><a class="header" href="#使用libp2p进行测试">使用<code>libp2p</code>进行测试</a></h2>
<p>上面那些是实现过程，现在让我们对其进行测试。</p>
<p>为了检查我们的实现是否工作，让我们在多个命令行中使用以下命令启动应用程序：</p>
<pre><code class="language-console">RUST_LOG=info cargo run
</code></pre>
<p>请注意，应用程序需要一个同级目录下的<code>recipes.json</code>文件。</p>
<p>当应用启动时，我们获取以下日志，并打印出成员 ID：</p>
<pre><code class="language-console">INFO  rust_peer_to_peer_example &gt; Peer Id: 12D3KooWDc1FDabQzpntvZRWeDZUL351gJRy3F4E8VN5Gx2pBCU2
</code></pre>
<p>现在，我们需要输入 enter 来启动事件循环。</p>
<p>输入<code>ls p</code>之后，我们获取到了发现的成员列表：</p>
<pre><code class="language-console">ls p
 INFO  rust_peer_to_peer_example &gt; Discovered Peers:
 INFO  rust_peer_to_peer_example &gt; 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG
 INFO  rust_peer_to_peer_example &gt; 12D3KooWLGN85pv5XTDALGX5M6tRgQtUGMWXWasWQD6oJjMcEENA
</code></pre>
<p>使用 <code>ls r</code>，我们将获取到本地食谱：</p>
<pre><code class="language-console">ls r
 INFO  rust_peer_to_peer_example &gt; Local Recipes (3)
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 0, name: &quot; Coffee&quot;, ingredients: &quot;Coffee&quot;, instructions: &quot;Make Coffee&quot;, public: true }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 1, name: &quot; Tea&quot;, ingredients: &quot;Tea, Water&quot;, instructions: &quot;Boil Water, add tea&quot;, public: false }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 2, name: &quot; Carrot Cake&quot;, ingredients: &quot;Carrots, Cake&quot;, instructions: &quot;Make Carrot Cake&quot;, public: true }
</code></pre>
<p>调用<code>ls r all</code>将向其他所有成员发送一个请求，并返回它们的食谱：</p>
<pre><code class="language-console">ls r all
 INFO  rust_peer_to_peer_example &gt; Response from 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG:
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 0, name: &quot; Coffee&quot;, ingredients: &quot;Coffee&quot;, instructions: &quot;Make Coffee&quot;, public: true }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 2, name: &quot; Carrot Cake&quot;, ingredients: &quot;Carrots, Cake&quot;, instructions: &quot;Make Carrot Cake&quot;, public: true }
</code></pre>
<p>如果我们使用带有成员 ID 的<code>ls r</code>命令，将会发生同样的事情：</p>
<pre><code class="language-console">ls r 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG
 INFO  rust_peer_to_peer_example &gt; Response from 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG:
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 0, name: &quot; Coffee&quot;, ingredients: &quot;Coffee&quot;, instructions: &quot;Make Coffee&quot;, public: true }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 2, name: &quot; Carrot Cake&quot;, ingredients: &quot;Carrots, Cake&quot;, instructions: &quot;Make Carrot Cake&quot;, public: true }
</code></pre>
<p>它确实有用！你也可以在同样的网络中使用更多的客户端进行尝试。</p>
<p>你可以在 <a href="https://github.com/zupzup/rust-peer-to-peer-example">Github</a> 中获取本教程的完整代码示例。</p>
<h2 id="结论-3"><a class="header" href="#结论-3">结论</a></h2>
<p>在本文中我们介绍了如何使用 Rust 以及<code>libp2p</code>构建一个简单的，去中心化的应用程序。</p>
<p>如果你来自 web 后端，那么你对许多的网络概念可能都很熟悉，但是构建 p2p 应用程序仍然需要一种根本不同的设计和构建方法。</p>
<p><code>libp2p</code>类库已经十分成熟，并且由于 Rust 在加密领域十分流行，因此出现了一个新兴的 (emerge)，丰富的生态系统，用于构建功能强大的去中心化应用程序。</p>
<h1 id="转rust-的-pin-和-unpin"><a class="header" href="#转rust-的-pin-和-unpin">「转」Rust 的 Pin 和 Unpin</a></h1>
<blockquote>
<p>转载：<a href="https://folyd.com/blog/rust-pin-unpin/">Rust 的 Pin 和 Unpin</a></p>
</blockquote>
</br>
<p>2019年2月28号，Rust 1.33版发布，增加了新的pinning API，主要包括这几个：</p>
<ul>
<li><code>std::pin::Pin</code></li>
<li><code>std::marker::Unpin</code></li>
<li><code>std::marker::PhantomPinned</code></li>
<li><code>impl !Unpin for T</code></li>
</ul>
<p>刚开始接触这些概念的时候感觉特别绕，有点难理解透彻。网上也有不少讲<code>Pin</code>和<code>Unpin</code>的文章，但总感觉讲得不是特别清楚。直接去看 <a href="https://doc.rust-lang.org/std/pin/index.html">std::pin 模块</a>的文档理解起来也挺有难度的。所以这篇文章我将尝试由浅入深的梳理一下<code>Pin</code>和<code>Unpin</code>，希望能帮助大家理解这些概念。</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p>我们先看一下<code>Pin</code>官方文档上的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its
/// value in place, preventing the value referenced by that pointer from being moved
/// unless it implements [`Unpin`].
#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[lang = &quot;pin&quot;]
#[fundamental]
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin&lt;P&gt; {
    pointer: P,
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我先来从宏观层面解读一下。<code>Pin</code>是一个这样的智能指针，他内部包裹了另外一个指针 P，并且只要 P 指针指向的内容（我们称为 T ）没有实现<code>Unpin</code>，则可以保证 T 永远不会被移动 (move)。<code>Pin</code>这个单词也很形象的表示<code>Pin</code>就像钉子一样可以把T钉住。所以<code>Pin</code>一般来说用<code>Pin&lt;P&lt;T&gt;&gt;</code>这种方式表示 (P 是 Pointer 的缩写，T 是 Type 的缩写)。这个定义初看有点绕，我们来划几个重点：</p>
<ul>
<li><code>Pin</code>自身是一个智能指针。为什么呢？因为他 impl 了<code>Deref</code>和<code>DerefMut</code>。</li>
<li><code>Pin</code>包裹的内容只能是指针，不能是其他普通类型。比如<code>Pin&lt;u32&gt;</code>就没有意义。</li>
<li><code>Pin</code>具有“钉住” T 不能移动的功能，这个功能是否生效取决于 T 是否 impl <code>Unpin</code>。简单的说，如果 T 实现了<code>Unpin</code>，<code>Pin</code>的“钉住”功能完全失效了，这时候的<code>Pin&lt;P&lt;T&gt;&gt;</code>就等价于<code>P&lt;T&gt;</code>。</li>
<li><code>Unpin</code>是一个<code>auto trait</code>，编译器默认会给所有类型实现<code>Unpin</code>。唯独有几个例外，他们实现的是<code>!Unpin</code>。这几个例外是<code>PhantomPinned</code>，编译器为<code>async/await desugar</code>之后生成的impl <code>Future</code>的结构体。</li>
<li>所以<code>Pin&lt;P&lt;T&gt;&gt;</code>默认情况下的“钉住”功能是不生效的，只针对上面说的这几个impl <code>!Unpin</code>的情况生效。</li>
</ul>
<p>看了这几条可能还有点懵，没关系，我们开始逐条剖析。首先要搞清楚的是到底什么是<code>move</code>以及为什么有些情况我们要防止<code>move</code>发生？</p>
<h2 id="到底什么是move"><a class="header" href="#到底什么是move">到底什么是move？</a></h2>
<p>根据官方定义：所有权转移的这个过程就是<code>move</code>。我们先看一个大家都非常熟悉的例子：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let mut s1 = String::from(&quot;Hello&quot;);
  let s2 = s1; // s1的所有权转移给了s2，这里发生了move
  // let s3 = s1; // s1的所有权以及转移走了，不能再move，否则会报错：error[E0382]: use of moved value: `s1`
}
</code></pre></pre>
<p>基本概念这里不多解释了，我们需要搞明白的是<code>let s2 = s1;</code>这一行到底发生了什么事情。</p>
<p><img src="lang/rust/./img/trpl04-04.svg" alt="trpl04-04" /></p>
<p>借用了 TRPL 书上的这张图。<code>s1</code>和<code>s2</code>两个变量都是在栈上分配内存，字符串 “Hello” 是在堆上分配内存，其中<code>ptr</code>字段就是指向该字符串的指针。<code>move</code>发生的时候编译器会在栈上开辟一块新内存<code>s2</code>，然后原封不动把<code>s1</code>栈上的内容拷贝到<code>s2</code>，随即立马让原<code>s1</code>的内存失效。</p>
<p>再看一个 move 的列子：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from(&quot;xxx&quot;);
    let mut y = String::from(&quot;yyy&quot;);

    std::mem::swap(&amp;mut x, &amp;mut y);

    assert_eq!(&quot;yyy&quot;, &amp;x);
    assert_eq!(&quot;xxx&quot;, &amp;y);
}
</code></pre></pre>
<p>我们通过<code>std::mem::swap()</code>方法交换了两个可变借用<code>&amp;mut</code>的内容，这里也发生了<code>move</code>。</p>
<p>像这两种<code>move</code>在 Rust 里面很稀松平常，使用起来丝毫不会引发什么问题。那到底是什么情况需要防止<code>move</code>的发生呢？</p>
<p>还真有，那就是自引用结构体！</p>
<h2 id="自引用结构体的-move"><a class="header" href="#自引用结构体的-move">自引用结构体的 move</a></h2>
<p>自引用结构体 (Self-Referential Structs) 是一个这个样的结构体，它内部某个成员是对另外一个成员的引用。比如这样：</p>
<pre><pre class="playground"><code class="language-rust">struct Test&lt;'a&gt; {
    a: String,
    b: &amp;'a String,
}

fn main() {
    let a = String::from(&quot;Hello&quot;);
    let _test = Test { a, b: &amp;a };
//    let _test = Test { a, b: &amp;a };
//  |                        -     ^^ value borrowed here after move
//  |                        |
//  |                        value moved here
}
</code></pre></pre>
<p>但事实上我们没办法通过<code>Safe Rust</code>构造一个像 Test 这样的自引用结构体，Rust 目前对自引用结构体支持还很不完善。只能变通一下使用指针：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String, // 改成指针
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.a;
        self.b = self_ref;
    }

    fn a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(&amp;self) -&gt; &amp;String {
        unsafe {&amp;*(self.b)}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们来试一下这个自引用结构体的 move：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    // 使用swap()函数交换两者，这里发生了move
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    test1.a = &quot;I've totally changed now!&quot;.to_string();
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());
}
</code></pre></pre>
<p>这是打印结果：</p>
<pre><code class="language-console">a: test1, b: test1
a: test1, b: I've totally changed now!
</code></pre>
<p>有没有发现，出问题了！问题出在哪？原因是 Test 结构体中的字段 b 是一个指向字段 a 的指针，它在栈上存的是字段 a 的地址。通过<code>swap()</code>函数交换两个 Test 结构体之后，字段 a, b 分别移动到对方的内存区域上，但是 a 和 b 本身的内容没有变。也就是指针 b 依然指向的是原来的地址，但是这个地址现在已经属于另外一个结构体了！这不仅不是自引用结构体了，更可怕的是这个指针可能导致更危险的问题，这是 Rust 决不允许出现的！👇下面这张图可以帮助理解：</p>
<p><img src="lang/rust/./img/swap_problem.jpeg" alt="swap_problem" /></p>
<p>更关键的是 Rust 的<code>Generator</code>和<code>async/await</code>这一套都是基于自引用结构体实现的。如果不能从根源上解决这个问题，Rust 号称的<code>Memory Safe</code>的根基就完全动摇了。</p>
<blockquote>
<p>更多关于async/await的原理，强烈推荐阅读这两本书：</p>
<ul>
<li>https://rust-lang.github.io/async-book</li>
<li>https://cfsamson.github.io/books-futures-explained</li>
</ul>
</blockquote>
<p>所以我们来找一下导致这个问题的根源，然后想办法从根源上解决它！</p>
<h2 id="根源是什么"><a class="header" href="#根源是什么">根源是什么？</a></h2>
<p>我们发现上面的例子最关键的一行代码是<code>std::mem::swap(&amp;mut test1, &amp;mut test2)</code>，就是它导致了我们自引用结构体失效引发了内存安全问题。所以我们是不是只要避免这个<code>swap()</code>函数应用到我们自引用结构体上就行？可是怎么去避免呢？我们来看一下<code>swap()</code>方法的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T) {
    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the
    // constraints on `ptr::swap_nonoverlapping_one`
    unsafe {
        ptr::swap_nonoverlapping_one(x, y);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它的参数要求是可变借用<code>&amp;mut</code>，所以只要我们想办法让<code>Safe Rust</code>下不暴露可变借用即可！</p>
<p>还是以 Test 为例，它自身没办法限制自己不能可变借用，因为我们直接用<code>&amp;mut Test{...}</code>就可以轻松拿到。那从标准库中去找找，<code>Box&lt;T&gt;</code>呢？先不考虑它性能问题，我们把结构体 T 包裹在<code>Box</code>中，看<code>Box</code>能不能保证不暴露<code>&amp;mut T</code>出去。看一下 API 文档，很遗憾不能。<code>Box::leak()</code>返回值就是&amp;mut T，更甚者<code>Box</code> impl 了<code>DerefMut</code>，就算不用<code>leak()</code>我们也可以通过<code>* &amp;mut Box&lt;T&gt;</code>解引用轻松拿到<code>&amp;mut T</code>！</p>
<p>不用找了，在<code>Pin</code>之前的标准库中确实没有这样的 API 能够防止在<code>Safe Rust</code>下不暴露<code>&amp;mut T</code>。</p>
<p>所以，接下来是该<code>Pin</code>登场的时候了！</p>
<h2 id="pin-闪亮登场"><a class="header" href="#pin-闪亮登场">Pin 闪亮登场</a></h2>
<p>我们找到了问题的根源在哪，<code>Pin</code>就是从根源上解决这个问题的。现在我们很清晰了，似乎是不是可以用一句话概括：<code>Pin</code>就是一个不会让你在<code>Safe Rust</code>暴露可变借用<code>&amp;mut</code>的智能指针?</p>
<p>答案是：不全正确。这就是<code>Pin</code>概念起初让大家一脸懵逼的地方。下面让<code>Pin</code>自己来解答大家的疑惑，<code>Pin</code>说：“你们不是想让我保证被我包裹的指针<code>P&lt;T&gt;</code>永远钉住不让<code>move</code>吗？我可以答应，但我有一个原则。那就是我永远不能钉住持有通行证的朋友，这张通行证就是<code>Unpin</code>。如果没有这张通行证，请放心，我会把你钉得死死的！”</p>
<p>举个例子。比如我是<code>Pin</code>，你是<code>P&lt;T&gt;</code>，如果你 impl 了<code>Unpin</code>，我会提供两种办法让你在<code>Safe Rust</code>下拿到<code>&amp;mut T</code>：</p>
<ul>
<li>第一种，使用：<code>Pin::get_mut()</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a mut T&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub fn get_mut(self) -&gt; &amp;'a mut T where T: Unpin {
        self.pointer
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>第二种，我 impl 了<code>DerefMut</code>，你可以解引用拿到<code>&amp;mut T</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可<code>rustc</code>爸爸太宽容了，他默认给你们所有类型发了通行证（都实现了<code>Unpin</code>）！搞得我都几乎快要失业了！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[lang = &quot;unpin&quot;]
pub auto trait Unpin {}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;'a, T: ?Sized + 'a&gt; Unpin for &amp;'a T {}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;'a, T: ?Sized + 'a&gt; Unpin for &amp;'a mut T {}

#[stable(feature = &quot;pin_raw&quot;, since = &quot;1.38.0&quot;)]
impl&lt;T: ?Sized&gt; Unpin for *const T {}

#[stable(feature = &quot;pin_raw&quot;, since = &quot;1.38.0&quot;)]
impl&lt;T: ?Sized&gt; Unpin for *mut T {}
<span class="boring">}
</span></code></pre></pre>
<p>唯一让我欣慰的是，他给我留了一个叫<code>PhantomPinned</code>的小伙伴。别看他名字很奇怪，他可是我很喜欢的得力助手！因为他实现的是<code>!Unpin</code>！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PhantomPinned;

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl !Unpin for PhantomPinned {}
<span class="boring">}
</span></code></pre></pre>
<p><code>rustc</code>爸爸还说，你们如果想“改邪归正”去掉<code>Unpin</code>也可以，有两种办法：</p>
<ul>
<li>使用<code>PhantomPinned</code>。有了它，<code>rustc</code>爸爸不会让你实现<code>Unpin</code>。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
   a: String,
   b: *const String,
   _marker: PhantomPinned,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>得自己手动impl <code>!Unpin</code>。前提是你要使用<code>nightly</code>版本，并且需要引入<code>#![feature(negative_impls)]</code>：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]
<span class="boring">fn main() {
</span>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl !Unpin for Test {}
<span class="boring">}
</span></code></pre></pre>
<p>满足以上任意两个条件之一的话，我就会保证你没办法在<code>Safe Rust</code>下拿到可变借用<code>&amp;mut T</code>（不信你去翻翻我的 API），拿不到<code>&amp;mut T</code>你就没办法作用到<code>std::mem::swap()</code>上，也就是说你被我钉住了！你以为<code>rustc</code>爸爸给我施了魔法么？你错了，我的工作原理就是这么简单！感谢 Rust 世界丰富而强大的类型系统，我的其他兄弟<code>Sync</code>，<code>Send</code>也是这样，我们都没有所谓的魔法！</p>
<p>当然我还是提供了一个<code>unsafe</code>的<code>get_unchecked_mut()</code>，不管你有没有实现<code>Unpin</code>，你都可以通过调用这个方法拿到<code>&amp;mut T</code>，但是你需要遵守<code>Pin</code>的契约（参考下面），否则出了什么问题后果自负！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a mut T&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub unsafe fn get_unchecked_mut(self) -&gt; &amp;'a mut T {
        self.pointer
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="pin的契约"><a class="header" href="#pin的契约">Pin的契约：</a></h3>
<blockquote>
<p>对于<code>Pin&lt;P&lt;T&gt;&gt;</code>，</p>
<ul>
<li>如果<code>P&lt;T&gt;</code>符合<code>Unpin</code>，那<code>P&lt;T&gt;</code>从被<code>Pin</code>包裹到被销毁，都要一直保证<code>P&lt;T&gt;</code>不被钉住</li>
<li>如果<code>P&lt;T&gt;</code>符合<code>!Unpin</code>，那<code>P&lt;T&gt;</code>从被<code>Pin</code>包裹到被销毁，都要一直保证<code>P&lt;T&gt;</code>被钉住</li>
</ul>
</blockquote>
<p>通过以上<code>Pin</code>的自述，我们再用一句话来总结：如果你实现了<code>Unpin</code>，<code>Pin</code>可以让你在<code>Safe Rust</code>下拿到<code>&amp;mut T</code>，否则会把你在<code>Safe Rust</code>下钉住(也就是拿不到<code>&amp;mut T</code>)。</p>
<p>接下来我们使用<code>Pin</code>来修复一下上面自引用结构体的问题。</p>
<h2 id="如何构造一个-pin"><a class="header" href="#如何构造一个-pin">如何构造一个 Pin</a></h2>
<p>首先我们要梳理清楚怎样把<code>P&lt;T&gt;</code>用<code>Pin</code>包裹起来，也就是怎样构造一个<code>Pin</code>。查看文档会发现主要有这几种方式：</p>
<h3 id="pinnew"><a class="header" href="#pinnew">Pin::new()</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub fn new(pointer: P) -&gt; Pin&lt;P&gt; {
        // Safety: the value pointed to is `Unpin`, and so has no requirements
        // around pinning.
        unsafe { Pin::new_unchecked(pointer) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你的 P 指向的 T 是<code>Unpin</code>的话，你可以安全的调用<code>Pin::new()</code>构造一个<code>Pin</code>。可以看到它底层实际上是调用<code>unsafe</code>的<code>Pin::new_unchecked()</code>，之所以<code>Pin::new()</code>是安全的，是因为<code>Unpin</code>的情况下<code>Pin</code>的”钉住“效果是不起作用的，跟正常的指针一样了。</p>
<h3 id="pinnew_unchecked"><a class="header" href="#pinnew_unchecked">Pin::new_unchecked()</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P: Deref&gt; Pin&lt;P&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub unsafe fn new_unchecked(pointer: P) -&gt; Pin&lt;P&gt; {
        Pin { pointer }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个方法很简单，但它是<code>unsafe</code>的。标为<code>unsafe</code>的原因是编译器没办法保证使用者后续操作一定遵守<code>Pin</code>的契约。只要有存在违反契约的可能性，就必须用<code>unsafe</code>标记，因为这是使用者的问题，编译器没办法保证。如果使用者通过<code>Pin::new_unchecked()</code>构造一个<code>Pin&lt;P&lt;T&gt;&gt;</code>之后<code>Pin</code>的生命周期结束了，但<code>P&lt;T&gt;</code>依然存在，则后续操作依然可能被<code>move</code>，造成内存不安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::pin::Pin;

fn move_pinned_ref&lt;T&gt;(mut a: T, mut b: T) {
    unsafe {
        let p: Pin&lt;&amp;mut T&gt; = Pin::new_unchecked(&amp;mut a);
        // This should mean the pointee `a` can never move again.
    }
    mem::swap(&amp;mut a, &amp;mut b);
    // The address of `a` changed to `b`'s stack slot, so `a` got moved even
    // though we have previously pinned it! We have violated the pinning API contract.
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<p>包括<code>Box::pin()</code>，<code>Rc::pin()</code>和<code>Arc::pin()</code>等，底层都是调用上面的<code>Pin::new_unchecked()</code>，不再阐述。</p>
<h2 id="pin-的应用"><a class="header" href="#pin-的应用">Pin 的应用</a></h2>
<p><code>Pin</code>可以分为栈上还是堆上，取决于你要<code>Pin</code>的那个指针 P 是在栈上还是堆上。比如<code>Pin&lt;&amp;mut T&gt;</code>是栈上，<code>Pin&lt;Box&lt;T&gt;&gt;</code>是在堆上。</p>
<h3 id="pin-到栈上"><a class="header" href="#pin-到栈上">Pin 到栈上</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }

    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
        let self_ptr: *const String = &amp;self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut Test::new(&quot;test1&quot;)) };
    Test::init(test1.as_mut());

    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut Test::new(&quot;test2&quot;)) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
</code></pre></pre>
<p>我们尝试把<code>&amp;mut Test</code>钉在栈上，然后尝试去调用<code>get_mut()</code>作为参数传给<code>std::mem::swap()</code>，发现编译不通过。Rust 编译器从编译阶段就阻止我们去犯错了。</p>
<pre><code class="language-console">|     std::mem::swap(test1.get_mut(), test2.get_mut());
  |                          ^^^^^^^ within `Test`, the trait `Unpin` is not implemented for `PhantomPinned`
  |
</code></pre>
<h3 id="pin-到堆上"><a class="header" href="#pin-到堆上">Pin 到堆上</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &amp;boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test2 = Test::new(&quot;test2&quot;);

    println!(&quot;a: {}, b: {}&quot;,test1.as_ref().a(), test1.as_ref().b());
    // std::mem::swap(test1.get_mut(), test2.get_mut());
    // std::mem::swap(&amp;mut *test1, &amp;mut *test2);
    println!(&quot;a: {}, b: {}&quot;,test2.as_ref().a(), test2.as_ref().b());
}
</code></pre></pre>
<p>这里使用<code>Box::pin()</code>把 Test 钉在了堆上。取消注释任意一行都会编译不通过，因为 Test 是<code>!Unpin</code>的。</p>
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;futures_api&quot;, since = &quot;1.36.0&quot;)]
pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来讲一下<code>Pin</code>目前最重要的一个应用：<code>Future</code>。当初 2018 年官方异步组引入<code>Pin</code> API的初衷就是为了解决<code>Future</code>内部自引用的问题。因为<code>async/await</code>就是通过<code>Generator</code>实现的，<code>Generator</code>是通过匿名结构体实现的。如果<code>async</code>函数中存在跨<code>await</code>的引用，会导致底层<code>Generator</code>存在跨<code>yield</code>的引用，那根据<code>Generator</code>生成的匿名结构体就会是一个自引用结构体！然后这个自引用结构体会impl <code>Future</code>，异步的<code>Runtime</code>在调用<code>Future::poll()</code>函数查询状态的时候，需要一个可变借用(即<code>&amp;mut Self</code>)。如果这个<code>&amp;mut Self</code>不包裹在<code>Pin</code>里面的话，开发者自己impl <code>Future</code>就会利用<code>std::mem::swap()</code>之类的函数<code>move</code>掉<code>&amp;mut Self</code>！所以这就是<code>Future</code>的<code>poll()</code>必须要使用<code>Pin&lt;&amp;mut Self&gt;</code>的原因。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个async块中存在跨await的借用！
let mut fut = async {
    let to_borrow = String::from(&quot;Hello&quot;);
    let borrowed = &amp;to_borrow;
    SomeResource::some_task().await;
    println!(&quot;{} world!&quot;, borrowed);
};
<span class="boring">}
</span></code></pre></pre>
<p>当然还有非常重要的一点不能忘了！<code>Pin</code>只对实现<code>!Unpin</code>的类型才有钉住的效果，这个impl <code>Future</code>的匿名结构体有impl <code>!Unpin</code>吗？当然有，前面说了只有几种特例是默认<code>!Unpin</code>，这个匿名结构体就是其中之一。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
where
    T: Generator&lt;ResumeTy, Yield = ()&gt;,
{
    #[rustc_diagnostic_item = &quot;gen_future&quot;]
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    // We rely on the fact that async/await futures are immovable in order to create
    // self-referential borrows in the underlying generator.
    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection.
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };

            // Resume the generator, turning the `&amp;mut Context` into a `NonNull` raw pointer. The
            // `.await` lowering will safely cast that back to a `&amp;mut Context`.
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}
<span class="boring">}
</span></code></pre></pre>
<p>划重点<code>impl &lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}</code>，只有亲眼所见才能让大家信服。</p>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<p><code>Pin</code>除了上面这些内容外还有其他几个概念，比如<code>Pin projection</code>，<code>Structural pin</code>和<code>Non-structural pin</code>，笔者自己用的也不多，详细可以看官方文档或查阅其他资料。</p>
<p><a href="https://docs.rs/futures">futures-rs</a> 中还有不少和<code>Pin</code>有关的 API，如果深入使用<code>futures-rs</code>的话，不可避免的需要频繁的和<code>Pin</code>打交道。</p>
<p><img src="lang/rust/./img/futures-rs.png" alt="futures-rs" /></p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>下面是摘抄自官方 <a href="https://github.com/rust-lang/async-book">Async Book</a> 上关于<code>Pin</code>的黄金8条作为总结，这些几乎就是<code>Pin</code> API 的全部了。</p>
<blockquote>
<ul>
<li>If T: Unpin (which is the default), then Pin&lt;'a, T&gt; is entirely equivalent to &amp;'a mut T. in other words: Unpin means it's OK for this type to be moved even when pinned, so Pin will have no effect on such a type.</li>
<li>Getting a &amp;mut T to a pinned T requires unsafe if T: !Unpin.</li>
<li>Most standard library types implement Unpin. The same goes for most &quot;normal&quot; types you encounter in Rust. A Future generated by async/await is an exception to this rule.</li>
<li>You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.</li>
<li>You can either pin data to the stack or to the heap.</li>
<li>Pinning a !Unpin object to the stack requires unsafe</li>
<li>Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.</li>
<li>For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.</li>
</ul>
</blockquote>
<p>2018 年 Rust 异步组的核心成员 @withoutboats 在他个人博客分享了稳定<code>async/await</code>的整个心路历程，感觉这一路也是充满曲折。比如<code>Pin</code>刚开始还需要区分<code>Pin</code>，<code>PinMut</code>，<code>PinBox</code>等，现在精简到只需要一个<code>Pin&lt;P&gt;</code>就能搞定。还有更早的时候还计划引入一个叫<code>Move</code>的 trait 来标记该类型是否可以<code>move</code>等等。我这篇文章里面的代码基于 1.48 版，不确定<code>Pin</code>以后会不会有更新，而且<code>Pin</code>目前还存在一个<code>unsoundness</code>的问题。不管怎样，一切简单优雅的设计背后一定隐藏着复杂和艰辛，感谢 Rust 官方过去的努力，让我们能够有内存安全、无畏并发和符合人体工程的编程体验！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
