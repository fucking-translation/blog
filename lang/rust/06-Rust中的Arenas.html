<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>「转」Rust 中的 Arenas - Blog Translation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../theme/ferris.css">
        
        <link rel="stylesheet" href="../../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="../../lang/rust/06-Rust中的Arenas.html" class="active"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item expanded "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item expanded "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item expanded "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item expanded "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item expanded "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li><li class="chapter-item expanded "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.20.</strong> 标准库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.20.1.</strong> std::pin</a></li><li class="chapter-item expanded "><a href="../../lang/rust/std/21-std-condvar.html"><strong aria-hidden="true">1.20.2.</strong> std::sync::Condvar</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-hrefhttpsgithubcomrustmagazinerust_magazine_2021blobmainsrcchapter_3arenas-in-rustmd转a-rust-中的-arenas"><a class="header" href="#a-hrefhttpsgithubcomrustmagazinerust_magazine_2021blobmainsrcchapter_3arenas-in-rustmd转a-rust-中的-arenas"><a href="https://github.com/RustMagazine/rust_magazine_2021/blob/main/src/chapter_3/arenas-in-rust.md">「转」</a> Rust 中的 Arenas</a></h1>
<blockquote>
<p>转载：<a href="https://github.com/RustMagazine/rust_magazine_2021">RustMagazine 2021 期刊</a> -&gt; <a href="https://github.com/RustMagazine/rust_magazine_2021/blob/main/src/chapter_3/arenas-in-rust.md">Rust 中的 Arenas</a></p>
</blockquote>
<h1 id="rust-中的-arenas-内存池"><a class="header" href="#rust-中的-arenas-内存池">Rust 中的 Arenas 内存池</a></h1>
<p>最近有一些关于 Rust 中 <code>Arenas</code> 的讨论，我想我应该写一篇关于这个的文章。</p>
<p>在 Rust 中，<code>Arenas</code> 并不是那种 &quot;典型的&quot; 问题，所以很少有人了解它们。只会在各种用例的应用程序中有看到它们。一般来说，你只需要调包就行了，没必要为它使用 <code>unsafe</code> 。因此无需专门去了解它，但这些知识也不是无用的，尤其是对使用 <code>Arenas</code> 的人来说更是如此 。</p>
<p>此外，我在实现自引用的 <code>Arenas</code> 时会涉及到一系列非常<em>酷</em>的 <code>lifetime</code>操作 ，我以前完全没写过。</p>
<p>我主要是为了一些<em>很酷</em>的生命周期效应而写的，但是我认为有必要写一篇针对所有 <code>Rustaceans</code> 的介绍。如果你已经知道什么是 <code>Arenas</code>，并且想看到一些很炫酷的 <code>lifetime</code> 技巧，则可以直接跳到<a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/#implementing-a-self-referential-arena">这里</a>阅读。</p>
<h2 id="什么是-arena-"><a class="header" href="#什么是-arena-">什么是 arena ?</a></h2>
<p><code>Arenas</code> 本质上是一种将生命周期相同的内存进行分组的模式。比如说有时需要在某个生命周期内分配一堆对象，之后这些对象将被全部销毁。每次都调用系统分配器效率低下，更可取的是为对象预分配一堆内存，并在完成处理后立即将其全部清理干净。</p>
<blockquote>
<p>译者注: 没错就是 cache</p>
</blockquote>
<p>从广义上讲，使用 <code>Arenas</code>  有以下两个原因：</p>
<p>首先，如上所述，使用它的主要目标是减轻内存消耗。例如，在游戏或应用程序中，可能存在大量对象需要逐帧分配，使用完立即销毁的情况。特别是在游戏开发中，这非常普遍，而内存压力是游戏开发人员比较关心的事情。使用 <code>Arenas</code>，可以轻松地分配一个 <code>Arena</code>，在每个帧中将其填满，并在帧结束后将其清空。缓存局部性还能其他好处：可以确保大多数每帧对象在帧期间（可能比其他对象使用得更多）位于缓存中，因为它们是相邻分配的。</p>
<p>另一个原因可能是用于编写<code>自引用</code>的数据，例如带有环的复杂图，使用此方法可以一次性清除全部数据。例如，在编写编译器时，类型信息可能将需要引用其他类型或者其他数据，从而导致复杂的类型有环图。一旦推导出类型，就不需要专门销毁它了，因此可以使用一个 <code>Arenas</code> 来存储所有计算出的类型信息，当类型信息无关紧要时，就可以直接将他们一次性清楚。使用这种模式可以让代码不必担心自引用位是否会 “提前” 释放，它可以保证，如果存在一个 <code>Ty</code> ，则它的寿命与其他所有 <code>Ty</code> 一样长，并且可以直接引用它们。</p>
<blockquote>
<p>译者注: 不会导致空引用</p>
</blockquote>
<p>这两个目标不一定是相互联系的：可以使用一个 <code>Arenas</code> 来同时实现两个目标。但是，也可以拥有一个禁止使用自我引用类型的 <code>Arenas</code>（有得有失，你能得到一些好处）。在本文的稍后部分，我将实现一个允许自我引用类型但对减轻内存分配压力影响不大的 <code>Arenas</code>，主要是为了易于实现。<em>通常</em>，如果你正在为自引用类型编写 <code>Arenas</code>，则可以使其同时减少分配器压力，但可能会有所取舍。</p>
<h2 id="在-rust-中如何使用-arena-"><a class="header" href="#在-rust-中如何使用-arena-">在 Rust 中如何使用 arena ?</a></h2>
<p>一般来说，要使用 arena ，只需要调包。 我简单的搜索一下现有的 <code>Arenas</code> 实现，在<a href="https://crates.io/search?q=arena">这里</a>。下面我会介绍两个我已经了解的库，但我只是挂 &quot;二&quot; 漏万。</p>
<p>要指出的是，如果只需要环结构，而不必使用 <code>arenas</code> ，那么出色的 <a href="https://docs.rs/petgraph/">petgraph</a> 通常就足够了。 <a href="https://docs.rs/slotmap/">slotmap</a> 也很不错； 它是类似地图的数据结构，可用于基于分代索引的自引用数据。 </p>
<h3 id="bumpalo"><a class="header" href="#bumpalo">Bumpalo</a></h3>
<p><code>Bumpalo</code> 是一种快速的 <code>bump allocator[1]</code>，它允许异构的内容，并且仅在不关心析构函数运行的情况下才允许循环。</p>
<blockquote>
<p>参见: <a href="https://blog.codingnow.com/2013/11/bump_pointer_allocator.html">1</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bumpalo::Bump;

// (example slightly modified from `bumpalo` docs)

// Create a new arena to bump allocate into.
let bump = Bump::new();

// Allocate values into the arena.
let scooter = bump.alloc(Doggo {
    cuteness: u64::max_value(),
    age: 8,
    scritches_required: true,
});

// Happy birthday, Scooter!
scooter.age += 1;
<span class="boring">}
</span></code></pre></pre>
<p>每次对 <code>Bump::alloc()</code> 的调用都会返回对已分配对象的可变引用。 这可以分配不同的对象，它们甚至可以相互引用 (不用环的话,借用检查就会强制这样做) 。 默认情况下，它不会在其内容上调用析构函数。 但是，可以使用 <code>bumpalo::boxed</code>（或Nightly上的自定义分配器）来实现这个效果。 可以类似地使用 <code>bumpalo::collections</code>来获取 <code>bumpalo</code> 支持的向量和字符串。<code> bumpalo::boxed</code> 将不允许自引用。</p>
<h3 id="typed-arena"><a class="header" href="#typed-arena">typed-arena</a></h3>
<p><a href="https://docs.rs/typed-arena/">typed-arena</a>是一个 <code>areana</code> 分配器，它只能存储单一类型的对象，但是就可以循环引用： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example from typed-arena docs

use std::cell::Cell;
use typed_arena::Arena;

struct CycleParticipant&lt;'a&gt; {
    other: Cell&lt;Option&lt;&amp;'a CycleParticipant&lt;'a&gt;&gt;&gt;,
}

let arena = Arena::new();

let a = arena.alloc(CycleParticipant { other: Cell::new(None) });
let b = arena.alloc(CycleParticipant { other: Cell::new(None) });

// mutate them after the fact to set up a cycle
a.other.set(Some(b));
b.other.set(Some(a));
<span class="boring">}
</span></code></pre></pre>
<p>和 <code>bumpalo</code> 不同的是，<code>typed-arena</code> 当 <code>arena</code> 本身超出范围时，就会使用析构函数。</p>
<blockquote>
<p>你或许想知道，析构函数在引用数据上的安全性–毕竟，无论哪一个变量被第二次销毁，析构函数都会读到悬挂的引用。我们将在文章的后面对此进行介绍，但这与 <code>drop</code> 检查有关，特别是如果尝试自引用时，则 arena 元素本身允许的唯一显式析构函数将是带有适当标记类型的析构函数。</p>
</blockquote>
<h2 id="实现一个支持自引用的-arena"><a class="header" href="#实现一个支持自引用的-arena">实现一个支持自引用的 arena</a></h2>
<p>写自引用代码是很有趣的，因为 Rust 非常警惕自我参照数据。 但是 <code>areana</code> 可以让你清楚地将“我不在乎此对象”和“可以删除此对象”阶段分开，以允许自引用和循环类型出现。</p>
<blockquote>
<p>人们很少需要实现自己的 arena，Bumpalo 和 Typedarena 涵盖了大多数使用场景，实在没办法的话不妨先在 crates.io 上 找一下。 但是，如果你的确需要直接实现的话，或者对具体的生命周期细节感兴趣，那么本节适合你。</p>
</blockquote>
<p>实现带有 Entry 类型的 Arena 的关键是以下几种规则：</p>
<ul>
<li><code>Arena</code>和<code>Entry</code>都应具有生命周期参数：<code>Arena &lt;'arena&gt;</code>和<code>Entry &lt;'arena&gt;</code></li>
<li><code>Arena</code>方法都应将<code>Arena &lt;'arena&gt;</code>作为<code>＆'arena self</code>，即<code>self</code>的类型为<code>＆'arena Arena &lt;'arena&gt;</code></li>
<li><code>Entry</code>几乎应该始终以<code>＆'arena Entry &lt;'arena&gt;</code>的形式传递（为此创建别名非常有用）</li>
<li>使用内部可变性；<code>Arena</code>上的<code>＆mut self</code>将使所有代码停止编译。如果使用<code>unsafe</code>的可变性，请确保 <code>RefCell&lt;Entry&lt;'arena&gt;&gt;</code>  具有 <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a> 。</li>
</ul>
<p>从生命周期的角度来看基本上就是这样，剩下的全部就是确定所需的 API。掌握了以上规则，只要确保定义区域与所需的保证一起使用，就不必了解底层生命周期的状况。</p>
<p>让我们看一个实现，然后剖析其工作原理。 </p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<p>我的库 <a href="https://docs.rs/elsa">elsa</a> 在其中一个示例中使用 100％ <code>safe</code> 的代码实现了一个 <code>arena</code> 。由于 <code>elsa :: FrozenVec</code> 要求其内容位于间接引用之后，因此该 <code>arena</code> 无法节省分配，并且它不是通用的，但这是一种合理的方式来说明生命周期的工作方式，而无需陷入 使用 <code>unsafe</code> 带来的麻烦之中。</p>
<p>该示例实现了 <code>Person &lt;'arena&gt;</code> 类型的 <code>Arena</code> ，<code>Arena &lt;'arena&gt;</code> 。目标是实现某种可能有环的有向社交图。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use elsa::FrozenVec;

struct Arena&lt;'arena&gt; {
    people: FrozenVec&lt;Box&lt;Person&lt;'arena&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/elsa/1.4.0/elsa/vec/struct.FrozenVec.html">elsa::FrozenVec</a> 是类似于 <code>Vec</code> 的仅支持追加内容的抽象，可让你调用<code>push</code> 而不需要传入可变的引用，这是只使用 <code>safe</code> 的一个实现。</p>
<p>每个 <code>Person &lt;'arena&gt;</code> 都有一个他们关注的人的列表，但也跟踪他们关注的人：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person&lt;'arena&gt; {
    pub follows: FrozenVec&lt;PersonRef&lt;'arena&gt;&gt;,
    pub reverse_follows: FrozenVec&lt;PersonRef&lt;'arena&gt;&gt;,
    pub name: &amp;'static str,
}

// following the rule above about references to entry types
type PersonRef&lt;'arena&gt; = &amp;'arena Person&lt;'arena&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这个生命周期 <code>arena</code>  其实是 “arena本身的生命周期”。 从这开始事情就变得奇怪起来了：通常，如果一个有生命周期参数，则调用者可以选择其中的内容。 不必只是说“这是对象本身的生命周期”，调用者通常可以根据需要实例化 <code>arena &lt;'static&gt;</code> 或为某个 <code>'a</code> 实例化 <code>Arena &lt;'a&gt;</code> 。 但是在这里，我们声明 “<code>'arena</code> 是 <code>arena</code> 自身的生命周期”； 很明显，一定有东西不太对。</p>
<p>这是我们实际实现的地方：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'arena&gt; Arena&lt;'arena&gt; {
    fn new() -&gt; Arena&lt;'arena&gt; {
        Arena {
            people: FrozenVec::new(),
        }
    }
    
    fn add_person(&amp;'arena self, name: &amp;'static str,
                  follows: Vec&lt;PersonRef&lt;'arena&gt;&gt;) -&gt; PersonRef&lt;'arena&gt; {
        let idx = self.people.len();
        self.people.push(Box::new(Person {
            name,
            follows: follows.into(),
            reverse_follows: Default::default(),
        }));
        let me = &amp;self.people[idx];
        for friend in &amp;me.follows {
            // We're mutating existing arena entries to add references,
            // potentially creating cycles!
            // 把每一个元素都加上了 引用 , 很有可能导致循环引用
            friend.reverse_follows.push(me)
        }
        me
    }

    fn dump(&amp;'arena self) {
        // code to print out every Person, their followers, and the people who follow them
        // 打印出 `Person` ,他们的关注者 ,和关注的人
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>注意 <code>add_person中的&amp;'arena self</code>。</p>
<p>此处的很好的实现了,“如果A 关注了 B，然后B又关注A” 这种通常需要分开处理的情况，但这仅是示例。</p>
<p>最后，我们可以像这样使用 <code>arena</code> ：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arena = Arena::new();
    let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
    let best_friend = arena.add_person(&quot;best friend&quot;, vec![lonely]);
    let threes_a_crowd = arena.add_person(&quot;threes a crowd&quot;, vec![lonely, best_friend]);
    let rando = arena.add_person(&quot;rando&quot;, vec![]);
    let _everyone = arena.add_person(&quot;follows everyone&quot;, vec![rando, threes_a_crowd, lonely, best_friend]);
    arena.dump();
}
</code></pre></pre>
<p>在这种情况下，所有 “可变性” 都发生在 <code>arena</code> 本身的实现中，但是此代码可能会将元素直接添加到 <code>follows/reverse_follows</code> 列表中，或者 <code>Person</code> 可能具有用于其他类型链接的 <code>RefCells</code> 。</p>
<h3 id="生命周期是如何工作的"><a class="header" href="#生命周期是如何工作的">生命周期是如何工作的</a></h3>
<p>那么这是如何工作的呢？ 如前所述，在 Rust 中使用这样的抽象，调用者通常可以自由地根据其处理方式来设置生存期。 例如，如果 <code>HashMap&lt;K，&amp;'a str&gt;</code>，则 <code>'a</code> 将根据你尝试插入的内容的生存期进行调整。</p>
<p>当构造 <code>Arena</code> 时，其生命周期确实仍然不受限制，我们可以通过检查以下强制约束生命周期的代码来进行测试(依然是能过编译的)。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena: Arena&lt;'static&gt; = Arena::new();
<span class="boring">}
</span></code></pre></pre>
<p>当你想做点什么的时候,就会停止工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena: Arena&lt;'static&gt; = Arena::new();
let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">error[E0597]: `arena` does not live long enough
  --&gt; examples/mutable_arena.rs:5:18
   |
4  |     let arena: Arena&lt;'static&gt; = Arena::new();
   |                -------------- type annotation requires that `arena` is borrowed for `'static`
5  |     let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
   |                  ^^^^^ borrowed value does not live long enough
...
11 | }
   | - `arena` dropped here while still borrowed
</code></pre>
<p><code>add_person</code> 方法以某种方式强制将 <code>Arena</code> 的 <code>arena</code> 参数设置为自己的生命周期，从而对其进行约束（并且无法用类型注释将其强制约束为其他任何值）。 这是与 <code>add_person</code> 的<code>＆'arena</code> 自签名（即 self 是 <code>＆'arena Arena &lt;'self&gt;</code> ）的巧妙互动，以及<code>'Arena in Arena &lt;'arena&gt;</code> 是<a href="https://doc.rust-lang.org/nomicon/subtyping.html#variance">不变的生命周期</a>。</p>
<p>通常，在 Rust 程序中，生命周期具有&quot;伸缩性&quot;。 以下代码可以通过编译：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ask for two strings *with the same lifetime*
// 要求具有相同 生命周期的 string 
fn take_strings&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) {}

// string literal with lifetime 'static
// 要求具有 `'static' 生命周期的 ` string literal`  
let lives_forever = &quot;foo&quot;;
// owned string with shorter, local lifetime
// 要求具有 `local` 生命周期
let short_lived = String::from(&quot;bar&quot;);

// still works!
// 能跑通
take_strings(lives_forever, &amp;*short_lived);
<span class="boring">}
</span></code></pre></pre>
<p>在这段代码中，Rust 很高兴地注意到，虽然 <code>live_forever</code> 和 <code>&amp;* short_lived</code> 具有不同的生命周期，但假装 <code>life_forever</code> 在 <code>take_strings</code> 函数的有效期内具有较短的生命周期是完全可以接受的。这只是引用，使用生命周期长的引用也适用于生命周期短的情况。</p>
<p>事实是，这种伸缩性并非对所用的生命周期都一样！<a href="https://doc.rust-lang.org/nomicon/subtyping.html">nomicon chapter on subtyping and variance</a> 一章详细说明了为什么会这样，但一般的经验法则是，大多数生命周期都是“紧缩的” (更专业的说法是 <code>协变的</code> )，就像上面的<code>&amp;a str</code> 中的一样，但是如果涉及某种形式的可变性，它们是不可变的，也称为“不变式”。如果使用的是函数类型，则具有 <code>弹性的</code> 生命周期 (即抗变的)，但是这种情况很少见。</p>
<p>我们的 <code>Arena &lt;'arena&gt;</code> 使用内部可变性（通过 <code>FrozenVec</code>）使' <code>arena</code>不变。 让我们再次看一下两行代码。当编译器看到下面代码的第一行时，便会构建 <code>arena</code>，我们将其生命周期称为“ a”。此时 Arena 类型是 <code>Arena &lt;'？&gt;</code> ，其中的'？由表示形式表示，但生命周期不受限制。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena = Arena::new(); 
let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<p>让我们把生命周期写清楚一点：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena = Arena::new(); // type Arena&lt;'?&gt;, lives for 'a

// explicitly write the `self` that gets constructed when you call add_person
// 显式写出 在调用 add_person 时的构建函数
let ref_to_arena = &amp;arena; // type &amp;'a Arena&lt;'?&gt;
let lonely = Arena::add_person(ref_to_arena, &quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<p>还记得我之前列出的第二条规则吗？</p>
<ul>
<li>Arena方法都应将Arena &lt;'arena&gt;接收为＆'arena自身，即其自身类型为＆'arena Arena &lt;'arena&gt; 我们遵循这条规则；</li>
</ul>
<p><code>add_person</code> 的签名是 <code>fn add_person(&amp;'arena self)</code>。这意味着 <code>ref_to_arena</code> 的生存期必须与 <code>&amp;'arena Arena &lt;'arena&gt;</code> 模式匹配。目前，它的生命周期是<code>&amp;'a Arena &lt;'?&gt;</code>，表示<code>'?</code>强制与'a相同，即 <code>arena</code> 变量本身的生存期。如果生命周期是可变的，则编译器可以压缩其他生存期来适配它，但它是不变的，并且不受限制的生存期被强制转变成一个确切的生命周期。</p>
<p>通过这个巧妙的技巧，我们可以强制编译器将 <code>Arena &lt;'arena&gt;</code> 的生存期参数设置为其实例的生存期。 </p>
<p>在此之后，其余的工作就非常简单了。 <code>Arena &lt;'arena&gt;</code> 拥有类型为 <code>Person &lt;'arena&gt;</code>的元素，也就是说：“<code>Person</code> 被允许引用具有 <code>'arena</code> 生命周期的元素, 例如 <code>Arena</code>“。</p>
<p><code>type PersonRef &lt;'arena&gt; =&amp;'arena Person &lt;'arena&gt;</code>是引用在 <code>Arena</code> 中并允许从其中引用对象 <code>Person</code> 的引用的便捷缩写。</p>
<h3 id="析构器如何工作"><a class="header" href="#析构器如何工作">析构器如何工作</a></h3>
<p>到目前为止，我还没有讨论存在析构函数的情况下如何保证安全。 如果 <code>Arena</code> 具 有循环引用，并且编写了一个析构函数读取去这些循环引用，那么在销毁的过程中就会导致悬垂引用。</p>
<p>这是 rust 十分模糊的地方。 除了“明确析构器巧妙地改变借用检查行为”，你没有什么需要必须去了解的。 但是了解这里的机制对建立一个更好的心智模型更有帮助。</p>
<p>如果将以下代码添加到 <code>arena</code> 示例中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'arena&gt; Drop for Person&lt;'arena&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;goodbye {:?}&quot;, self.name);
        for friend in &amp;self.reverse_follows {
            // potentially dangling!
            println!(&quot;\t\t{}&quot;, friend.name);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>报错:</p>
<pre><code class="language-shell">error[E0597]: `arena` does not live long enough
  --&gt; examples/mutable_arena.rs:5:18
   |
5  |     let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
   |                  ^^^^^ borrowed value does not live long enough
...
11 | }
   | -
   | |
   | `arena` dropped here while still borrowed
   | borrow might be used here, when `arena` is dropped and runs the destructor for type `Arena&lt;'_&gt;`
</code></pre>
<p>析构函数的存在在自引用数据的生命周期内巧妙地更改了借用检查器的行为。准确的规则是十分 <code>tricky</code>的，并在 <a href="https://doc.rust-lang.org/nomicon/dropck.html">nomicon</a>中进行了解释，但实际上发生的是，在Person &lt;'arena&gt;上存在自定义析构函数后，<code>'person arena</code>(因为是Arena)的<code>'arena</code>变成了一个“在销毁时观测到的的生命周期&quot;。然后在借用检查期间将其考虑在内---知道作用域末尾隐式调用<code>drop()</code>能够读取<code>'arena</code>的数据，Rust 做出了适当的结论，由于销毁本身是可变的操作，在销毁之后，调用<code>drop()</code> 读取内容是可行的。</p>
<p>当然，需要问的一个合理问题是，如果析构函数不允许用 <code>'arena</code> “包装”数据，应该如何在 <code>arena</code> 中存储例如 <code>Box</code> 或者 <code>FrozenVec</code>之类的东西呢？</p>
<p>原因是 Rust 知道 <code>Box::Drop</code>由于不清楚 <code>Person</code> 是什么,也不会去试图知道,而无法检查 <code>Person.follows</code>的内容。</p>
<p>当然凡事都有例外,由于析构器可以调用指定的 <code>trait</code> 方法(或者特化的方法)来告诉如何读取<code>Person</code>的内容,如果有一个随机的泛型类型提供了这种方法,就可以再次巧妙地更改借用检查器的行为。<code>stdlib</code> 类型和其他自定义数据结构通过转义填充<code>#[may_dangle]</code>（也称为“ eyepatch” 毕竟析构器 &quot;看不到&quot; 生命周期）来实现这种目的，声明不会从生命周期或通用参数中读取自定义析构函数。</p>
<p>这也适用于诸如 <a href="https://docs.rs/typed-arena/">typed-arena</a> 之类的库；如果需要创建循环引用，则将无法在为放置在 <code>arena</code>  上的类型上编写自定义析构函数。但是只要避免创建循环引用就可以使用 <code>typed-arena</code> 编写自定义析构函数了；因此将无法使用内部可变性来使一个 <code>arena</code> 指向另一个 <code>arena</code>。</p>
<p>感谢 <a href="https://mpc.sh/">Mark Cohen</a> 和 <a href="https://twitter.com/kneecaw/">Nika Layzell</a> 审阅了这篇文章的草稿。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../theme/ferris.js"></script>
        

        

    </body>
</html>
