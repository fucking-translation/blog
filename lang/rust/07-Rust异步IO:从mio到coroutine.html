<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 异步 IO: 从 mio 到 coroutine - Blog Translation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">6.</strong> Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html" class="active"><strong aria-hidden="true">7.</strong> Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">8.</strong> 图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">10.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">11.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">12.</strong> Rust 的 Pin 与 Unpin</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="转rust-异步-io从-mio-到-coroutine"><a class="header" href="#转rust-异步-io从-mio-到-coroutine">「转」Rust 异步 I/O：从 mio 到 coroutine</a></h1>
<blockquote>
<p>转载：<a href="https://hexilee.me/2018/12/17/rust-async-io/">Rust 异步 I/O：从 mio 到 coroutine</a></p>
</blockquote>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5-io-%E7%9A%84%E5%9F%BA%E7%9F%B3---mio">异步 IO 的基石 - mio</a>
<ul>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C-io">异步网络 IO</a></li>
<li><a href="#%E5%AE%B9%E9%94%99%E6%80%A7%E5%8E%9F%E5%88%99">容错性原则</a></li>
<li><a href="#poll-option">Poll Option</a></li>
<li><a href="#still-block">Still Block</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6">自定义事件</a></li>
<li><a href="#callback-is-evil">Callback is evil</a></li>
</ul>
</li>
<li><a href="#coroutine">coroutine</a>
<ul>
<li><a href="#generator">generator</a></li>
<li><a href="#%E8%87%AA%E5%BC%95%E7%94%A8">自引用</a></li>
<li><a href="#pin">Pin</a></li>
<li><a href="#%E5%90%88%E7%90%86%E7%9A%84%E6%8A%BD%E8%B1%A1">合理的抽象</a>
<ul>
<li><a href="#pollt">Poll&lt;T&gt;</a></li>
<li><a href="#await">await!</a></li>
<li><a href="#async">async</a></li>
</ul>
</li>
<li><a href="#non-blocking-coroutine">non-blocking coroutine</a>
<ul>
<li><a href="#executor">Executor</a></li>
<li><a href="#block_on">block_on</a></li>
<li><a href="#spawn">spawn</a></li>
<li><a href="#tcplistener">TcpListener</a></li>
<li><a href="#tcpstream">TcpStream</a></li>
<li><a href="#echo-server">echo-server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%90%8E%E8%AE%B0">后记</a></li>
</ul>
<h3 id="引言"><a class="header" href="#引言">引言</a></h3>
<p>2018 年接近尾声，<code>rust</code> 团队勉强立住了异步 <code>IO</code> 的 flag，<code>async</code> 成为了关键字，<code>Pin</code>, <code>Future</code>, <code>Poll</code> 和 <code>await!</code> 也进入了标准库。不过一直以来实际项目中用不到这套东西，所以也没有主动去了解过。</p>
<p>最近心血来潮想用 <code>rust</code> 写点东西，但并找不到比较能看的文档（可能是因为 <code>rust</code> 发展太快了，很多都过时了），最后参考<a href="https://cafbit.com/post/tokio_internals/">这篇文章</a>和 <code>&quot;new tokio&quot;</code>( <a href="https://github.com/withoutboats/romio">romio</a> ) 写了几个 <code>demo</code>，并基于 <code>mio</code> 在 <code>coroutine</code> 中实现了简陋的异步 <code>IO</code>。</p>
<p>最终实现的 file-server 如下：</p>
<pre><pre class="playground"><code class="language-rust">// examples/async-echo.rs

#![feature(async_await)]
#![feature(await_macro)]
#![feature(futures_api)]

#[macro_use]
extern crate log;

use asyncio::executor::{block_on, spawn, TcpListener, TcpStream};
use asyncio::fs_future::{read_to_string};
use failure::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    env_logger::init();
    block_on(new_server())?
}

const CRLF: &amp;[char] = &amp;['\r', '\n'];

async fn new_server() -&gt; Result&lt;(), Error&gt; {
    let mut listener = TcpListener::bind(&amp;&quot;127.0.0.1:7878&quot;.parse()?)?;
    info!(&quot;Listening on 127.0.0.1:7878&quot;);
    while let Ok((stream, addr)) = await!(listener.accept()) {
        info!(&quot;connection from {}&quot;, addr);
        spawn(handle_stream(stream))?;
    }
    Ok(())
}

async fn handle_stream(mut stream: TcpStream) -&gt; Result&lt;(), Error&gt; {
    await!(stream.write_str(&quot;Please enter filename: &quot;))?;
    let file_name_vec = await!(stream.read())?;
    let file_name = String::from_utf8(file_name_vec)?.trim_matches(CRLF).to_owned();
    let file_contents = await!(read_to_string(file_name))?;
    await!(stream.write_str(&amp;file_contents))?;
    stream.close();
    Ok(())
}
</code></pre></pre>
<p>写这篇文章的主要目的是梳理和总结，同时也希望能给对这方面有兴趣的 <code>Rustacean</code> 作为参考。本文代码以易于理解为主要编码原则，某些地方并没有太考虑性能，还请见谅；但如果文章和代码中有明显错误，欢迎指正。</p>
<p>本文代码仓库在 <a href="https://github.com/Hexilee/async-io-demo">Github</a> （部分代码较长，建议 <code>clone</code> 下来用编辑器看），所有 <code>examples</code> 在 <code>nightly-x86_64-apple-darwin 2018 Edition</code> 上均能正常运行。运行 <code>example/async-echo</code>  时设置 <code>RUST_LOG</code> 为 <code>info</code> 可以在 terminal 看到基本的运行信息，<code>debug</code> 则可见事件循环中的事件触发顺序。</p>
<h3 id="异步-io-的基石---mio"><a class="header" href="#异步-io-的基石---mio">异步 <code>IO</code> 的基石 - <code>mio</code></a></h3>
<p><code>mio</code> 是一个极简的底层异步 <code>IO</code> 库，如今 <code>rust</code> 生态中几乎所有的异步 <code>IO</code> 程序都基于它。</p>
<p>随着 <code>channel</code>, <code>timer</code> 等 <code>sub module</code> 在 <code>0.6.5</code> 版本被标为 <code>deprecated</code>，如今的 mio 提供的唯二两个核心功能分别是：</p>
<ul>
<li>对操作系统异步网络 <code>IO</code> 的封装</li>
<li>用户自定义事件队列</li>
</ul>
<p>第一个核心功能对应到不同操作系统分别是</p>
<ul>
<li><code>Linux(Android) =&gt; epoll</code></li>
<li><code>Windows =&gt; iocp</code></li>
<li><code>MacOS(iOS), FreeBSD =&gt; kqueue</code> </li>
<li><code>Fuchsia =&gt; &lt;unknown&gt;</code></li>
</ul>
<p>mio 把这些不同平台上的 API 封装出了一套 <code>epoll like</code> 的异步网络 API，支持 <code>udp 和 tcp</code>。</p>
<blockquote>
<p>除此之外还封装了一些不同平台的拓展 API，比如 <code>uds</code>，本文不对这些 API 做介绍。</p>
</blockquote>
<h4 id="异步网络-io"><a class="header" href="#异步网络-io">异步网络 IO</a></h4>
<p>下面是一个 <code>tcp</code> 的 <code>demo</code></p>
<pre><pre class="playground"><code class="language-rust">// examples/tcp.rs

use mio::*;
use mio::net::{TcpListener, TcpStream};
use std::io::{Read, Write, self};
use failure::Error;
use std::time::{Duration, Instant};

const SERVER_ACCEPT: Token = Token(0);
const SERVER: Token = Token(1);
const CLIENT: Token = Token(2);
const SERVER_HELLO: &amp;[u8] = b&quot;PING&quot;;
const CLIENT_HELLO: &amp;[u8] = b&quot;PONG&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let addr = &quot;127.0.0.1:13265&quot;.parse()?;

// Setup the server socket
    let server = TcpListener::bind(&amp;addr)?;

// Create a poll instance
    let poll = Poll::new()?;

// Start listening for incoming connections
    poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge())?;

// Setup the client socket
    let mut client = TcpStream::connect(&amp;addr)?;

    let mut server_handler = None;

// Register the client
    poll.register(&amp;client, CLIENT, Ready::readable() | Ready::writable(),
                  PollOpt::edge())?;

// Create storage for events
    let mut events = Events::with_capacity(1024);

    let start = Instant::now();
    let timeout = Duration::from_millis(10);
    'top: loop {
        poll.poll(&amp;mut events, None)?;
        for event in events.iter() {
            if start.elapsed() &gt;= timeout {
                break 'top
            }
            match event.token() {
                SERVER_ACCEPT =&gt; {
                    let (handler, addr) = server.accept()?;
                    println!(&quot;accept from addr: {}&quot;, &amp;addr);
                    poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
                    server_handler = Some(handler);
                }

                SERVER =&gt; {
                    if event.readiness().is_writable() {
                        if let Some(ref mut handler) = &amp;mut server_handler {
                            match handler.write(SERVER_HELLO) {
                                Ok(_) =&gt; {
                                    println!(&quot;server wrote&quot;);
                                }
                                Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                                err =&gt; {
                                    err?;
                                }
                            }
                        }
                    }
                    if event.readiness().is_readable() {
                        let mut hello = [0; 4];
                        if let Some(ref mut handler) = &amp;mut server_handler {
                            match handler.read_exact(&amp;mut hello) {
                                Ok(_) =&gt; {
                                    assert_eq!(CLIENT_HELLO, &amp;hello);
                                    println!(&quot;server received&quot;);
                                }
                                Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                                err =&gt; {
                                    err?;
                                }
                            }
                        }
                    }
                }
                CLIENT =&gt; {
                    if event.readiness().is_writable() {
                        match client.write(CLIENT_HELLO) {
                            Ok(_) =&gt; {
                                println!(&quot;client wrote&quot;);
                            }
                            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                            err =&gt; {
                                err?;
                            }
                        }
                    }
                    if event.readiness().is_readable() {
                        let mut hello = [0; 4];
                        match client.read_exact(&amp;mut hello) {
                            Ok(_) =&gt; {
                                assert_eq!(SERVER_HELLO, &amp;hello);
                                println!(&quot;client received&quot;);
                            }
                            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                            err =&gt; {
                                err?;
                            }
                        }
                    }
                }
                _ =&gt; unreachable!(),
            }
        }
    };
    Ok(())
}
</code></pre></pre>
<p>这个 <code>demo</code> 稍微有点长，接下来我们把它一步步分解。</p>
<p>直接看主循环</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ...
    loop {
        poll.poll(&amp;mut events, None).unwrap();
        // ...
    }
}
</code></pre></pre>
<p>每次循环都得执行 <code>poll.poll</code>，第一个参数是用来存 <code>events</code> 的 <code>Events</code>， 容量是 <code>1024</code>；</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut events = Events::with_capacity(1024);
<span class="boring">}
</span></code></pre></pre>
<p>第二个参数是 <code>timeout</code>，即一个 <code>Option&lt;Duration&gt;</code>，超时会直接返回。返回类型是 <code>io::Result&lt;usize&gt;</code>。</p>
<blockquote>
<p>其中的 <code>usize</code> 代表 <code>events</code> 的数量，这个返回值是 <code>deprecated</code> 并且会在之后的版本移除，仅供参考</p>
</blockquote>
<p>这里我们设置了 <code>timeout = None</code>，所以当这个函数返回时，必然是某些事件被触发了。让我们遍历 <code>events</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  match event.token() {
      SERVER_ACCEPT =&gt; {
          let (handler, addr) = server.accept()?;
          println!(&quot;accept from addr: {}&quot;, &amp;addr);
          poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
          server_handler = Some(handler);
      }

      SERVER =&gt; {
          if event.readiness().is_writable() {
              if let Some(ref mut handler) = &amp;mut server_handler {
                  match handler.write(SERVER_HELLO) {
                      Ok(_) =&gt; {
                          println!(&quot;server wrote&quot;);
                      }
                      Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                      err =&gt; {
                          err?;
                      }
                  }
              }
          }
          if event.readiness().is_readable() {
              let mut hello = [0; 4];
              if let Some(ref mut handler) = &amp;mut server_handler {
                  match handler.read_exact(&amp;mut hello) {
                      Ok(_) =&gt; {
                          assert_eq!(CLIENT_HELLO, &amp;hello);
                          println!(&quot;server received&quot;);
                      }
                      Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                      err =&gt; {
                          err?;
                      }
                  }
              }
          }
      }
      CLIENT =&gt; {
          if event.readiness().is_writable() {
              match client.write(CLIENT_HELLO) {
                  Ok(_) =&gt; {
                      println!(&quot;client wrote&quot;);
                  }
                  Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                  err =&gt; {
                      err?;
                  }
              }
          }
          if event.readiness().is_readable() {
              let mut hello = [0; 4];
              match client.read_exact(&amp;mut hello) {
                  Ok(_) =&gt; {
                      assert_eq!(SERVER_HELLO, &amp;hello);
                      println!(&quot;client received&quot;);
                  }
                  Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                  err =&gt; {
                      err?;
                  }
              }
          }
      }
      _ =&gt; unreachable!(),
  }
<span class="boring">}
</span></code></pre></pre>
<p>我们匹配每一个 <code>event</code> 的 <code>token</code>，这里的 <code>token</code> 就是我用来注册的那些 <code>token</code>。比如我在上面注册了 <code>server</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start listening for incoming connections
poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge()).unwrap();

<span class="boring">}
</span></code></pre></pre>
<p>第二个参数就是 <code>token</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SERVER_ACCEPT: Token = Token(0);
<span class="boring">}
</span></code></pre></pre>
<p>这样当 <code>event.token() == SERVER_ACCEPT</code> 时，就说明这个事件跟我们注册的 <code>server</code> 有关，于是我们试图 <code>accept</code> 一个新的连接并把它注册进 <code>poll</code>，使用的 <code>token</code> 是 <code>SERVER</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (handler, addr) = server.accept()?;
println!(&quot;accept from addr: {}&quot;, &amp;addr);
poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
server_handler = Some(handler);
<span class="boring">}
</span></code></pre></pre>
<p>这样我们之后如果发现 <code>event.token() == SERVER</code>，我们就认为它和注册的 <code>handler</code> 有关：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if event.readiness().is_writable() {
    if let Some(ref mut handler) = &amp;mut server_handler {
        match handler.write(SERVER_HELLO) {
            Ok(_) =&gt; {
                println!(&quot;server wrote&quot;);
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
            err =&gt; {
                err?;
            }
        }
    }
}
if event.readiness().is_readable() {
    let mut hello = [0; 4];
    if let Some(ref mut handler) = &amp;mut server_handler {
        match handler.read_exact(&amp;mut hello) {
            Ok(_) =&gt; {
                assert_eq!(CLIENT_HELLO, &amp;hello);
                println!(&quot;server received&quot;);
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
            err =&gt; {
                err?;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这时候我们还需要判断 <code>event.readiness()</code>，这就是 <code>register</code> 函数的第三个参数，叫做 <code>interest</code>，顾名思义，就是“感兴趣的事”。它的类型是 <code>Ready</code>，一共四种，<code>readable, writable, error 和 hup</code>，可进行并运算。</p>
<p>在上面我们给 <code>handler</code> 注册了 <code>Ready::readable() | Ready::writable()</code>，所以 <code>event</code> 可能是 <code>readable</code> 也可能是 <code>writable</code>，所以我们要经过判断来执行相应的逻辑。注意这里的判断是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ... {
    ...
}

if ... {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>而非</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ... {
    ...
} else if ... {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>因为一个事件可能同时是 <code>readable</code> 和 <code>writable</code>。</p>
<h4 id="容错性原则"><a class="header" href="#容错性原则">容错性原则</a></h4>
<p>大概逻辑先讲到这儿，这里先讲一下 <code>mio</code> 的“容错性原则”，即不能完全相信 <code>event</code>。</p>
<p>可以看到我上面有一段代码是这么写的 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match event.token() {
     SERVER_ACCEPT =&gt; {
         let (handler, addr) = server.accept()?;
         println!(&quot;accept from addr: {}&quot;, &amp;addr);
         poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
         server_handler = Some(handler);
     }
<span class="boring">}
</span></code></pre></pre>
<p><code>server.accept()</code> 返回的是 <code>io::Result&lt;(TcpStream, SocketAddr)&gt;</code>。如果我们选择完全相信 <code>event</code> 的话，在这里 <code>unwrap()</code> 并没有太大问题 —— 如果真的有一个新的连接就绪，<code>accept()</code> 产生的 <code>io::Result</code> 是我们无法预料且无法处理的，我们应该抛给调用者或者直接 <code>panic</code>。</p>
<p>但问题就是，我们可以认为 <code>event</code> 的伪消息是可预料的，可能并没有一个新的连接准备就绪，这时候我们 <code>accept()</code> 会引发 <code>WouldBlock Error</code>。但我们不应该认为 <code>WouldBlock</code> 是一种错误 —— 这是一种友善的提醒。<code>server</code> 告诉我们：“并没有新的连接，请下次再来吧。”，所以在这里我们应该忽略（可以打个 <code>log</code>）它并重新进入循环。</p>
<p>像我后面写的那样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.write(CLIENT_HELLO) {
   Ok(_) =&gt; {
       println!(&quot;client wrote&quot;);
   }
   Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
   err =&gt; {
       err?;
   }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="poll-option"><a class="header" href="#poll-option">Poll Option</a></h4>
<p>好了，现在我们可以运行：</p>
<pre><code class="language-bash">[async-io-demo] cargo run --example tcp
</code></pre>
<p>terminal 里打印出了</p>
<pre><code class="language-bash">client wrote
accept from addr: 127.0.0.1:53205
client wrote
server wrote
server received
...
</code></pre>
<p>我们可以发现，在短短的 <code>10 millis</code> 内（<code>let timeout = Duration::from_millis(10);</code>），<code>server</code> 和 <code>client</code> 分别进行了数十次的读写！</p>
<p>如果我们不想进行这么多次读写呢？比如，我们只想让 <code>server</code> 写一次。在网络比较通畅的情况下，<code>client</code> 和 <code>server</code> 几乎一直是可写的，所以 <code>Poll::poll</code> 在数微秒内就返回了。</p>
<p>这时候就要看 <code>register</code> 的第四个参数了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge()).unwrap();

<span class="boring">}
</span></code></pre></pre>
<p><code>PollOpt::edge()</code> 的类型是 <code>PollOpt</code>，一共有 <code>level, edge, oneshot</code> 三种，他们有什么区别呢？</p>
<p>比如在我上面的代码里，</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if event.readiness().is_readable() {
    let mut hello = [0; 4];
    match client.read_exact(&amp;mut hello) {
        Ok(_) =&gt; {
            assert_eq!(SERVER_HELLO, &amp;hello);
            println!(&quot;client received&quot;);
        }
        Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
        err =&gt; {
            err?;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我在收到一个 <code>readable readiness</code> 时，只读了四个字节。如果这时候缓冲区里有八字节的数据，那么：</p>
<ul>
<li>如果我注册时使用 <code>PollOpt::level()</code>，我在下次 <code>poll</code> 时 <strong>一定</strong> 还能收到一次 <code>readable readiness event</code> （只要我没有主动执行 <code>set_readiness(Read::empty())</code>）；</li>
<li>如果我注册时使用 <code>PollOpt::edge()</code>，我在下次 <code>poll</code> 时 <strong>不一定</strong> 还能收到一次 <code>readable readiness event</code>；</li>
</ul>
<p>所以，使用 <code>PollOpt::edge()</code> 时有一个“排尽原则（<code>Draining readiness</code>）”，即每次触发 <code>event</code> 时一定要操作到资源耗尽返回 <code>WouldBlock</code>，即上面的代码要改成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if event.readiness().is_readable() {
    let mut hello = [0; 4];
    loop {
        match client.read_exact(&amp;mut hello) {
            Ok(_) =&gt; {
                assert_eq!(SERVER_HELLO, &amp;hello);
                println!(&quot;client received&quot;);
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; break,
            err =&gt; {
                err?;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>那么，<code>oneshot</code> 又是怎样的行为呢？让我们回到上面的问题，如果我们只想让 <code>handler</code> 写一次，怎么办 —— 注册时使用 <code>PollOpt::oneshot()</code>，即</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (handler, addr) = server.accept()?;
println!(&quot;accept from addr: {}&quot;, &amp;addr);
poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::oneshot())?;
server_handler = Some(handler);
<span class="boring">}
</span></code></pre></pre>
<p>这样的话，你只能收到一次 <code>SERVER</code> 事件，除非你使用 <code>Poll::reregister</code> 重新注册 <code>handler</code>。</p>
<blockquote>
<p><code>Poll::reregister</code> 可以更改 <code>PollOpt</code> 和 <code>interest</code></p>
</blockquote>
<h4 id="still-block"><a class="header" href="#still-block">Still Block</a></h4>
<p>其实上面这个 <code>demo</code> 还存在一个问题，即我们在回调代码块中使用了同步的 <code>IO</code> 操作 <code>println!</code>。我们要尽可能避免在回调的代码块里使用耗时的 <code>IO</code> 操作。</p>
<p>考虑到文件 <code>IO</code> (包括 <code>Stdin, Stdout, Stderr</code>) 速度很慢，我们只需要把所有的文件 <code>IO</code> 交给一个线程进行即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::{Sender, Receiver, channel, SendError};

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

impl Fs {
    pub fn new() -&gt; Self {
        let (sender, receiver) = channel();
        std::thread::spawn(move || {
            loop {
                match receiver.recv() {
                    Ok(task) =&gt; {
                        match task {
                            Task::Println(ref string) =&gt; println!(&quot;{}&quot;, string),
                            Task::Exit =&gt; return
                        }
                    },
                    Err(_) =&gt; {
                        return;
                    }
                }
            }
        });
        Fs { task_sender: sender }
    }

    pub fn println(&amp;self, string: String) {
        self.task_sender.send(Task::Println(string)).unwrap()
    }
}

pub enum Task {
    Exit,
    Println(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>之后，可以使用 <code>Fs::println</code> 替换所有的 <code>println!</code>。</p>
<h4 id="自定义事件"><a class="header" href="#自定义事件">自定义事件</a></h4>
<p>上面我们实现异步 <code>println</code> 比较简单，这是因为 <code>println</code> 并没有返回值，不需要进行后续操作。设想一下，如果要我们实现 <code>open</code> 和 <code>ready_to_string</code>，先异步地 <code>open</code> 一个文件，然后异步地 <code>read_to_string</code>，最后再异步地 <code>println</code>, 我们要怎么做？</p>
<p>最简单的写法是回调，像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/fs.rs

use crossbeam_channel::{unbounded, Sender};
use std::fs::File;
use std::io::Read;
use std::boxed::FnBox;
use std::thread;
use failure::Error;

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

pub struct FsHandler {
    io_worker: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
    executor: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
}

pub fn fs_async() -&gt; (Fs, FsHandler) {
    let (task_sender, task_receiver) = unbounded();
    let (result_sender, result_receiver) = unbounded();
    let io_worker = std::thread::spawn(move || {
        loop {
            match task_receiver.recv() {
                Ok(task) =&gt; {
                    match task {
                        Task::Println(ref string) =&gt; println!(&quot;{}&quot;, string),
                        Task::Open(path, callback, fs) =&gt; {
                            result_sender
                                .send(TaskResult::Open(File::open(path)?, callback, fs))?
                        }
                        Task::ReadToString(mut file, callback, fs) =&gt; {
                            let mut value = String::new();
                            file.read_to_string(&amp;mut value)?;
                            result_sender
                                .send(TaskResult::ReadToString(value, callback, fs))?
                        }
                        Task::Exit =&gt; {
                            result_sender
                                .send(TaskResult::Exit)?;
                            break;
                        }
                    }
                }
                Err(_) =&gt; {
                    break;
                }
            }
        }
        Ok(())
    });
    let executor = std::thread::spawn(move || {
        loop {
            let result = result_receiver.recv()?;
            match result {
                TaskResult::ReadToString(value, callback, fs) =&gt; callback.call_box((value, fs))?,
                TaskResult::Open(file, callback, fs) =&gt; callback.call_box((file, fs))?,
                TaskResult::Exit =&gt; break
            };
        };
        Ok(())
    });

    (Fs { task_sender }, FsHandler { io_worker, executor })
}

impl Fs {
    pub fn println(&amp;self, string: String) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Println(string))?)
    }

    pub fn open&lt;F&gt;(&amp;self, path: &amp;str, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::Open(path.to_string(), Box::new(callback), self.clone()))?)
    }

    pub fn read_to_string&lt;F&gt;(&amp;self, file: File, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::ReadToString(file, Box::new(callback), self.clone()))?)
    }

    pub fn close(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Exit)?)
    }
}

impl FsHandler {
    pub fn join(self) -&gt; Result&lt;(), Error&gt; {
        self.io_worker.join().unwrap()?;
        self.executor.join().unwrap()
    }
}

type FileCallback = Box&lt;FnBox(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;
type StringCallback = Box&lt;FnBox(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;

pub enum Task {
    Exit,
    Println(String),
    Open(String, FileCallback, Fs),
    ReadToString(File, StringCallback, Fs),
}

pub enum TaskResult {
    Exit,
    Open(File, FileCallback, Fs),
    ReadToString(String, StringCallback, Fs),
}

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// examples/fs.rs

use asyncio::fs::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = &quot;Hello, World!&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open(&quot;./examples/test.txt&quot;, |file, fs| {
        fs.read_to_string(file, |value, fs| {
            assert_eq!(TEST_FILE_VALUE, &amp;value);
            fs.println(value)?;
            fs.close()
        })
    })?;
    fs_handler.join()?;
    Ok(())
}
</code></pre></pre>
<p>测试</p>
<pre><code class="language-bash">[async-io-demo] cargo run --example fs
</code></pre>
<p>这样写在逻辑上的确是对的，但是负责跑 <code>callback</code> 的 <code>executor</code> 线程其实被负责 <code>io</code> 的线程阻塞住了（<code>result_receiver.recv()</code>）。那我们能不能在 <code>executor</code> 线程里跑一个事件循环，以达到不被 <code>io</code> 线程阻塞的目的呢？（即确定 <code>result_receiver</code> 中有 <code>result</code> 时，<code>executor</code> 才会进行 <code>result_receiver.recv()</code>）.</p>
<p>这就到了体现 <code>mio</code> 强大可拓展性的时候：注册用户态的事件队列。</p>
<p>把上面的代码稍加修改，就成了这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/fs_mio.rs

use crossbeam_channel::{unbounded, Sender, TryRecvError};
use std::fs::File;
use std::io::{Read};
use std::boxed::FnBox;
use std::thread;
use failure::Error;
use std::time::Duration;
use mio::*;

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

pub struct FsHandler {
    io_worker: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
    executor: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
}

const FS_TOKEN: Token = Token(0);

pub fn fs_async() -&gt; (Fs, FsHandler) {
    let (task_sender, task_receiver) = unbounded();
    let (result_sender, result_receiver) = unbounded();
    let poll = Poll::new().unwrap();
    let (registration, set_readiness) = Registration::new2();
    poll.register(&amp;registration, FS_TOKEN, Ready::readable(), PollOpt::oneshot()).unwrap();
    let io_worker = std::thread::spawn(move || {
        loop {
            match task_receiver.recv() {
                Ok(task) =&gt; {
                    match task {
                        Task::Println(ref string) =&gt; println!(&quot;{}&quot;, string),
                        Task::Open(path, callback, fs) =&gt; {
                            result_sender
                                .send(TaskResult::Open(File::open(path)?, callback, fs))?;
                            set_readiness.set_readiness(Ready::readable())?;
                        }
                        Task::ReadToString(mut file, callback, fs) =&gt; {
                            let mut value = String::new();
                            file.read_to_string(&amp;mut value)?;
                            result_sender
                                .send(TaskResult::ReadToString(value, callback, fs))?;
                            set_readiness.set_readiness(Ready::readable())?;
                        }
                        Task::Exit =&gt; {
                            result_sender
                                .send(TaskResult::Exit)?;
                            set_readiness.set_readiness(Ready::readable())?;
                            break;
                        }
                    }
                }
                Err(_) =&gt; {
                    break;
                }
            }
        }
        Ok(())
    });

    let executor = thread::spawn(move || {
        let mut events = Events::with_capacity(1024);
        'outer: loop {
            poll.poll(&amp;mut events, Some(Duration::from_secs(1)))?;
            for event in events.iter() {
                match event.token() {
                    FS_TOKEN =&gt; {
                        loop {
                            match result_receiver.try_recv() {
                                Ok(result) =&gt; {
                                    match result {
                                        TaskResult::ReadToString(value, callback, fs) =&gt; callback.call_box((value, fs))?,
                                        TaskResult::Open(file, callback, fs) =&gt; callback.call_box((file, fs))?,
                                        TaskResult::Exit =&gt; break 'outer
                                    }
                                }
                                Err(e) =&gt; {
                                    match e {
                                        TryRecvError::Empty =&gt; break,
                                        TryRecvError::Disconnected =&gt; Err(e)?
                                    }
                                }
                            }
                        }
                        poll.reregister(&amp;registration, FS_TOKEN, Ready::readable(), PollOpt::oneshot())?;
                    }
                    _ =&gt; unreachable!()
                }
            }
        };
        Ok(())
    });
    (Fs { task_sender }, FsHandler { io_worker, executor })
}

impl Fs {
    pub fn println(&amp;self, string: String) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Println(string))?)
    }

    pub fn open&lt;F&gt;(&amp;self, path: &amp;str, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::Open(path.to_string(), Box::new(callback), self.clone()))?)
    }

    pub fn read_to_string&lt;F&gt;(&amp;self, file: File, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::ReadToString(file, Box::new(callback), self.clone()))?)
    }

    pub fn close(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Exit)?)
    }
}

impl FsHandler {
    pub fn join(self) -&gt; Result&lt;(), Error&gt; {
        self.io_worker.join().unwrap()?;
        self.executor.join().unwrap()
    }
}

type FileCallback = Box&lt;FnBox(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;
type StringCallback = Box&lt;FnBox(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;

pub enum Task {
    Exit,
    Println(String),
    Open(String, FileCallback, Fs),
    ReadToString(File, StringCallback, Fs),
}

pub enum TaskResult {
    Exit,
    Open(File, FileCallback, Fs),
    ReadToString(String, StringCallback, Fs),
}

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// examples/fs-mio.rs

use asyncio::fs_mio::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = &quot;Hello, World!&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open(&quot;./examples/test.txt&quot;, |file, fs| {
        fs.read_to_string(file, |value, fs| {
            assert_eq!(TEST_FILE_VALUE, &amp;value);
            fs.println(value)?;
            fs.close()
        })
    })?;
    fs_handler.join()?;
    Ok(())
}
</code></pre></pre>
<p>可以注意到，上面的代码发生的改变就是，<code>executor</code> 不再被 <code>result_receiver.recv</code> 阻塞，而变成了注册事件（<code>registration</code>）后等待 <code>Poll::poll</code> 返回事件；只有等到了新的事件，才会进行 <code>result_receiver.try_recv</code>。同时，<code>io_worker</code> 线程在 <code>send result</code> 之后会执行 <code>set_readiness.set_readiness(Ready::readable())?;</code>，以通知 <code>executor</code> 线程对相应结果做处理。</p>
<p>这样的话，<code>executor</code> 就不会被 <code>io worker</code> 阻塞了，因为我们可以把所有的事件都注册到 <code>executor</code> 上，<code>mio::Poll</code> 会同时监听多个事件（比如把 <code>fs</code> 和 <code>tcp</code> 结合起来）。</p>
<p>测试</p>
<pre><code class="language-bash">[async-io-demo] cargo run --example fs-mio
</code></pre>
<h4 id="callback-is-evil"><a class="header" href="#callback-is-evil">Callback is evil</a></h4>
<p>既然文件 <code>IO</code> 的 <code>executor</code> 不再会被 <code>io worker</code> 线程阻塞了，那我们来试试让 <code>fs</code> 和 <code>tcp</code>  共用一个 <code>poll</code> 然后建立一个简单的文件服务器吧。</p>
<p>但可以先等等，因为我已经开始觉得写 <code>callback</code> 有点难受了 —— 如果我们还想处理错误的话，会觉得更难受，像这样</p>
<pre><pre class="playground"><code class="language-rust">use asyncio::fs_mio::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = &quot;Hello, World!&quot;;

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open(&quot;./examples/test.txt&quot;, 
        |file, fs| {
            fs.read_to_string(file, 
                |value, fs| {
                    assert_eq!(TEST_FILE_VALUE, &amp;value);
                    fs.println(value, 
                        |err| {
                            ...
                        }
                    );
                    fs.close()
                },
                |err| {
                    ...
                }
            )
        },
        |err| {
            ...
        }
    )?;
    fs_handler.join()?;
    Ok(())
}
</code></pre></pre>
<p>而且对 <code>rust</code> 来说，更加艰难的是闭包中的生命周期问题（闭包几乎不能通过捕获来借用环境变量）。这就意味着，如果我要借用环境中的某个变量，我要么 <code>clone</code> 它（如果它实现了 <code>Clone</code> 的话），要么把它作为闭包参数传入（意味着你要根据需要改每一层回调函数的签名，这太屎了）。</p>
<p>考虑到各种原因，<code>rust</code> 最终选择用 <code>coroutine</code> 作为异步 <code>IO</code> 的 <code>API</code> 抽象。</p>
<h3 id="coroutine"><a class="header" href="#coroutine">coroutine</a></h3>
<p>这里所说的 <code>coroutine</code> 是指基于 <code>rust generator</code> 的 <code>stackless coroutine</code> 而非早期被 <code>rust</code> 抛弃的 <code>green thread(stackful coroutine)</code>。</p>
<h4 id="generator"><a class="header" href="#generator">generator</a></h4>
<p><code>rust</code> 大概在今年五月份引入了 <code>generator</code>，但到现在还是 unstable 的 —— 虽说也没多少人用 stable（误</p>
<p>一个典型的斐波那契 <code>generator</code> 如下</p>
<pre><pre class="playground"><code class="language-rust">// examples/fab.rs

#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = fab(5);
    loop {
        match unsafe { gen.resume() } {
            GeneratorState::Yielded(value) =&gt; println!(&quot;yield {}&quot;, value),
            GeneratorState::Complete(ret) =&gt; {
                println!(&quot;return {}&quot;, ret);
                break;
            }
        }
    }
}

fn fab(mut n: u64) -&gt; impl Generator&lt;Yield=u64, Return=u64&gt; {
    move || {
        let mut last = 0u64;
        let mut current = 1;
        yield last;
        while n &gt; 0 {
            yield current;
            let tmp = last;
            last = current;
            current = tmp + last;
            n -= 1;
        }
        return last;
    }
}
</code></pre></pre>
<p>由于 <code>generator</code> 的“中断特性”，我们很自然的可以想到，如果用 <code>generator</code> 搭配 <code>mio</code>，给每个 <code>generator</code> 分配一个 <code>token</code>，然后 <code>poll mio</code> 的事件循环，收到一个唤醒事件就 <code>resume</code> 相应的 <code>generator</code>；每个 <code>generator</code> 在要阻塞的时候拿自己的 <code>token</code> 注册一个唤醒事件然后 <code>yield</code>，不就实现了“同步代码”的异步 <code>IO</code> 吗？</p>
<p>这样看来原理上来说已经稳了，但 <code>rust</code> 异步 <code>IO</code> 的天空依旧漂浮着两朵乌云。</p>
<h4 id="自引用"><a class="header" href="#自引用">自引用</a></h4>
<p>第一朵乌云和 <code>rust</code> 自身的内存管理机制有关。</p>
<p>如果你写出这样的 <code>generator</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn self_ref_generator() -&gt; impl Generator&lt;Yield=u64, Return=()&gt; {
    || {
        let x: u64 = 1;
        let ref_x: &amp;u64 = &amp;x;
        yield 0;
        yield *ref_x;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>rust</code> 一定会给你抛个错然后告诉你 &quot;borrow may still be in use when generator yields&quot;。编译器没有教你怎么修正可能会让你有些恐慌，去不存在的搜索引擎上查了查，你发现这和 <code>generator</code> 的实现有关。</p>
<p>前文中提到，<code>rust generator</code> 是 <code>stackless</code> 的，即它并不会保留一个完整的栈，而是根据不同的状态保留需要的变量。如果你把上面的代码改成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_ref_generator() -&gt; impl Generator&lt;Yield=u64, Return=()&gt; {
    || {
        let x: u64 = 1;
        let ref_x: &amp;u64 = &amp;x;
        yield *ref_x;
        yield 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在第一次 <code>yield</code> 结束之后，编译器会发现 <code>generator</code> 唯一需要保留的是字面量 <code>0</code>，所以这段代码可以顺利编译通过。但是，对于前面的 <code>generator</code>，第一次 <code>yield</code> 过后，编译器发现你需要同时保留 <code>x</code> 和它的引用 <code>ref_x</code>，这样的话 <code>generator</code> 就会变成类似这样的结构（仅供参考）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SomeGenerator&lt;'a&gt; {
    ...
    SomeState {
        _yield: u64,
        x: u64
        ref_x: &amp;'a u64
    }
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>这就是 <code>rust</code> 中“臭名昭著” 的自引用，下面这段代码会发生什么呢</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        let mut a = A{b: 1, ref_b: None};
		a.ref_b = Some(&amp;a.b);
        a
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>你会发现它编译不过，当然这是很合理的，栈上的 a 变量拷贝出去之后其成员 b 的引用会失效，<code>rust</code>的生命周期机制帮你规避了这个问题。但即使你改成这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::{BorrowMut};

struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn boxed() -&gt; Box&lt;Self&gt; {
        let mut a = Box::new(A{b: 1, ref_b: None});
        let mut_ref: &amp;mut A = a.borrow_mut();
		mut_ref.ref_b = Some(&amp;mut_ref.b);
        a
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样按道理来说是没问题的，因为 a 的实体已经在堆上了，即使你拷贝它在栈上的引用，也不会改变其成员 b 的地址，引用一直是有效的 —— 但问题是，你没法跟编译器解释这事，编译器认为函数里面的 <code>&amp;mut_ref.b</code>只能活到函数结束，这样含有这个引用的 a 自然也不能 move 出来。</p>
<p>那你可能会想，那我就在外面再取引用就好了</p>
<pre><pre class="playground"><code class="language-rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        A{b: 1, ref_b: None}
    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = Some(&amp;a.b);
}
</code></pre></pre>
<p>这样的确没啥毛病，但是，你会发现自引用不仅阻止了 move，还阻止了你对 A 可变引用。。比如这样就编译不过</p>
<pre><pre class="playground"><code class="language-rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        A{b: 1, ref_b: None}
    }

    fn mute(&amp;mut self) {

    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = Some(&amp;a.b);
    a.mute();
}
</code></pre></pre>
<p>但远古的 <code>Future::poll</code> 签名就长这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>而直到现在 <code>Generator::resume</code> 的签名还是这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn resume(&amp;mut self) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这样的话自引用会导致 <code>generator</code> 无法实现 <code>Generator</code> 和 <code>Future</code> </p>
<p>在这种情况下，我们可以使用 <code>NonNull</code>来避过编译器的检查</p>
<pre><pre class="playground"><code class="language-rust">use std::ptr::NonNull;

struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;
}

impl A {
    fn new() -&gt; Self {
        A{b: 1, ref_b: NonNull::dangling()}
    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = NonNull::from(&amp;a.b);
}
</code></pre></pre>
<p>这样的确没有了烦人的生命周期约束，但也意味着你要自己保证内存安全 —— 绝对不能 move，也不能对其可变引用使用 <code>mem::replace</code> 或 <code>mem::swap</code> ，这样非常不妙。</p>
<h4 id="pin"><a class="header" href="#pin">Pin</a></h4>
<p>那有没有办法通过其它方式来保证能保证它不能被 move 或者取可变引用呢？这就是 <code>pin</code>的应用场景了。<code>pin</code>具体的内容可以看这篇 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">RFC</a>，本文只是简要说明一下。</p>
<p><code>rust</code> 默认给大部分类型实现了 <code>trait std::marker::Unpin</code>，这只是一个标记，表示这个类型 move 是安全的，这时候，<code>Pin&lt;'a, T&gt;</code> 跟 <code>&amp;'a mut T</code> 没有区别，你也可以安全地通过 <code>Pin::new(&amp;mut T)</code> 和 <code>Pin::as_mut(self: &amp;mut Pin&lt;T&gt;)</code>相互转换。</p>
<p>但对于不能安全 move 的类型，比如上面的 <code>A</code>，我们得先把它标记为 <code>!Unpin</code>，安全的标记方法是给它一个 <code>!Unpin</code>的成员，比如 <code>Pinned</code>。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(pin)]
use std::marker::{Pinned};

use std::ptr::NonNull;

struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;,
    _pin: Pinned,
}

impl A {
    fn new() -&gt; Self {
        A {
            b: 1,
            ref_b: NonNull::dangling(),
            _pin: Pinned,
        }
    }
}

fn main() {
    let mut a = A::new();
    let mut pinned = unsafe { Pin::new_unchecked(&amp;mut a) };
    let ref_b = NonNull::from(&amp;pinned.b);
    let mut_ref: Pin&lt;&amp;mut A&gt; = pinned.as_mut();
    unsafe {Pin::get_mut_unchecked(mut_ref).ref_b = ref_b};
    let unmoved = pinned;
    assert_eq!(unmoved.ref_b, NonNull::from(&amp;unmoved.b));
}
</code></pre></pre>
<p>从 <code>!Unpin</code> 的类型构建 <code>Pin</code> 总是 <code>unsafe</code> 的，它们通过 <code>Pin::new_unchecked</code> 和 <code>Pin::get_mut_unchecked</code> 相互转换。当然，我们在构建时是可以保证它是 <code>safe</code> ，我们只要完成这两个 <code>unsafe</code>的操作，就可以保证：</p>
<ul>
<li>永远不能 <code>safe</code> 地获得可变引用： <code>Pin::get_mut_unchecked</code> 是 <code>unsafe</code> 的</li>
<li>永远不能 <code>safe</code> 地 move：因为 <code>Pin</code> 只拥有可变引用，且由于<code>Pin::get_mut_unchecked</code> 是 <code>unsafe</code> 的，你不能 <code>safe</code> 地对其可变引用使用 <code>mem::replace</code> 或 <code>mem::swap</code></li>
</ul>
<p>当然，如果你不想在构建时使用 <code>unsafe</code>或者想获得 <code>a</code> 的所有权以便在函数间传递，你可以使用 <code>Box::pinned</code>从而把它分配在堆上</p>
<pre><pre class="playground"><code class="language-rust">struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;,
    _pin: Pinned,
}

impl A {
    fn boxed() -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let mut boxed = Box::pinned(A {
            b: 1,
            ref_b: NonNull::dangling(),
            _pin: Pinned,
        });
        let ref_b = NonNull::from(&amp;boxed.b);
        let mut_ref: Pin&lt;&amp;mut A&gt; = boxed.as_mut();
        unsafe { Pin::get_mut_unchecked(mut_ref).ref_b = ref_b };
        boxed
    }
}

fn main() {
    let boxed = A::boxed();
    let unmoved = boxed;
    assert_eq!(unmoved.ref_b, NonNull::from(&amp;unmoved.b));
}
</code></pre></pre>
<p>有了 <code>Pin</code> 之后，新版 <code>Future</code> 的定义就是这样的了</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, lw: &amp;LocalWaker) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="合理的抽象"><a class="header" href="#合理的抽象">合理的抽象</a></h4>
<p>既然已经打算钦定了 <code>coroutine</code> 作为异步 <code>IO</code> 的 <code>API</code> 抽象，那应该把哪些东西加入标准库、哪些东西加入语法支持、哪些东西交给第三方实现呢？让开发者手动调用 <code>unsafe</code> 的 <code>Generator::resume</code> 终归不是很妙，也不好把 <code>mio</code> 作为唯一的底层异步 <code>IO</code> 实现（如果这样的话不如把 <code>mio</code> 也并入标准库）。</p>
<p>现在的 <code>rust</code> 提供了 <code>async</code> 的语法支持（以前是用过程宏的实现的）、<code>await!</code>的标准库宏支持，标准库 <code>std::future</code> 的 <code>trait Future</code> 和 <code>struct GenFuture</code> ， 标准库 <code>std::task</code> 的  <code>enum Poll&lt;T&gt;, struct LocalWaker, struct Waker </code> 和 <code>trait UnsafeWaker</code>。</p>
<p>你需要给你的 <code>MyWaker</code> 实现 <code>trait UnsafeWaker</code>，用 <code>mio</code> 的话就用 <code>SetReadiness</code>，<code>unsafe fn wake(&amp;self)</code> 用 <code>SetReadiness::set_readiness</code> 实现。然后把 <code>MyWaker</code> 包在 <code>Waker, LocalWaker</code> 里面。</p>
<h5 id="pollt"><a class="header" href="#pollt">Poll&lt;T&gt;</a></h5>
<p><code>Poll&lt;T&gt;</code> 的定义为</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="await"><a class="header" href="#await">await!</a></h5>
<p><code>await!</code> 宏只能在 <code>async</code> 函数或者块里面用，传入一个 <code>Future</code></p>
<p><code>await!(future)</code>会被展开成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    if let Poll::Ready(x) = ::future::poll_with_tls(unsafe{
        Pin::new_unchecked(&amp;mut future)
    }) {
        break x;
    }
    yield
}
<span class="boring">}
</span></code></pre></pre>
<p><code>::future::poll_with_tls</code> 即 <code>thread-local waker</code>，就是你传给这个 <code>GenFuture::poll</code> 的 <code>LocalWaker</code>，</p>
<h5 id="async"><a class="header" href="#async">async</a></h5>
<p><code>async</code>则会把 <code>Generator</code> 包装成 <code>Future(GenFuture)</code> 。</p>
<p><code>GenFuture</code> 的相关定义如下</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GenFuture&lt;T: Generator&lt;Yield = ()&gt;&gt;(T);

impl&lt;T: Generator&lt;Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

impl&lt;T: Generator&lt;Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
    type Output = T::Return;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, lw: &amp;LocalWaker) -&gt; Poll&lt;Self::Output&gt; {
        set_task_waker(lw, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {
            GeneratorState::Yielded(()) =&gt; Poll::Pending,
            GeneratorState::Complete(x) =&gt; Poll::Ready(x),
        })
    }
}

pub fn from_generator&lt;T: Generator&lt;Yield = ()&gt;&gt;(x: T) -&gt; impl Future&lt;Output = T::Return&gt; {
    GenFuture(x)
}
<span class="boring">}
</span></code></pre></pre>
<p>这里可以看到，<code>GenFuture</code> 在每次调用 <code>self.0.resume</code> 之前会 <code>set_task_waker</code>，通过一个 <code>thread_local</code> 的变量中转，从而 <code>generator</code> 里面的 <code>future::poll</code> 能通过 <code>poll_with_tls</code> 拿到这个 <code>LocalWaker</code>。</p>
<p>所以，下面的代码</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn async_recv(string_channel: Receiver&lt;String&gt;) -&gt; String {
    await!(string_channel.recv_future())
}
<span class="boring">}
</span></code></pre></pre>
<p>会被类似地展开为这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn async_recv(string_channel: Receiver&lt;String&gt;) -&gt; impl Future&lt;Output = T::Return&gt; {
	from_generator(move || {
        let recv_future = string_channel.recv_future();
        loop {
            if let Poll::Ready(x) = ::future::poll_with_tls(unsafe{
                Pin::new_unchecked(&amp;mut recv_future)
            }) {
                break x;
            }
            yield
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="non-blocking-coroutine"><a class="header" href="#non-blocking-coroutine">non-blocking coroutine</a></h4>
<p>掌握了上文的基础知识后，我们就可以开始实践了。</p>
<p>coroutine 本身并不意味着“非阻塞”，你完全可以在两次 <code>yield</code> 之间调用阻塞 <code>IO</code> 的 <code>API</code> 从而导致阻塞。 非阻塞的关键在于，在将要阻塞的时候（比如某个 <code>API</code> 返回了 <code>io::ErrorKind::WouldBlock</code>），在 <code>GenFuture::poll</code> 中用底层异步接口注册一个事件和唤醒回调（<code>waker</code>）然后自身休眠（<code>yield</code>），底层异步调度在特定事件发生的时候回调唤醒这个 <code>Future</code>。</p>
<p>下面我参照 <code>romio</code> 的异步调度实现了 <code>Executor</code> <code>block_on, spawn, TcpListener</code> 和 <code>TcpStream</code>，代码较长，建议 <code>clone</code> 后用编辑器看。（请注意区分 <code>Poll(mio::Poll)</code> 与 <code>task::Poll</code> 以及 <code>net::{TcpListener, TcpStream}(mio::net::{TcpListener, TcpStream})</code> 与 <code>TcpListener, TcpStream</code>）</p>
<p><a href="https://github.com/Hexilee/async-io-demo/blob/master/src/executor.rs">src/executor.rs</a></p>
<h5 id="executor"><a class="header" href="#executor">Executor</a></h5>
<p><code>Executor</code> 中包含 <code>mio::Poll</code>，<code>main task waker</code> 及用来管理 <code>task</code> 和 <code>source</code> 的 <code>Slab</code> 各一个。其本身并没有实现什么特别的方法，主要是初始化为 <code>thread_local</code> 的 <code>EXECUTOR</code> 供其它函数借用。</p>
<h5 id="block_on"><a class="header" href="#block_on">block_on</a></h5>
<p><code>block_on</code> 函数会阻塞当前线程，传入参数是一个 <code>future: Future&lt;Output=T&gt;</code>，被称为 <code>main task</code>；返回值类型是 <code>T</code>。该函数一般在最外层被调用。</p>
<p><code>block_on</code> 会引用 <code>thread_local EXECUTOR</code>，主要逻辑是调用 <code>mio::Poll::poll</code> 来响应事件。<code>block_on</code> 把 <code>0 - MAX_RESOURCE_NUM(1 &lt;&lt; 31)</code> 个 <code>Token</code> 分为三类。</p>
<ul>
<li>
<p><code>main task token</code></p>
<p>收到 <code>Token</code> 为 <code>MAIN_TASK_TOKEN</code> 的事件即表示需要唤醒 <code>main task</code>，执行 <code>main_task.poll</code>，返回 <code>task::Poll::Ready(T)</code> 则 <code>block_on</code> 函数返回。</p>
</li>
<li>
<p><code>task token</code></p>
<p>奇数 <code>token</code> 表示由 <code>spawn</code> 函数分发的其它任务需要被唤醒，执行相应的 <code>task.poll</code>，<code>token</code> 和该事件在 <code>EXECUTOR.tasks</code> 中的 <code>index</code> 一一映射。</p>
</li>
<li>
<p><code>source token</code></p>
<p>偶数 <code>token</code> 表示由 <code>register_source</code> 函数注册的 <code>source</code>需要被分发，执行相应 <code>source</code> 的 <code>waker()</code> 以唤醒分发它们的 <code>task</code>。</p>
</li>
</ul>
<h5 id="spawn"><a class="header" href="#spawn">spawn</a></h5>
<p>分发任务</p>
<h5 id="tcplistener"><a class="header" href="#tcplistener">TcpListener</a></h5>
<p>包装了 <code>mio::net::TcpListener</code>，<code>accept</code> 方法返回一个 <code>Future</code>。</p>
<h5 id="tcpstream"><a class="header" href="#tcpstream">TcpStream</a></h5>
<p>包装了 <code>mio::net::TcpStream</code>, <code>read</code>和 <code>write</code> 方法均返回 <code>Future</code>。</p>
<h5 id="echo-server"><a class="header" href="#echo-server">echo-server</a></h5>
<p>实现了 <code>executor</code> 之后，我们可以就写一个简单的 <code>echo-server</code> 了</p>
<pre><pre class="playground"><code class="language-rust">// examples/async-echo

#![feature(async_await)]
#![feature(await_macro)]

#[macro_use]
extern crate log;

use asyncio::executor::{block_on, spawn, TcpListener};
use failure::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    env_logger::init();
    block_on(
        async {
            let mut listener = TcpListener::bind(&amp;&quot;127.0.0.1:7878&quot;.parse()?)?;
            info!(&quot;Listening on 127.0.0.1:7878&quot;);
            while let Ok((mut stream, addr)) = await!(listener.accept()) {
                info!(&quot;connection from {}&quot;, addr);
                spawn(
                    async move {
                        let client_hello = await!(stream.read())?;
                        let read_length = client_hello.len();
                        let write_length =
                            await!(stream.write(client_hello))?;
                        assert_eq!(read_length, write_length);
                        stream.close();
                        Ok(())
                    },
                )?;
            };
            Ok(())
        },
    )?
}

</code></pre></pre>
<pre><code class="language-bash">RUST_LOG=info cargo run --example async-echo
</code></pre>
<p>可以用 <code>telnet</code> 连上试试看。</p>
<h3 id="后记"><a class="header" href="#后记">后记</a></h3>
<p>当然最后还留了一个 demo，就是把文件 <code>IO</code> 也封装为 <code>coroutine</code> 的非阻塞 <code>IO</code>，实现在 <code>src/fs_future.rs</code> 中，这时可以运行本文开头给的 example 了。</p>
<pre><code class="language-bash">RUST_LOG=info cargo run --example file-server
</code></pre>
<p>用 <code>telnet</code> 测试</p>
<pre><code class="language-bash">[~] telnet 127.0.0.1 7878                                                                  
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Please enter filename: examples/test.txt
Hello, World!
Connection closed by foreign host.
</code></pre>
<p>读者有兴趣的话可以看一下 <a href="https://github.com/Hexilee/async-io-demo/blob/master/src/fs_future.rs">src/fs_future.rs</a> 中的实现，这里就不细说，接下来我们再谈谈现在 <code>coroutine API</code> 的不足。</p>
<p>我目前发现的主要问题就是不能在 <code>Future::poll</code> 中使用 <code>try</code>，导致出现 <code>Result</code> 的地方只能 <code>match</code>，希望之后会有比较好的解决方案（比如给 <code>task::Poll&lt;Result&lt;R, E&gt;&gt;</code> 实现 <code>Try</code>）。</p>
<p>第二个问题是 <code>Waker</code> 最里面装的是 <code>UnsafeWaker</code>的 <code>NonNull</code> 指针，当然我能理解 <code>rust</code> 团队有性能等其它方面的考虑，但如果用 <code>mio</code> 的 <code>set_readiness</code> 封装出 <code>MyWaker</code> 的话，<code>clone</code> 完全不需要 <code>NonNull</code>，而且我在实际编码时因为这个出过空指针错误。。希望以后能提供一个更安全的选择。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../lang/rust/06-Rust中的Arenas.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../lang/rust/08-图解Rust所有权与生命周期.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../lang/rust/06-Rust中的Arenas.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../lang/rust/08-图解Rust所有权与生命周期.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
