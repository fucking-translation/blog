<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust中的宏: 带有示例的教程 - Blog Translation</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../../theme/ferris.css">
                <link rel="stylesheet" href="../../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html" class="active"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li><li class="chapter-item "><a href="../../lang/rust/20-rust如何实现线程安全.html"><strong aria-hidden="true">1.20.</strong> Rust 如何实现线程安全</a></li><li class="chapter-item "><a href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html"><strong aria-hidden="true">1.21.</strong> 无需 fork Clippy 就可以编写 Rust lint</a></li><li class="chapter-item "><a href="../../lang/rust/23-使用Mio编写底层TCP服务器.html"><strong aria-hidden="true">1.22.</strong> 使用 Mio 编写底层 TCP 服务器</a></li><li class="chapter-item "><a href="../../lang/rust/24-UnsafeRust的取舍.html"><strong aria-hidden="true">1.23.</strong> 「转」Unsafe Rust 的取舍</a></li><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.24.</strong> 标准库</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.24.1.</strong> std::pin</a></li><li class="chapter-item "><a href="../../lang/rust/std/21-std-condvar.html"><strong aria-hidden="true">1.24.2.</strong> std::sync::Condvar</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li><li class="chapter-item "><a href="../../oci/summary.html"><strong aria-hidden="true">3.</strong> Open Container Initiative</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../oci/01-oci-spec-overview.html"><strong aria-hidden="true">3.1.</strong> OCI 规范概述</a></li></ol></li><li class="chapter-item "><a href="../../网络协议/summary.html"><strong aria-hidden="true">4.</strong> 网络协议</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../网络协议/kcp/详解KCP协议的原理和实现.html"><strong aria-hidden="true">4.1.</strong> 「转」详解 KCP 协议的原理和实现</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-中的宏带有示例的教程"><a class="header" href="#rust-中的宏带有示例的教程">Rust 中的宏：带有示例的教程</a></h1>
<p><a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/">原文</a></p>
<p><img src="./img/macro_in_rust.webp" alt="macro in rust" /></p>
</br>
<p>在本篇教程中，我们将介绍有关 Rust 宏的全部内容，包括 Rust 中宏的引入以及在示例中演示如何使用 Rust 宏。</p>
<p>我们将包含一下内容：</p>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-Rust-%E4%B8%AD%E7%9A%84%E5%AE%8F%EF%BC%9F">什么是 Rust 中的宏？</a></li>
<li><a href="#Rust-%E5%AE%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">Rust 宏的类型</a></li>
<li><a href="#Rust-%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F">Rust 中的声明式宏</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F">创建声明式宏</a></li>
<li><a href="#Rust-%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E8%A7%A3%E6%9E%90">Rust 中声明式宏的高级解析</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E6%AE%B5">解析结构体的名称和字段</a></li>
<li><a href="#%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E8%A7%A3%E6%9E%90%E5%85%83%E6%95%B0%E6%8D%AE">从结构体中解析元数据</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%8F%E7%9A%84%E9%99%90%E5%88%B6">声明式宏的限制</a></li>
</ul>
</li>
<li><a href="#Rust-%E4%B8%AD%E7%9A%84%E8%BF%87%E7%A8%8B%E5%AE%8F">Rust 中的过程宏</a>
<ul>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%BC%8F%E5%AE%8F">属性式宏</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E5%AE%8F">自定义派生宏</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%AE%8F">函数式宏</a></li>
</ul>
</li>
</ul>
<h2 id="什么是-rust-中的宏"><a class="header" href="#什么是-rust-中的宏">什么是 Rust 中的宏？</a></h2>
<p>Rust 对宏提供了出色的支持。使用宏可以编写代码，该代码可以在编译期间生成其他的代码，这被称为元编程。</p>
<p>宏提供了类似于函数的功能，却没有运行时成本。但是，由于在编译期间扩展了宏，因此存在一些编译时的开销。</p>
<p>Rust 的宏与 C 中的宏有很大的不同。Rust 宏可以应用于 token 树，但是 C 宏只能用于文本替换 (substitution)。</p>
<h2 id="rust-宏的类型"><a class="header" href="#rust-宏的类型">Rust 宏的类型</a></h2>
<p>Rust 宏有两种类型：</p>
<ol>
<li><strong>声明式宏</strong>：使你能够编写类似于在 Rust 代码中作为参数运行的 match 表达式。它使用你提供的代码生成可以替换宏调用的代码。</li>
<li><strong>过程宏</strong>：使你能够在 Rust 代码的抽象语法树 (AST) 上进行操作。过程宏是从一个(或两个)<code>TokenStream</code>到另一个<code>TokenStream</code>的函数，其输出替换宏调用。</li>
</ol>
<p>让我们深入学习声明式宏与过程宏，并探讨一些示例，学习如何在 Rust 中使用宏。</p>
<h2 id="rust-中的声明式宏"><a class="header" href="#rust-中的声明式宏">Rust 中的声明式宏</a></h2>
<p>声明式宏通过<code>macro_rules!</code>来定义。声明式宏的功能性稍微差一些，但是提供了易于使用的接口来创建宏以移除重复的代码。常见的声明式宏如<code>println!</code>。声明式宏提供了类似 match 的接口，在匹配时，宏会被替换为对应的匹配分支内的代码。</p>
<h3 id="创建声明式宏"><a class="header" href="#创建声明式宏">创建声明式宏</a></h3>
<pre><pre class="playground"><code class="language-rust">// use macro_rules! &lt;name of macro&gt;{&lt;Body&gt;}
macro_rules! add{
 // macth like arm for macro
    ($a:expr,$b:expr)=&gt;{
 // macro expand to this code
        {
// $a and $b will be templated using the value/variable provided to macro
            $a+$b
        }
    }
}

fn main(){
 // call to macro, $a=1 and $b=2
    add!(1,2);
}
</code></pre></pre>
<p>这段代码创建了一个可以将两个数相加的宏。<code>[macro_rules!]</code>与宏的名称，<code>add</code>以及宏的主体一起使用。</p>
<p>这个宏并没有将两个数相加，它只是将自己替换成了将两个数相加的代码。宏的每一个分支都携带了对应功能需要的参数，并且有多种类型可以分配给参数。如果<code>add</code>函数也可以采用单个参数，我们可以添加另一个分支：</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add{
 // first arm match add!(1,2), add!(2,3) etc
    ($a:expr,$b:expr)=&gt;{
        {
            $a+$b
        }
    };
// Second arm macth add!(1), add!(2) etc
    ($a:expr)=&gt;{
        {
            $a
        }
    }
}

fn main(){
// call the macro
    let x=0;
    add!(1,2);
    add!(x);
}
</code></pre></pre>
<p>一个宏中可以有多个分支，可以根据不同的参数扩展为不同的代码。每个分支可以采用多个参数，以<code>$</code>符号开头，后跟 token 的类型。</p>
<ul>
<li><code>item</code> - 项，如：函数，结构体，模块等</li>
<li><code>block</code> - 块 (语句或表达式的代码块，被大括号包含)</li>
<li><code>stmt</code> - 语句</li>
<li><code>pat</code> - 模式</li>
<li><code>expr</code> - 表达式</li>
<li><code>ty</code> - 类型</li>
<li><code>ident</code> - 标识符</li>
<li><code>path</code> - 路径(如：<code>foo</code>，<code>::std::mem::replace</code>，<code>transmute::&lt;_, int&gt;</code>，...)</li>
<li><code>meta</code> - 元项 (meta item)，即<code>#[...]</code>和<code>#![...]</code>属性中的内容</li>
<li><code>tt</code> - 单个 token 树</li>
<li><code>vis</code> - 可能为空的可见性 (Visibility) 限定词</li>
<li><code>lifetime</code> - 生命周期</li>
<li><code>literal</code> - 字面量表达式</li>
</ul>
<p>在本例中，我们使用 token 类型为<code>ty</code>的<code>$typ</code>参数作为数据类型，如<code>u8</code>，<code>u16</code>等。在数字相加之前，这个宏会将其转换为指定的类型。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add_as{
// using a ty token type for macthing datatypes passed to maccro
    ($a:expr,$b:expr,$typ:ty)=&gt;{
        $a as $typ + $b as $typ
    }
}

fn main(){
    println!(&quot;{}&quot;,add_as!(0,2,u8));
}
</code></pre></pre>
<p>Rust 宏还支持传入非固定数量的参数。运算符和正则表达式非常类似。<code>*</code>用于 0 个或多个 token 类型，<code>+</code>用于 0 个或 1 个参数。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add_as{
    (
  // repeated block
  $($a:expr)
 // seperator
   ,
// zero or more
   *
   )=&gt;{
       { 
   // to handle the case without any arguments
   0
   // block to be repeated
   $(+$a)*
     }
    }
}

fn main(){
    println!(&quot;{}&quot;,add_as!(1,2,3,4)); // =&gt; println!(&quot;{}&quot;,{0+1+2+3+4})
}
</code></pre></pre>
<p>重复的 token 类型包含在<code>$()</code>中，后面跟一个分隔符以及一个<code>*</code>或者<code>+</code>，表示 token 将要重复的次数。分隔符用来区分彼此的 token。后面跟<code>*</code>或<code>+</code>的<code>$()</code>用于表示重复的代码块。在上面的示例中，<code>+$a</code>是需要重复的代码。</p>
<p>如果你仔细看这段代码，你会发现代码中添加了一个额外的 0 来使语法有效。要删除这个 0 并使<code>add</code>表达式和参数一样，我们需要创建一个名为 <a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html">TT muncher</a> 的新宏。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! add{
 // first arm in case of single argument and last remaining variable/number
    ($a:expr)=&gt;{
        $a
    };
// second arm in case of two arument are passed and stop recursion in case of odd number ofarguments
    ($a:expr,$b:expr)=&gt;{
        {
            $a+$b
        }
    };
// add the number and the result of remaining arguments 
    ($a:expr,$($b:tt)*)=&gt;{
       {
           $a+add!($($b)*)
       }
    }
}

fn main(){
    println!(&quot;{}&quot;,add!(1,2,3,4));
}
</code></pre></pre>
<p>TT muncher 递归式的分别处理每个 token。一次处理一个 token 比较容易。这个宏有三个分支：</p>
<ol>
<li>第一个分支处理传入单个参数的情况</li>
<li>第二个分支处理传入两个参数的情况</li>
<li>第三个分支通过传入剩余的参数再次调用<code>add</code>宏</li>
</ol>
<p>宏参数不需要逗号分隔符。多个 token 可以使用不同的 token 类型。举个例子，括号可以与<code>ident</code> token 类型一起使用。Rust 编译器采用匹配的分支，并从参数字符串中提取变量。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ok_or_return{
// match something(q,r,t,6,7,8) etc
// compiler extracts function name and arguments. It injects the values in respective varibles.
    ($a:ident($($b:tt)*))=&gt;{
       {
        match $a($($b)*) {
            Ok(value)=&gt;value,
            Err(err)=&gt;{
                return Err(err);
            }
        }
        }
    };
}

fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{
    if i+j&gt;2 {
        Ok((i,j))
    } else {
        Err(&quot;error&quot;.to_owned())
    }
}

fn main()-&gt;Result&lt;(),String&gt;{
    ok_or_return!(some_work(1,4));
    ok_or_return!(some_work(1,0));
    Ok(())
}
</code></pre></pre>
<p>如果某个操作返回<code>Err</code>或者某个操作的值返回<code>Ok</code>，则<code>ok_or_return</code>宏返回该函数。它将函数作为一个参数并在内部的 match 语句中执行。对于传递给函数的参数，它重复的使用。</p>
<p>通常，需要将几个宏放在同一个宏分组中。在本例中，使用了内部的宏规则。它有助于操作宏输入并编写干净的 TT muncher。</p>
<p>为了创建一个内部规则，添加一个以<code>@</code>开头的规则名作为参数。现在，除非明确将其指定为参数，否则该宏将永远不会匹配内部规则。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ok_or_return{
 // internal rule.
    (@error $a:ident,$($b:tt)* )=&gt;{
        {
        match $a($($b)*) {
            Ok(value)=&gt;value,
            Err(err)=&gt;{
                return Err(err);
            }
        }
        }
    };

// public rule can be called by the user.
    ($a:ident($($b:tt)*))=&gt;{
        ok_or_return!(@error $a,$($b)*)
    };
}

fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{
    if i+j&gt;2 {
        Ok((i,j))
    } else {
        Err(&quot;error&quot;.to_owned())
    }
}

fn main()-&gt;Result&lt;(),String&gt;{
   // instead of round bracket curly brackets can also be used
    ok_or_return!{some_work(1,4)};
    ok_or_return!(some_work(1,0));
    Ok(())
}
</code></pre></pre>
<h3 id="rust-中声明式宏的高级解析"><a class="header" href="#rust-中声明式宏的高级解析">Rust 中声明式宏的高级解析</a></h3>
<p>宏有时会执行需要解析 Rust 语言本身的任务。</p>
<p>将到目前为止我们已经介绍的概念放在一起，创建一个宏，该宏通过使<code>pub</code>关键字作为前缀，将结构体的可见性设置为公开。</p>
<p>首先，我们需要解析 Rust 结构体以获取它的名称，字段以及字段类型。</p>
<h3 id="解析结构体的名称和字段"><a class="header" href="#解析结构体的名称和字段">解析结构体的名称和字段</a></h3>
<p>结构体的声明开头有一个可见性关键字(如<code>pub</code>)，后面跟<code>struct</code>关键字，接着是结构体的名称，最后是结构体的主体。</p>
<p><img src="./img/Parsing-Struct-Name-Field-Diagram.webp" alt="Parsing-Struct-Name-Field-Diagram" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! make_public{
    (
  // use vis type for visibility keyword and ident for struct name
     $vis:vis struct $struct_name:ident { }
    ) =&gt; {
        {
            pub struct $struct_name{ }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>$vis</code>对应可见性，<code>$struct_name</code>对应结构体的名称。为了使结构体是外部可见的，我们需要添加<code>pub</code>关键字并忽略<code>$vis</code>变量。</p>
<p><img src="./img/Make-Struct-Public-with-Keyword.webp" alt="Make-Struct-Public-with-Keyword" /></p>
<p>一个结构体中可能包含多个字段，这些字段可能具有相同或不同的数据类型以及可见性。<code>ty</code> token 类型用于数据类型，<code>vis</code> 用于可见性以及<code>ident</code>用于字段名。我们将使用<code>*</code>来重复表示 0 个或多个字段。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! make_public{
    (
     $vis:vis struct $struct_name:ident {
        $(
 // vis for field visibility, ident for field name and ty for field data type
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*
    }
    ) =&gt; {
        {
            pub struct $struct_name{
                $(
                pub $field_name : $field_type,
                )*
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="从结构体中解析元数据"><a class="header" href="#从结构体中解析元数据">从结构体中解析元数据</a></h3>
<p>通常结构体会有一些附加的元数据或者过程宏，如<code>#[derive(Debug)]</code>。此元数据需要保持不变。解析这个元数据需要使用<code>meta</code>类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! make_public{
    (
     // meta data about struct
     $(#[$meta:meta])* 
     $vis:vis struct $struct_name:ident {
        $(
        // meta data about field
        $(#[$field_meta:meta])*
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*$(,)+
    }
    ) =&gt; {
        { 
            $(#[$meta])*
            pub struct $struct_name{
                $(
                $(#[$field_meta:meta])*
                pub $field_name : $field_type,
                )*
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们的<code>make_public</code>宏已经就绪。为了查看它是如何工作的，我们使用 <a href="https://play.rust-lang.org/">Rust Playground</a> 将宏扩展为已经编译的实际代码。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_public{
    (
     $(#[$meta:meta])* 
     $vis:vis struct $struct_name:ident {
        $(
        $(#[$field_meta:meta])*
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*$(,)+
    }
    ) =&gt; {

            $(#[$meta])*
            pub struct $struct_name{
                $(
                $(#[$field_meta:meta])*
                pub $field_name : $field_type,
                )*
            }
    }
}

fn main(){
    make_public!{
        #[derive(Debug)]
        struct Name{
            n:i64,
            t:i64,
            g:i64,
        }
    }
}
</code></pre></pre>
<p>扩展后的代码如下所示：</p>
<pre><pre class="playground"><code class="language-rust">// some imports

macro_rules! make_public {
    ($ (#[$ meta : meta]) * $ vis : vis struct $ struct_name : ident
     {
         $
         ($ (#[$ field_meta : meta]) * $ field_vis : vis $ field_name : ident
          : $ field_type : ty), * $ (,) +
     }) =&gt;
    {

            $ (#[$ meta]) * pub struct $ struct_name
            {
                $
                ($ (#[$ field_meta : meta]) * pub $ field_name : $
                 field_type,) *
            }
    }
}

fn main() {
        pub struct name {
            pub n: i64,
            pub t: i64,
            pub g: i64,
    }
}
</code></pre></pre>
<h3 id="声明式宏的限制"><a class="header" href="#声明式宏的限制">声明式宏的限制</a></h3>
<p>声明式宏有一些限制。一些与 Rust 宏本身有关，一些是声明式宏所特有的。</p>
<ul>
<li>缺少宏的自动提示与扩展的支持</li>
<li>调试声明式宏非常困难</li>
<li>有限的修改功能</li>
<li>(编译后产生)超大的二进制文件</li>
<li>需要更长的编译时间(声明式宏与过程宏都有这个问题)</li>
</ul>
<h2 id="rust-中的过程宏"><a class="header" href="#rust-中的过程宏">Rust 中的过程宏</a></h2>
<p><a href="https://blog.logrocket.com/procedural-macros-in-rust/">过程宏</a>是宏的更高级的版本。过程宏允许你扩展已存在的 Rust 语法。它接受任意的输入并返回合法的 Rust 代码。</p>
<p>过程宏是一个接受<code>TokenStream</code>作为输入并返回另一个<code>TokenStream</code>作为输出。过程宏操作输入的<code>TokenStream</code>以产生一个输出流。</p>
<p>这里有三种类型的过程宏：</p>
<ol>
<li>属性式宏</li>
<li>派生宏</li>
<li>函数式宏</li>
</ol>
<p>我们将会在下面详细的介绍每一种类型的过程宏。</p>
<h3 id="属性式宏"><a class="header" href="#属性式宏">属性式宏</a></h3>
<p>属性式宏可以让你创建一个依附于某一项的自定义属性，并允许你操作该项。它还可以携带参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[some_attribute_macro(some_argument)]
fn perform_task(){
// some code
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的代码中，<code>some_attribute_macros</code>是一个属性宏，它操作<code>perform_task</code>函数。</p>
<p>为了写一个属性式宏，使用<code>cargo new macro-demo --lib</code>创建一个项目。一旦项目就绪，更新<code>Cargo.toml</code>来告诉项目将要创建一个过程宏。</p>
<pre><code class="language-toml"># Cargo.toml
[lib]
proc-macro = true
</code></pre>
<p>现在我们开始尝试编写过程宏。</p>
<p>过程宏是一个接收<code>TokenStream</code>作为输入，并返回另一个<code>TokenStream</code>的函数。为了编写一个过程宏，我们需要编写一个解析器解析<code>TokenStream</code>。Rust 社区有一个非常棒的库：<a href="https://github.com/dtolnay/syn">syn</a>，用来解析<code>TokenStream</code>。</p>
<p><a href="https://github.com/dtolnay/syn">syn</a> 为 Rust 语法提供了现成的解析器用来解析<code>TokenStream</code>。你也可以通过组合 <a href="https://github.com/dtolnay/syn">syn</a> 提供的更加底层的解析器来解析你的语法。</p>
<p>在<code>Cargo.toml</code>中添加<code>syn</code>和<code>quote</code>：</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
syn = {version=&quot;1.0.57&quot;,features=[&quot;full&quot;,&quot;fold&quot;]}
quote = &quot;1.0.8&quot;
</code></pre>
<p>现在我们可以使用编译器为编写过程宏而提供<code>proc_macro</code>库在<code>lib.rs</code>中编写属性式宏。一个过程宏库不能导出过程宏以外的其他任何东西，并且在 crate 中定义的过程宏不能在该 crate 中使用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
extern crate proc_macro;
use proc_macro::{TokenStream};
use quote::{quote};

// using proc_macro_attribute to declare an attribute like procedural macro
#[proc_macro_attribute]
// _metadata is argument provided to macro call and _input is code to which attribute like macro attaches
pub fn my_custom_attribute(_metadata: TokenStream, _input: TokenStream) -&gt; TokenStream {
    // returing a simple TokenStream for Struct
    TokenStream::from(quote!{struct H{}})
}
<span class="boring">}
</span></code></pre></pre>
<p>为了测试我们添加的宏，通过创建一个名为<code>tests</code>的文件夹并在其中添加<code>attribute_macro.rs</code>文件来创建一个集成测试。在这个文件中，我们测试我们的属性式宏。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/attribute_macro.rs

use macro_demo::*;

// macro converts struct S to struct H
#[my_custom_attribute]
struct S{}

#[test]
fn test_macro(){
// due to macro we have struct H in scope
    let demo=H{};
}
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>cargo test</code>命令运行上面的测试代码。</p>
<p>既然我们理解了过程宏的基本概念，让我们使用<code>syn</code>来操作并解析更高级的<code>TokenStream</code>。</p>
<p>为了学习<code>syn</code>是如何解析并操作<code>TokenStream</code>的，我们以<code>syn</code>的<a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs">Github仓库</a> 的一个示例为例。这个示例创建了一个在值变更时跟踪变量的 Rust 宏。</p>
<p>首先，我们需要弄清楚宏是如何操作它依附的代码的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[trace_vars(a)]
fn do_something(){
  let a=9;
  a=6;
  a=0;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>trace_vars</code>宏传入它需要跟踪的变量名，并且一旦传入的变量<code>a</code>的值发生改变，就会注入了一条打印语句。它跟踪了输入变量的值。</p>
<p>首先，解析属性式宏依附的代码。<code>syn</code>为 Rust 函数语法提供了一个内置的解析器。<code>ItemFn</code>将会解析函数，并且当语法是非法时抛出一个错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn trace_vars(_metadata: TokenStream, input: TokenStream) -&gt; TokenStream {
// parsing rust function to easy to use struct
    let input_fn = parse_macro_input!(input as ItemFn);
    TokenStream::from(quote!{fn dummy(){}})
}
<span class="boring">}
</span></code></pre></pre>
<p>既然我们有了已解析的输入，让我们转到元数据。对于元数据，没有内置的解析器会起作用，因此我们需要使用<code>syn</code>的<code>parse</code>模块编写我们自己的解析器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[trace_vars(a,c,b)] // we need to parse a &quot;,&quot; seperated list of tokens
// code
<span class="boring">}
</span></code></pre></pre>
<p>为了让<code>syn</code>起作用，我们需要实现<code>syn</code>提供的<code>Parse</code>特征。<code>Punctuated</code>被用来创建一个以<code>,</code>分隔的<code>Ident</code>的向量。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Args{
    vars:HashSet&lt;Ident&gt;
}

impl Parse for Args{
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        // parses a,b,c, or a,b,c where a,b and c are Indent
        let vars = Punctuated::&lt;Ident, Token![,]&gt;::parse_terminated(input)?;
        Ok(Args {
            vars: vars.into_iter().collect(),
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一旦我们实现了<code>Parse</code>特征，我们就可以使用<code>parse_macro_input</code>宏来解析元数据了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn trace_vars(metadata: TokenStream, input: TokenStream) -&gt; TokenStream {
    let input_fn = parse_macro_input!(input as ItemFn);
// using newly created struct Args
    let args= parse_macro_input!(metadata as Args);
    TokenStream::from(quote!{fn dummy(){}})
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，当变量的值变更时，我们将修改<code>input_fn</code>以添加<code>println!</code>。为了添加这个功能，我们需要过滤出赋值语句，并在该行之后插入一条打印语句。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Args {
    fn should_print_expr(&amp;self, e: &amp;Expr) -&gt; bool {
        match *e {
            Expr::Path(ref e) =&gt; {
 // variable shouldn't start wiht ::
                if e.path.leading_colon.is_some() {
                    false
// should be a single variable like `x=8` not n::x=0 
                } else if e.path.segments.len() != 1 {
                    false
                } else {
// get the first part
                    let first = e.path.segments.first().unwrap();
// check if the variable name is in the Args.vars hashset
                    self.vars.contains(&amp;first.ident) &amp;&amp; first.arguments.is_empty()
                }
            }
            _ =&gt; false,
        }
    }

// used for checking if to print let i=0 etc or not
    fn should_print_pat(&amp;self, p: &amp;Pat) -&gt; bool {
        match p {
// check if variable name is present in set
            Pat::Ident(ref p) =&gt; self.vars.contains(&amp;p.ident),
            _ =&gt; false,
        }
    }

// manipulate tree to insert print statement
    fn assign_and_print(&amp;mut self, left: Expr, op: &amp;dyn ToTokens, right: Expr) -&gt; Expr {
 // recurive call on right of the assigment statement
        let right = fold::fold_expr(self, right);
// returning manipulated sub-tree
        parse_quote!({
<span class="boring">            left #op #right;
</span>            println!(concat!(stringify!(#left), &quot; = {:?}&quot;), #left);
        })
    }

// manipulating let statement
    fn let_and_print(&amp;mut self, local: Local) -&gt; Stmt {
        let Local { pat, init, .. } = local;
        let init = self.fold_expr(*init.unwrap().1);
// get the variable name of assigned variable
        let ident = match pat {
            Pat::Ident(ref p) =&gt; &amp;p.ident,
            _ =&gt; unreachable!(),
        };
// new sub tree
        parse_quote! {
            let #pat = {
                #[allow(unused_mut)]
                let #pat = #init;
                println!(concat!(stringify!(#ident), &quot; = {:?}&quot;), #ident);
<span class="boring">                ident
</span>            };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的示例中，<code>quote</code>宏用于模版化并编写 Rust。<code>#</code>用来插入变量的值。</p>
<p>现在我们将会对<code>input_fn</code>进行深度优先搜索 (DFS) 并插入一条打印语句。<code>syn</code>提供了一个<code>Fold</code>特征，它可以为任何<code>Item</code>实现 DFS。我们只需要修改与我们要操作的标记类型相对应的特征方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Fold for Args {
    fn fold_expr(&amp;mut self, e: Expr) -&gt; Expr {
        match e {
// for changing assignment like a=5
            Expr::Assign(e) =&gt; {
// check should print
                if self.should_print_expr(&amp;e.left) {
                    self.assign_and_print(*e.left, &amp;e.eq_token, *e.right)
                } else {
// continue with default travesal using default methods
                    Expr::Assign(fold::fold_expr_assign(self, e))
                }
            }
// for changing assigment and operation like a+=1
            Expr::AssignOp(e) =&gt; {
// check should print
                if self.should_print_expr(&amp;e.left) {
                    self.assign_and_print(*e.left, &amp;e.op, *e.right)
                } else {
// continue with default behaviour
                    Expr::AssignOp(fold::fold_expr_assign_op(self, e))
                }
            }
// continue with default behaviour for rest of expressions
            _ =&gt; fold::fold_expr(self, e),
        }
    }

// for let statements like let d=9
    fn fold_stmt(&amp;mut self, s: Stmt) -&gt; Stmt {
        match s {
            Stmt::Local(s) =&gt; {
                if s.init.is_some() &amp;&amp; self.should_print_pat(&amp;s.pat) {
                    self.let_and_print(s)
                } else {
                    Stmt::Local(fold::fold_local(self, s))
                }
            }
            _ =&gt; fold::fold_stmt(self, s),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Fold</code>特征用于对<code>Item</code>进行 DFS。它可以让你对不同的 token 类型执行不同的行为。</p>
<p>现在我们可以使用<code>fold_item_fn</code>在解析的代码中注入打印语句。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn trace_var(args: TokenStream, input: TokenStream) -&gt; TokenStream {
// parse the input
    let input = parse_macro_input!(input as ItemFn);
// parse the arguments
    let mut args = parse_macro_input!(args as Args);
// create the ouput
    let output = args.fold_item_fn(input);
// return the TokenStream
    TokenStream::from(quote!(#output))
}
<span class="boring">}
</span></code></pre></pre>
<p>这个代码示例来自 <a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs">syn examples</a>，这是一个非常出色的学习过程宏的资源。</p>
<h3 id="自定义派生宏"><a class="header" href="#自定义派生宏">自定义派生宏</a></h3>
<p>在 Rust 中自定义派生宏可以自动实现特征。这些宏让你可以通过使用<code>#[derive(Trait)]</code>来实现该特征。</p>
<p><code>syn</code>对派生宏有出色的支持。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Trait)]
struct MyStruct{}
<span class="boring">}
</span></code></pre></pre>
<p>为了在 Rust 中编写自定义派生宏，我们可以使用<code>DeriveInput</code>来解析输入以派生宏。我们也可以使用<code>proc_macro_derive</code>宏来自定义派生宏。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(Trait)]
pub fn derive_trait(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let name = input.ident;

    let expanded = quote! {
        impl Trait for #name {
            fn print(&amp;self) -&gt; usize {
                println!(&quot;{}&quot;,&quot;hello from #name&quot;)
           }
        }
    };

    proc_macro::TokenStream::from(expanded)
}
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>syn</code>可以编写更多高级的派生宏。可以在 <a href="https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs">syn examples</a>中查看本示例。</p>
<h3 id="函数式宏"><a class="header" href="#函数式宏">函数式宏</a></h3>
<p>函数式宏和声明式宏很像，因为它们都通过<code>!</code>进行调用并且看起来都很像函数调用。它们对括号内的代码进行操作。</p>
<p>在 Rust 中，这是如何编写函数式宏的示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro]
pub fn a_proc_macro(_input: TokenStream) -&gt; TokenStream {
    TokenStream::from(quote!(
            fn anwser()-&gt;i32{
                5
            }
))
}
<span class="boring">}
</span></code></pre></pre>
<p>函数式宏不是在运行时执行的，而是在编译时执行的。它们可以用在 Rust 代码中的每一处地方。函数式宏同样接收一个<code>TokenStream</code>并返回一个<code>TokenStream</code>。</p>
<p>使用过程宏的好处包括：</p>
<ul>
<li>使用<code>span</code>更好的进行错误处理</li>
<li>更好的控制输出</li>
<li>社区提供的<code>syn</code>和<code>quote</code></li>
<li>比声明式宏更强大</li>
</ul>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>在 Rust 宏教程中，我们涉及了 Rust 中宏的所有基础概念，定义了声明式宏和过程宏，并学习了如何通过使用各种语法以及社区提供的类库来编写这两种类型的宏。我们还介绍了使用每一种 Rust 宏的优势。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../lang/rust/10-Rust标准库特征指南.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../lang/rust/10-Rust标准库特征指南.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../../theme/ferris.js"></script>
        
        
    </body>
</html>
