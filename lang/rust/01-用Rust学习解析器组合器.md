# 用Rust学习解析器组合器  

#### [原文](https://bodil.lol/parser-combinators/) 

</br>

[1. 初学者的想法](#初学者的想法)  
[2. 如何阅读本文](#如何阅读本文)  
[3. `Xcruciating`标记语言](#Xcruciating标记语言)  
[4. 定义解析器](#定义解析器)  


本文向已是Rust程序员的人们传授解析器组合器的基础知识。它假定不涉及其他知识，并将解释与Rust没有直接关系的所有内容，以及为达到此目的使用Rust的一些令人意外的特性。如果你不了解Rust，他不会教你Rust的内容，但是这样的话，同样也无法更好的教你解析器和组合器的知识。如果你想要学习Rust语言，我推荐  [Rust编程语言](https://doc.rust-lang.org/book/) 这本书。  

## 初学者的想法

&#8195;&#8195;当每个程序员发现自己需要解析器时，它们的生活将变得有意义。  

&#8195;&#8195;初学者程序员将会问：“什么是解析器？”。  
&#8195;&#8195;中级程序员将会说：“这很简单，我将写一串正则表达式”。  
&#8195;&#8195;高级程序员将会说：“退一步考虑问题，我知道`Lex`（词法分析器）和`Yacc`（语法解析器）”  

&#8195;&#8195;初学者的想法是正确的。

&#8195;&#8195;不是说正则表达式不好（但是请不要用正则表达式写复杂的解析器）。使用经过数千年磨练至完美的解析器和词法分析生成器之类的强大工具并不是没有乐趣可言。但是从头开始一点一点学习解析器将更有趣。这两者只是对当前实际问题的抽象，如果你直接选择正则表达式或者解析器生成工具，你将失去这一份乐趣。在初学者眼中，正如人们说的：本来（解决这个问题）有很多种方法，但是在专家眼里，已经形成思维定视，只会选择一种他们最习惯的方式。
&#8195;&#8195;在本文中我们将从头开始学习如何构建解析器，基于被称为解析器组合器的函数式编程语言的通用技术。一旦你掌握了它们的基本概念，它们的优势将非常巨大，同时又非常接近第一原理。因为这里唯一的抽象是你将在基础的组合器之上构建你自己的抽象。所有这些，你必须先构建它们，才能使用它们。

## 如何阅读本文

&#8195;&#8195;强烈建议你初始化一个Rust项目，并且在`src/lib.rs`中书写你阅读到的代码片段（你可以直接从页面上直接复制，但是最好还是自己手敲，因为这样会自动确保你完整阅读代码）。本文将按序介绍你需要的每段代码。请注意，有时会引入你先前编写功能的最新版本，这时，你需要将旧版本替换为新版本。

&#8195;&#8195;该代码是使用2018年语言版本的`rustc`的1.34.0版本编写的。你应该尽可能使用最新版本的编译器，只要你确保你使用的是2018的版本即可（检查`Cargo.toml`文件中是否包含`edition = "2018"`）。代码不需要任何的外部依赖。

&#8195;&#8195;如果要运行本文中的测试用例，请执行`cargo test`。

## `Xcruciating`标记语言

我们将用简化的XML格式写一个解析器，如下所示：

```xml
<parent-element>
  <single-element attribute="value" />
</parent-element>
```

&#8195;&#8195;XML元素使用`<`符号开头和一个由字母组成的标志符开头，后面可以根任意数量的字母，数字和`-`。后面跟一些空格，以及一些属性对的可选列表：前面定义一个标识符，后面跟一个`=`符号和一个双引号字符串，最后以`/>`结尾来表示一个没有子节点的单个元素。或者用`>`表示后面跟了一串子节点，最终是一个以`</`开头的结束标签，后跟一个必须与开始标识匹配的标志符，然后以`>`结束。

&#8195;&#8195;这就是我们将要支持的特性。没有命名空间，没有文本节点，其余的都没有，并且没有模式校验。我们甚至都不会自寻烦恼，去实现字符串的转义引号（`\"`） - 它们由第一个双引号开始，到下一个双引号结束，就是这样。如果你想在实际字符串中使用双引号，你可以将这个不合理的要求转移到其他地方。

&#8195;&#8195;我们将用下面的结构体来解析这些元素。

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String,
    attributes: Vec<(String, String)>,
    children: Vec<Element>,
}
```

&#8195;&#8195;没有花哨的类型，仅仅用字符串表示名称（那是每个标签开始的标志符），用字符串元组表示属性（标志符和对应的值），还有一个看起来和父元素完全一样的子元素列表。

&#8195;&#8195;（如果你正在输入，请加上那一系列的`derive`，你将在后面用到它们）。

## 定义解析器

&#8195;&#8195;好了，是时候编写解析器了。

&#8195;&#8195;解析是从数据流中派生结构的过程。解析器就是要弄清楚该结构的工具。

&#8195;&#8195;在我们即将探索的知识中，解析器最简单的一种形式就是一个函数，该函数接受一些输入并返回解析后的输出以及输入的其余部分，或者是一个错误信息：“我无法解析该输入”。

&#8195;&#8195;事实证明，简而言之，更复杂的解析器看起来也是如此。如果你要获取友好的错误提示，你可能会使输入，输出和错误的含义复杂化，但是解析器的特征依然如此：消费输入并产生解析后的数据以及输入的其余部分，或者会让你知道无法将输入解析成输出。

&#8195;&#8195;让我们将其（解析器）写成函数的形式。

```rust
Fn(Input) -> Result<(Input, Output), Error>
```

&#8195;&#8195;更具体的说，就我们而言，我们希望可以填充这些类型，就像下面代码块所示。因为我们要做的是将一个字符串转化为`Element`结构体，并且在这方面我们不想陷入错综复杂的错误提示中，所以当我们不能够解析输入的字符串时，只需返回一段提示错误的字符串即可。

```rust
Fn(&str) -> Result<(&str, Element), &str>
```

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;

&#8195;&#8195;