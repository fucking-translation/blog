# 用Rust学习解析器组合器  

#### [原文](https://bodil.lol/parser-combinators/) 

</br>

[1. 初学者的想法](#初学者的想法)  
[2. 如何阅读本文](#如何阅读本文)  
[3. `Xcruciating`标记语言](#Xcruciating标记语言)  
[4. 定义解析器](#定义解析器)  
[5. 我们的第一个解析器](#我们的第一个解析器)  


本文向已是 Rust 程序员的人们传授解析器组合器的基础知识。它假定不涉及其他知识，并将解释与 Rust 没有直接关系的所有内容，以及为达到此目的使用 Rust 的一些令人意外的特性。如果你不了解 Rust，他不会教你 Rust 的内容，但是这样的话，同样也无法更好的教你解析器和组合器的知识。如果你想要学习 Rust 语言，我推荐  [Rust编程语言](https://doc.rust-lang.org/book/) 这本书。  

## 初学者的想法

当每个程序员发现自己需要解析器时，它们的生活将变得有意义。  

初学者程序员将会问：“什么是解析器？”。  
中级程序员将会说：“这很简单，我将写一串正则表达式”。  
高级程序员将会说：“退一步考虑问题，我知道`Lex`（词法分析器）和`Yacc`（语法解析器）”  

初学者的想法是正确的。

不是说正则表达式不好（但是请不要用正则表达式写复杂的解析器）。使用经过数千年磨练至完美的解析器和词法分析生成器之类的强大工具并不是没有乐趣可言。但是从头开始一点一点学习解析器将更有趣。这两者只是对当前实际问题的抽象，如果你直接选择正则表达式或者解析器生成工具，你将失去这一份乐趣。在初学者眼中，正如人们说的：本来（解决这个问题）有很多种方法，但是在专家眼里，已经形成思维定视，只会选择一种他们最习惯的方式。
在本文中我们将从头开始学习如何构建解析器，基于被称为解析器组合器的函数式编程语言的通用技术。一旦你掌握了它们的基本概念，它们的优势将非常巨大，同时又非常接近第一原理。因为这里唯一的抽象是你将在基础的组合器之上构建你自己的抽象。所有这些，你必须先构建它们，才能使用它们。

## 如何阅读本文

强烈建议你初始化一个 Rust 项目，并且在`src/lib.rs`中书写你阅读到的代码片段（你可以直接从页面上直接复制，但是最好还是自己手敲，因为这样会自动确保你完整阅读代码）。本文将按序介绍你需要的每段代码。请注意，有时会引入你先前编写功能的最新版本，这时，你需要将旧版本替换为新版本。

该代码是使用 2018 年语言版本的`rustc`的 1.34.0 版本编写的。你应该尽可能使用最新版本的编译器，只要你确保你使用的是 2018 的版本即可（检查`Cargo.toml`文件中是否包含`edition = "2018"`）。代码不需要任何的外部依赖。

如果要运行本文中的测试用例，请执行`cargo test`。

## `Xcruciating`标记语言

我们将用简化的XML格式写一个解析器，如下所示：

```xml
<parent-element>
  <single-element attribute="value" />
</parent-element>
```

XML元素使用`<`符号开头和一个由字母组成的标志符开头，后面可以根任意数量的字母，数字和`-`。后面跟一些空格，以及一些属性对的可选列表：前面定义一个标识符，后面跟一个`=`符号和一个双引号字符串，最后以`/>`结尾来表示一个没有子节点的单个元素。或者用`>`表示后面跟了一串子节点，最终是一个以`</`开头的结束标签，后跟一个必须与开始标识匹配的标志符，然后以`>`结束。

这就是我们将要支持的特性。没有命名空间，没有文本节点，其余的都没有，并且没有模式校验。我们甚至都不会自寻烦恼，去实现字符串的转义引号（`\"`） - 它们由第一个双引号开始，到下一个双引号结束，就是这样。如果你想在实际字符串中使用双引号，你可以将这个不合理的要求转移到其他地方。

我们将用下面的结构体来解析这些元素。

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String,
    attributes: Vec<(String, String)>,
    children: Vec<Element>,
}
```

没有花哨的类型，仅仅用字符串表示名称（那是每个标签开始的标志符），用字符串元组表示属性（标志符和对应的值），还有一个看起来和父元素完全一样的子元素列表。

（如果你正在输入，请加上那一系列的`derive`，你将在后面用到它们）。

## 定义解析器

好了，是时候编写解析器了。

解析是从数据流中派生结构的过程。解析器就是要弄清楚该结构的工具。

在我们即将探索的知识中，解析器最简单的一种形式就是一个函数，该函数接受一些输入并返回解析后的输出以及输入的其余部分，或者是一个错误信息：“我无法解析该输入”。

事实证明，简而言之，更复杂的解析器看起来也是如此。如果你要获取友好的错误提示，你可能会使输入，输出和错误的含义复杂化，但是解析器的特征依然如此：消费输入并产生解析后的数据以及输入的其余部分，或者会让你知道无法将输入解析成输出。

让我们将其（解析器）写成函数的形式。

```rust
Fn(Input) -> Result<(Input, Output), Error>
```

更具体的说，就我们而言，我们希望可以填充这些类型，就像下面代码块所示。因为我们要做的是将一个字符串转化为`Element`结构体，并且在这方面我们不想陷入错综复杂的错误提示中，所以当我们不能够解析输入的字符串时，只需返回一段提示错误的字符串即可。

```rust
Fn(&str) -> Result<(&str, Element), &str>
```

我们使用字符串切片（`&str`），是因为他是指向字符串的有效指针。我们可以进一步对其进行切片，通过切掉已解析的部分来消耗输入，并将余下的输入和结果一起返回。

可能使用`&[u8]`类型作为输入（一串字节数组，如果将输入的字节限制在`ASCII`范围内，则`u8`和`char`相对应）会看起来更加干净，尤其是字符串切片（`&str`）的行为和大多数切片的行为有所不同。你不能够通过一个数字来检索它们，你必须使用一个分片`input[0..1]`。另一方面，它们对于解析字符串有很多有用的函数，而字节切片没有。

事实上，我们通常都需要依赖这些函数而不是像`input[0]`这样对他进行索引。因为 Rust 的字符串是`UTF-8`格式的，这些索引并不总是对应于单个字符，所以对于我们来说，让标准库为我们处理这些问题更好。

## 我们的第一个解析器

让我们来一起写一个解析器，只需要关注字符串中的第一个字符并判断它是否是字母`a`

```rust
fn the_letter_a(input: &str) -> Result<(&str, ()), &str> {
  match input.chars().next() {
      Some('a') => Ok((&input['a'.len_utf8()..], ())),
      _ => Err(input),
  }
}
```

首先，我们来看一下输入和输入和输出的类型：和上面讨论的一样，我们让字符串切片作为输入，并返回携带`(&str, ())`元组或者错误类型`&str`的`Result`。`(&str, ())`元组比较有趣：正如我们所说的，我们想要返回一个包含下一次待解析的输入和输出。`&str`是下一次输入，解析返回的结果仅仅是一个单元类型`()`。因为如果解析成功，只可能有一种结果（我们找到了字母`a`），但是这里我们并不需要返回字母`a`，我们只需要告诉调用者我们成功发现了字母`a`即可。

然后，让我们看下解析器本身的代码。我们从提取输入的第一个字符开始：`input.chars().next()`。依靠标准库来避免带来的 Unicode 编码问题并不是在开玩笑 - 我们要求它为字符串的字符提供一个`chars()`迭代器，然后从中取出第一项。该项是封装在`Option`中的`char`类型，因此是`Option<char>`，如果它的值为`None`则表示我们尝试在空字符串中提取一个`char`。

更糟的是，`char`可能并不是你想的那样是 Unicode 字符。