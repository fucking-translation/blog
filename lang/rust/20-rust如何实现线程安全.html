<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 如何实现线程安全 - Blog Translation</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../../theme/ferris.css">
                <link rel="stylesheet" href="../../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li><li class="chapter-item expanded "><a href="../../lang/rust/20-rust如何实现线程安全.html" class="active"><strong aria-hidden="true">1.20.</strong> Rust 如何实现线程安全</a></li><li class="chapter-item "><a href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html"><strong aria-hidden="true">1.21.</strong> 无需 fork Clippy 就可以编写 Rust lint</a></li><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.22.</strong> 标准库</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.22.1.</strong> std::pin</a></li><li class="chapter-item "><a href="../../lang/rust/std/21-std-condvar.html"><strong aria-hidden="true">1.22.2.</strong> std::sync::Condvar</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li><li class="chapter-item "><a href="../../oci/summary.html"><strong aria-hidden="true">3.</strong> Open Container Initiative</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../oci/01-oci-spec-overview.html"><strong aria-hidden="true">3.1.</strong> OCI 规范概述</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-如何实现线程安全"><a class="header" href="#rust-如何实现线程安全">Rust 如何实现线程安全</a></h1>
<p><a href="https://manishearth.github.io/blog/2015/05/30/how-rust-achieves-thread-safety/">原文</a></p>
<p>在我迄今为止的每一次演讲中，都会遇到 “Rust 是如何实现线程安全”的提问，我通常只是概述一下，而本文为感兴趣的人提供了更全面的解释。</p>
<p>你也可以参阅：<a href="http://huonw.github.io/blog/2015/02/some-notes-on-send-and-sync/">Huon 关于此主题的博客</a></p>
<p>在<a href="http://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">之前的文章</a>中，我稍微谈到了 <a href="http://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a> 特征。标准库中还有其他这样的“标记”特征，本文中与之相关的是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 和 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 特征。如果你对像 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> 和 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> 这样的包装器类型不熟悉，我建议你阅读那篇文章，因为我将在本文中将它们作为示例；但是这里解释的概念在很大程度上是独立的。</p>
<p>处于本文的目的，我将线程安全限制为没有数据竞争或跨线程悬垂指针。Rust 的目的不是为了解决竞争条件。然而，有些项目利用类型系统来提供某种形式的额外安全，如 <a href="https://github.com/Munksgaard/rust-sessions">rust-session</a> 尝试使用会话类型提供协议安全。</p>
<p>这些特征是使用被称为“可选的内置特征”自动实现的。举个例子，如果<code>struct Foo</code>仅包含 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 字段，则它也将是 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>，除非我们使用<code>impl !Sync for Foo {}</code>明确说明不实现此特征。类似的，如果<code>struct Foo</code>包含至少一种非 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 类型，则它也不会是 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>，除非它显式指定<code>unsafe impl Sync for Foo {}</code>。</p>
<p>这意味着，<a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 类型的 <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html">Sender</a> 本身就是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>，但非 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 类型的 <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html">Sender</a> 将不是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>。这种模式非常强大。它允许在单线程上下文中使用具有非线程安全数据的通道，而无需单独的“单线程”通道抽象。</p>
<p>同时，像 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> 和 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> 这样包含 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>/<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 字段的结构已经明确指出退出其中的一个或多个，因为它们依赖的不变量 (invariants) 在多线程的情况下不成立。</p>
<p>实际上可以在编译器之外设计你自己的具有类似线程安全保证的库 - 虽然这些标记特征由编译器特别处理，但它们的工作不需要特殊处理。这里可以使用任意两个可选 (opt-in) 的内置特性。</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 和 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 的含义略有不同，但是功能有交织 (intertwined) 的部分。</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 类型可以在线程之间移动而不会有问题。它回答了“如果某个变量被移动到另一个线程，仍然可以使用吗”的问题。大多数完全拥有其包含数据的对象都符合此要求。值得注意的是，<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> 没有(因为它是共享所有权)。另一个例外是 <a href="https://doc.rust-lang.org/nightly/std/thread/struct.LocalKey.html">LocalKey</a>，它确实拥有自己的数据，但对其他线程无效。借用的数据确实有资格被发送，但在大多数情况下，由于稍后会涉及的约束，它不能跨线程发送。</p>
<p>即使像 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> 这样的类型使用非原子引用计数，它也可以在线程之间安全的发送，因为这是所有权的转移 (move)。将 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> 发送到另一个线程将是一个 move，并且将无法在原来的线程中使用。</p>
<p>另一方面，<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 与同步访问有关。它回答了“如果多个线程都试图访问这些数据，它会安全吗？”。<a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex</a> 等类型和其他基于<code>lock/atomic</code>的类型以及原始类型都实现了这一点。包含指针的结构通常不是 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>。</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 有点像 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 的拐杖 (crutch)。它有助于在涉及共享时让其他类型具有 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 特征。例如，<code>&amp;T</code>和 [Arc<T>] 仅在内部数据为 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 时才具有 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 特征(在 [Arc<T>] 的情况下有一个额外的 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 边界)。换句话说，如果<code>共享/借用 (shared/borrowed)</code>的数据是同步安全 (synchronous-safe) 的，则可以将具有<code>共享/借用</code>所有权的内容发送到另一个线程。</p>
<p>由于非原子引用计数，<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> 是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 但不是 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>。</p>
<p>把它们放在一起，所有这些的看门人 (gatekeeper) 是 <a href="http://doc.rust-lang.org/std/thread/fn.spawn.html">thread::spawn()</a>。它有签名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where 
    F: FnOnce() -&gt; T, 
    F: Send + 'static, 
    T: Send + 'static
<span class="boring">}
</span></code></pre></pre>
<p>诚然，这令人感到困惑，部分原因是它允许返回一个值，还返回了一个句柄，我们可以从中阻塞线程连接 (thread join)。不过，我们可以为我们的需要创造一个更简单的<code>spawn</code>API：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(f: F) 
where 
    F: FnOnce(), 
    F: Send + 'static
<span class="boring">}
</span></code></pre></pre>
<p>可以这样调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = vec![1,2,3,4];

// `move` instructs the closure to move out of its environment
thread::spawn(move || {
   x.push(1);

});

// x is not accessible here since it was moved
<span class="boring">}
</span></code></pre></pre>
<p><code>spawn()</code> 将接受一个将被调用一次的可调用对象(通常是一个闭包)，并包含 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 和<code>'static</code>的数据。这里，<code>'static</code>只是意味着闭包中不包含借用的数据。这是前面提到的阻止跨线程共享借用数据的约束。如果没有它，我们将能够将借用的指针发送到一个线程，该线程很容易超过借用时间，从而导致安全问题。</p>
<p>这里有一个关于闭包的细微差别 - 闭包可以捕获外部变量，但默认情况下它们是通过引用进行的(因此有<code>move</code>关键字)。它们根据捕获子句自动实现 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 和 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>。有关它们内部的更多信息，请参阅 <a href="http://huonw.github.io/blog/2015/05/finding-closure-in-rust/">huon 的博客</a>。在这种情况下，<code>x</code>将被捕获；即作为 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> (而不是类似于<code>&amp;Vec&lt;T&gt;</code>或其他东西)，所以闭包本身可以是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>。如果没有<code>move</code>关键字，闭包就不会是<code>'static</code>，因为它包含借用的内容。</p>
<p>由于闭包继承了其捕获数据的<code>Send/Sync/'static</code>，捕获正确类型数据的闭包将满足<code>F: Send + 'static</code>边界。</p>
<p>此函数允许和不允许的一些示例(对于<code>x</code>类型)：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>，<a href="http://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 是允许的，因为它们是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 和<code>'static</code>(当内部类型是相同类型时)。</li>
<li><code>&amp;T</code>是不允许的，因为它不是<code>'static</code>的。这很棒，因为借用应该有一个静态已知的生命周期。将借用的指针发送到其他线程可能会导致释放后使用，或者以其他方式破坏别名规则 (aliasing rules)。</li>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> 不是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>，所以是不允许的。我们可能会有其他一些 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> 闲置，并最终导致引用计数上的数据竞争。</li>
<li><code>Arc&lt;Vec&lt;u32&gt;&gt;</code>是允许的(如果内部类型 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 和 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>)；我们不能在这里造成安全违规。迭代器失效需要可变性，而 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>默认不提供。</li>
<li><code>Arc&lt;Cell&lt;T&gt;&gt;</code>是不允许的。<code>Cell&lt;T&gt;</code>提供基于复制的内部可变性，并且不是<code>Sync</code>(因此<code>Arc&lt;Cell&lt;T&gt;&gt;</code>不是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>)。如果允许这样做，我们可能会遇到较大的结构同时从不同的线程写入的情况，从而导致两者随机混杂，即数据竞争。</li>
<li><code>Arc&lt;Mutex&lt;T&gt;&gt;</code>或<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>是允许的(对于<code>Send T</code>)。内部类型使用线程安全锁并提供基于锁的内部可变性。它们可以保证在任何时间点只有一个线程正在写入。因此，互斥体 (mutex) 是 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>，只要其内部 T 是 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 即可，<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 类型可以与 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a> 等包装器安全的共享。从内部类型的角度来看，它一次只能被一个线程访问 (<a href="http://doc.rust-lang.org/std/sync/struct.RwLock.html">RwLock</a> 的情况稍微复杂一点)，因此不需要知道所涉及的线程。当涉及这些 <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 类型时，就不会出现数据竞争。</li>
</ul>
<p>如上所述，你实际上可以创建一对非 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 对象的<code>Sender/Receiver</code>。这听起来有点违反直觉 (counterintuitive) - 我们不是应该只发送<code>Send</code>的值吗？但是 <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender&lt;T&gt;</code></a> 仅当<code>T</code>为 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 时才为 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>；所以即使我们可以使用非 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 类型的 <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html">Sender</a>，我们也不能将它发送到另一个线程，因此它不能用于破坏线程安全。</p>
<p>还有一种方法可以讲<code>&amp;T</code>的 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> 用于某些<code>Sync T</code>，即 <a href="http://doc.rust-lang.org/std/thread/fn.scoped.html">thread::scoped</a>。这个函数没有<code>'static</code>边界，但它有一个<code>RAII</code>保护，它在借用结束之前强制 join。这使得不需要互斥体 (Mutex) 就可以轻松的实现 fork-join 并行性。可悲的是，当这与 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> 循环交互时会出现问题，因此该 API 目前不稳定，将会重新设计。这不是语言设计或 <a href="http://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>/<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> 设计的问题，而是库中小设计的不一致导致的完美风暴。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../lang/rust/19-生命周期型变示例.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../lang/rust/19-生命周期型变示例.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../../theme/ferris.js"></script>
        
        
    </body>
</html>
