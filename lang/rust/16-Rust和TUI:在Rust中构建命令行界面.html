<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 和 TUI：在 Rust 中构建命令行界面 - Blog Translation</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../../theme/ferris.css">
                <link rel="stylesheet" href="../../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item expanded "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html" class="active"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li><li class="chapter-item "><a href="../../lang/rust/20-rust如何实现线程安全.html"><strong aria-hidden="true">1.20.</strong> Rust 如何实现线程安全</a></li><li class="chapter-item "><a href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html"><strong aria-hidden="true">1.21.</strong> 无需 fork Clippy 就可以编写 Rust lint</a></li><li class="chapter-item "><a href="../../lang/rust/23-使用Mio编写底层TCP服务器.html"><strong aria-hidden="true">1.22.</strong> 使用 Mio 编写底层 TCP 服务器</a></li><li class="chapter-item "><a href="../../lang/rust/24-UnsafeRust的取舍.html"><strong aria-hidden="true">1.23.</strong> Unsafe Rust 的取舍</a></li><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.24.</strong> 标准库</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.24.1.</strong> std::pin</a></li><li class="chapter-item "><a href="../../lang/rust/std/21-std-condvar.html"><strong aria-hidden="true">1.24.2.</strong> std::sync::Condvar</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li><li class="chapter-item "><a href="../../oci/summary.html"><strong aria-hidden="true">3.</strong> Open Container Initiative</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../oci/01-oci-spec-overview.html"><strong aria-hidden="true">3.1.</strong> OCI 规范概述</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-和-tui在-rust-中构建命令行界面"><a class="header" href="#rust-和-tui在-rust-中构建命令行界面">Rust 和 TUI：在 Rust 中构建命令行界面</a></h1>
<p><a href="https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/">原文</a></p>
<p><img src="https://blog.logrocket.com/wp-content/uploads/2021/01/rust-tui-command-line-interface.png" alt="rust-tui-command-line-interface" /></p>
<p>Rust 是一门拥有良好的交叉编译支持的底层系统编程语言，这使其成为编写命令行程序的主要候选语言。从重新实现广泛使用的工具 (如 <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>，<a href="https://github.com/ogham/exa">exa</a>，<a href="https://github.com/sharkdp/bat">bat</a>) 到功能完善的终端 UI 工具（如：<a href="https://github.com/extrawurst/gitui">GitUI</a>，<a href="https://github.com/Rigellute/spotify-tui">Spotify TUI</a>，<a href="https://github.com/imsnif/bandwhich">Bandwhich</a>，<a href="https://github.com/orhun/kmon">KMon</a>，<a href="https://github.com/imsnif/diskonaut">Diskonaut</a>）都是比较著名 (Prominent) 的例子。</p>
<p>甚至有比较流行的 shell 实现 (如 <a href="https://github.com/alacritty/alacritty">Alacritty</a> 和 <a href="https://github.com/nushell/nushell">Nushell</a>)。使用 Rust 重写这众多的工具 (且保持稳定的增长) 的原因包括 <a href="https://transitiontech.ca/random/RIIR">Rewrite it in Rust (RIIR) meme</a> 以及 Rust 绝佳的编写命令行应用程序的生态系统。</p>
<p>当谈到 Rust 命令行库的生态系统，我想专门提一下 <a href="https://github.com/clap-rs/clap">Clap</a> 和 <a href="https://github.com/fdehau/tui-rs">TUI</a>，它们都是上面提到的许多工具中所必须的。Clap 是一个命令行解析器，具有出色的 API 和大量可用的功能，如果不需要，可以禁用其中的许多功能以加快编译速度。</p>
<h2 id="什么是-tui"><a class="header" href="#什么是-tui">什么是 TUI？</a></h2>
<p>TUI 是一个用于构建终端用户界面的框架。它支持多个用于绘制终端的“后端”。这些后端控制与终端交互的实际逻辑，如设置正确的字符集，清空屏幕等，而 TUI 是一个更高级的界面，它提供了用于组成用户界面的小部件和其他帮助程序。</p>
<p>在本篇教程中，我们将学习如何使用将 <a href="https://github.com/crossterm-rs/crossterm">Crossterm</a> 作为后端的 TUI 实现一个简单的终端应用程序。除了渲染和事件处理管道的初始化之外，我们不会直接与 Crossterm 进行交互，因此该示例只需要做很小的修改，就可以在其他 TUI 后端下工作。</p>
<p>为了演示 TUI 是如何工作的，我们将构建一个简单的 app 来管理你的宠物，其中使用本地 JSON 文件作为数据存储。最终的产品将会如下所示：</p>
<p><img src="./img/rust-tui-example-command-line-interface.webp" alt="rust-tui-example-command-line-interface" /></p>
<p><img src="./img/rust-tui-example-command-line-interface-finished.webp" alt="rust-tui-example-command-line-interface-finished" /></p>
<p>第一张图展示了带有菜单的欢迎界面。菜单中的高亮字符表示用户需要点击以执行操作的热键。如果按下<code>p</code>键，用户将会来到第二个(宠物)屏幕，他们可以在这里管理宠物。用户可以通过列表进行导航，使用<code>a</code>来添加随机的新宠物，使用<code>d</code>来删除当前选中的宠物。按下<code>q</code>可以关闭 app。</p>
<p>这个 app 相当简单，但是它对于展示 TUI 的工作原理以及如何构建这类应用的基础模块已经足够。使用我为这篇教程编写的 <a href="https://github.com/zupzup/rust-commandline-example">Rust 命令行示例代码</a>，你可以编辑该代码以对其进行扩展，为添加新宠物新增一个表单等。</p>
<p>使用 TUI 时，可以调整应用程序的大小，并可以响应式的进行更改，从而将不同 UI 的元素配置比例保持在适当的位置。这是使用现有的部件时 TUI 要做的其中一件事。</p>
<p>事不宜迟 (without further ado)，让我们开始吧！</p>
<h2 id="设置-rust-app"><a class="header" href="#设置-rust-app">设置 Rust app</a></h2>
<p>要进行后续操作，你需要做的是安装最新的 Rust (1.45+；在编写本文时最新版本是 <a href="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html">Rust 1.49.0</a>)。</p>
<p>首先，创建一个新的 Rust 项目：</p>
<pre><code class="language-console">cargo new rust-cli-example
cd rust-cli-example
</code></pre>
<p>然后编辑<code>Cargo.toml</code>文件，并添加以下你所需要的依赖：</p>
<pre><code class="language-toml">[dependencies]
crossterm = { version = &quot;0.19&quot;, features = [ &quot;serde&quot; ] }
serde = {version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
chrono = { version = &quot;0.4&quot;, features = [&quot;serde&quot;] }
rand = { version = &quot;0.7.3&quot;, default-features = false, features = [&quot;std&quot;] }
tui = { version = &quot;0.14&quot;, default-features = false, features = ['crossterm', 'serde'] }
thiserror = &quot;1.0&quot;
</code></pre>
<p>除了使用 Crossterm 作为 TUI 的后端。我们还需要 <a href="https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/">Serde</a> 用来处理 JSON，<a href="https://blog.logrocket.com/timezone-handling-in-rust-with-chrono-tz/">Chrono</a> 用来处理宠物的创建日期以及 <a href="https://blog.logrocket.com/rust-cryptography-libraries-a-comprehensive-list/#rngs">Rand</a> 用于创建随机数。</p>
<p>正如你在上面的配置中所见，我们在 TUI 中选择了<code>crossterm</code>和<code>serde</code>特性。</p>
<p>让我们从定义一些基础的数据结构以及常量开始。</p>
<h2 id="定义数据结构"><a class="header" href="#定义数据结构">定义数据结构</a></h2>
<p>首先，让我们为本地“数据库” JSON 文件定义一个常量，以及宠物对应的结构体：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const DB_PATH: &amp;str = &quot;./data/db.json&quot;;

#[derive(Serialize, Deserialize, Clone)]
struct Pet {
    id: usize,
    name: String,
    category: String,
    age: usize,
    created_at: DateTime&lt;Utc&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>当处理数据库文件时，我们可能会遇到 I/O 异常。虽然为所有的潜在异常实现异常处理不在本文要讲述的范围内，我们仍然定义一些内部的错误类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub enum Error {
    #[error(&quot;error reading the DB file: {0}&quot;)]
    ReadDBError(#[from] io::Error),
    #[error(&quot;error parsing the DB file: {0}&quot;)]
    ParseDBError(#[from] serde_json::Error),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>db.json</code>文件是一个简单的用 JSON 表示的<code>Pet</code>结构的列表。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[
    {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Chip&quot;,
        &quot;category&quot;: &quot;cats&quot;,
        &quot;age&quot;: 4,
        &quot;created_at&quot;: &quot;2020-09-01T12:00:00Z&quot;
    },
    ...
]
<span class="boring">}
</span></code></pre></pre>
<p>我们也需要输入事件的数据结构。我们将会使用在 <a href="https://github.com/fdehau/tui-rs/tree/master/examples">TUI 示例</a>仓库中的 Crossterm 示例中使用的相同的方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event&lt;I&gt; {
    Input(I),
    Tick,
}
<span class="boring">}
</span></code></pre></pre>
<p>事件可能是用户的输入或者是简单的<code>tick</code>。我们将会定义 tick 的速率(如：200毫秒)，如果在该速率内没有输入事件则发送一个<code>Tick</code>，否则提交一个输入。</p>
<p>最后，为菜单结构定义一个枚举，因此可以轻松确定我们在应用程序中的位置：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, Debug)]
enum MenuItem {
    Home,
    Pets,
}

impl From&lt;MenuItem&gt; for usize {
    fn from(input: MenuItem) -&gt; usize {
        match input {
            MenuItem::Home =&gt; 0,
            MenuItem::Pets =&gt; 1,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们目前只有两个页面 - Home 和 Pets - 我们实现了<code>From</code>特征将它们转换成<code>usize</code>。这让我们可以使用 TUI 组件中的枚举凸显菜单中当前选中的选项卡。</p>
<p>先不进行初始化，让我们设置 TUI 和 crossterm，以便可以开始在屏幕上渲染内容并对用户事件做出响应。</p>
<h2 id="渲染和输入"><a class="header" href="#渲染和输入">渲染和输入</a></h2>
<p>首先，将终端设置成<code>raw</code>模式，这消除了等待用户对输入做出响应时按下<code>Enter</code>键的需要。</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    enable_raw_mode().expect(&quot;can run in raw mode&quot;);
...
</code></pre></pre>
<p>然后，设置一个<code>mpsc</code>(多生产者，单消费者)管道来与输出处理以及渲染循环通信。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (tx, rx) = mpsc::channel();
let tick_rate = Duration::from_millis(200);
thread::spawn(move || {
    let mut last_tick = Instant::now();
    loop {
        let timeout = tick_rate
            .checked_sub(last_tick.elapsed())
            .unwrap_or_else(|| Duration::from_secs(0));

        if event::poll(timeout).expect(&quot;poll works&quot;) {
            if let CEvent::Key(key) = event::read().expect(&quot;can read events&quot;) {
                tx.send(Event::Input(key)).expect(&quot;can send events&quot;);
            }
        }

        if last_tick.elapsed() &gt;= tick_rate {
            if let Ok(_) = tx.send(Event::Tick) {
                last_tick = Instant::now();
            }
        }
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>创建了通道之后，定义上面提到的 tick 速率并生成一个线程。我们的输入循环将在这个线程中执行。建议按照此代码段使用 TUI 和 Crossterm 来设置输入循环。</p>
<p>这个想法是想要计算下一个 tick (<code>timeout</code>)，然后使用<code>event::poll</code>一直等待直到事件发生的那一刻，如果有事件发生，则通过我们通道发送该输入事件，该通道中带有用户按下的按键。</p>
<p>如果在这段时间没有发生用户事件，我们简单的发送一个<code>Tick</code>事件并重新开始。使用<code>tick_rate</code>，你可以调整 (tune) 应用程序的响应能力。但是如果将该值设置的很低同样意味着这个循环运行会占用很多资源。</p>
<p>这个逻辑在另一个线程中生成，因为我们需要主线程渲染这个应用。这么做的话，我们的输入循环就不会阻塞渲染线程。</p>
<p>将后端设置为<code>Crossterm</code>的 TUI 终端需要一些步骤：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stdout = io::stdout();
let backend = CrosstermBackend::new(stdout);
let mut terminal = Terminal::new(backend)?;
terminal.clear()?;
<span class="boring">}
</span></code></pre></pre>
<p>我们使用<code>stdout</code>定义了一个<code>CrosstermBackend</code>并在 TUI 终端中使用，首先对终端进行 clear，然后隐式的检查一切运行良好。如果有任何出错，我们简单的 panic 并将应用终止；由于我们没有获取更改渲染事件的任何内容，因此这里真的没有其他更好的应对方法。</p>
<p>至此，我们需要一个样板 (boilerplate) 设置来创建一个输入循环以及一个可以绘制的终端。</p>
<p>让我们构建第一个 UI 元素 - 基于 tab 的菜单！</p>
<h2 id="渲染-tui-中的部件"><a class="header" href="#渲染-tui-中的部件">渲染 TUI 中的部件</a></h2>
<p>在我们创建菜单之前，我们需要实现一个渲染循环，它在每一次迭代中调用<code>terminal.draw()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    terminal.draw(|rect| {
        let size = rect.size();
        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .margin(2)
            .constraints(
                [
                    Constraint::Length(3),
                    Constraint::Min(2),
                    Constraint::Length(3),
                ]
                .as_ref(),
            )
            .split(size);
...
<span class="boring">}
</span></code></pre></pre>
<p>我们使用闭包提供了一个<code>draw</code>函数，它接收一个<code>Rect</code>作为参数。这只是 TUI 中使用的矩形布局原语，用于定义应在何处渲染的部件。</p>
<p>下一步是定义布局的<code>chunks</code>。我们有传统垂直布局，其中包含三个框：</p>
<ol>
<li>菜单</li>
<li>内容</li>
<li>页尾</li>
</ol>
<p>我们使用 TUI 中的<code>Layout</code>来定义这个，设置方向以及一些约束条件。这些约束条件定义了应该如何组合布局中不同的部分。在我们的示例中，我们将菜单部分的长度定义为 3 (本质上是 3 行)，中间的内容部分长度至少是 2，页尾长度是 3。这意味着，如果你在全屏中运行这个 app，菜单和页尾的高度为 3 行始终不变，而内容部分将增长到其余的大小。</p>
<p>这些约束条件是一个功能强大的系统，我们在后面还会介绍设置百分比和比率的选项。最后，我们将布局分成多个布局块。</p>
<p>我们布局中最简单的 UI 组件就是带有假版权的静态页尾，让我们开始感受一下如何创建并渲染一个部件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let copyright = Paragraph::new(&quot;pet-CLI 2020 - all rights reserved&quot;)
    .style(Style::default().fg(Color::LightCyan))
    .alignment(Alignment::Center)
    .block(
        Block::default()
            .borders(Borders::ALL)
            .style(Style::default().fg(Color::White))
            .title(&quot;Copyright&quot;)
            .border_type(BorderType::Plain),
    );
rect.render_widget(copyright, chunks[2]);
<span class="boring">}
</span></code></pre></pre>
<p>我们使用<code>Paragraph</code>部件，它是预先存在于 TUI 中许多<a href="https://docs.rs/tui/latest/tui/widgets/index.html">部件</a>的其中一个。我们使用硬编码文本定义一个段落，通过在默认风格中使用<code>.fg</code>来设置不同的前景色来自定义风格，设置居中对齐，然后定义一个块。</p>
<p>这个块很重要因为它是一个“基础”部件，意味着它可以渲染到其他所有的部件中。<code>Block</code>定义了一个区域，你可以在该区域中围绕要呈现的内容放置标题和可选边框。</p>
<p>在这里，我们创建了一个标题为 “Copyright” 的框，它具有完整的边框，可以创建漂亮的三框垂直布局。</p>
<p>然后，我们使用<code>draw</code>方法中的<code>rect</code>调用<code>render_widget</code>，将我们的段落渲染成<code>chunks[2]</code>，它是布局中的第三个部分(底下的部分)。</p>
<p>这就是在 TUI 中渲染部件的全部内容。很简单，对不堵？</p>
<h2 id="构建一个基于-tab-的菜单"><a class="header" href="#构建一个基于-tab-的菜单">构建一个基于 tab 的菜单</a></h2>
<p>现在，我们终于可以处理 (tackle) 基于 tab 的菜单了。幸运的是，TUI 开箱即用 (out of box)，其中有一个<code>Tabs</code>部件，我们无需做很多事情即可使其工作。为了管理有关哪个菜单项出于激活状态，我们需要在渲染循环之前添加两行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
let menu_titles = vec![&quot;Home&quot;, &quot;Pets&quot;, &quot;Add&quot;, &quot;Delete&quot;, &quot;Quit&quot;];
let mut active_menu_item = MenuItem::Home;
...
loop {
    terminal.draw(|rect| {
...
<span class="boring">}
</span></code></pre></pre>
<p>在第一行中，我们定义了硬编码的菜单标题并且<code>active_menu_item</code>存储了当前被选中的菜单项，初始化时将其设置为<code>Home</code>。</p>
<p>因为我们只有两个页面，所以它只能被设置为<code>Home</code>或者<code>Pets</code>，但是你可以想象如何将这种方法用于基本的上层路由。</p>
<p>为了渲染菜单，我们首先需要创建一个<code>Span</code>(是的，就像是 HTML 中的 <a href="https://blog.logrocket.com/html-tags-every-frontend-developer-should-know/"><span> 标签</a>)元素列表以持有这些菜单标签，然后将它们放置在<code>Tabs</code>部件中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let menu = menu_titles
    .iter()
    .map(|t| {
        let (first, rest) = t.split_at(1);
        Spans::from(vec![
            Span::styled(
                first,
                Style::default()
                    .fg(Color::Yellow)
                    .add_modifier(Modifier::UNDERLINED),
            ),
            Span::styled(rest, Style::default().fg(Color::White)),
        ])
    })
    .collect();

let tabs = Tabs::new(menu)
    .select(active_menu_item.into())
    .block(Block::default().title(&quot;Menu&quot;).borders(Borders::ALL))
    .style(Style::default().fg(Color::White))
    .highlight_style(Style::default().fg(Color::Yellow))
    .divider(Span::raw(&quot;|&quot;));

rect.render_widget(tabs, chunks[0]);
<span class="boring">}
</span></code></pre></pre>
<p>我们遍历硬编码菜单标签，然后在每个标签的第一个字符处分割字符串。我们给第一个字符添加不同的颜色和下划线，让它与其他字符的风格不一样，以提示用户，它们需要按下该字符以激活对应的菜单项。</p>
<p>这个操作的结果是一个<code>Spans</code>元素，它是一个<code>Span</code>元素列表，其实就是多个可选风格的文本片段。这些<code>Spans</code>会被放置在<code>Tabs</code>部件中。</p>
<p>我们使用<code>active_menu_item</code>调用<code>.select()</code>并设置一个高亮风格，它与其它普通风格有所不同。这意味着如果一个菜单项被选中，它将完全变成黄色，而未被选中的只有第一个字符是黄色，其他字符是白色。我们还定义了一个分隔符，然后再设置一个带有边框和标题的基本块，以保持和我们的样式一致。</p>
<p>和 copyright 一致，我们使用<code>chunk[0]</code>将 tab 菜单渲染进布局的第一个部分。</p>
<p>现在，三分之二的布局元素已经完成。然而，我们在这里使用<code>active_menu_item</code>定义一个有状态的元素来判断哪一个菜单项是激活状态，这将如何改变？</p>
<p>让我们接下来进行输入处理来解决这个秘密。</p>
<h2 id="处理-tui-中的输入"><a class="header" href="#处理-tui-中的输入">处理 TUI 中的输入</a></h2>
<p>在渲染<code>loop {}</code>中，在<code>terminal.draw()</code>调用完成之后，我们添加了另一段代码：我们的输入处理。</p>
<p>这意味着我们总是首先渲染当前的状态然后对新的输入做出反应。我们只需在<code>channel</code>的接收端等待输入即可，这是我们在开始时就设置的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match rx.recv()? {
        Event::Input(event) =&gt; match event.code {
            KeyCode::Char('q') =&gt; {
                disable_raw_mode()?;
                terminal.show_cursor()?;
                break;
            }
            KeyCode::Char('h') =&gt; active_menu_item = MenuItem::Home,
            KeyCode::Char('p') =&gt; active_menu_item = MenuItem::Pets,
            _ =&gt; {}
        },
        Event::Tick =&gt; {}
    }
} // end of render loop
<span class="boring">}
</span></code></pre></pre>
<p>当发生了一个事件，我们对传入的<code>KeyCode</code>进行匹配。如果用户按下<code>q</code>，表示想要关闭 app，这表示我们想要做一些清理，将终端的状态设置成我们最初获得终端时相同的状态。在真实的应用中，这个清理应该发生在任何的严重错误中。否则，终端保持在<code>raw</code>模式并看起来很混乱。</p>
<p>我们禁用了<code>raw</code>模式并再一次展示光标，因此用户应该在启动 app 之前处于“普通”的终端模式。</p>
<p>如果我们遇到了<code>h</code>，我们将激活的菜单设置为<code>Home</code>，如果是<code>p</code>，则将菜单设置为<code>Pets</code>。这是我们需要的全部路由逻辑。</p>
<p>而且，在<code>terminal.draw</code>闭包中，我们需要为这个路由添加一些逻辑：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match active_menu_item {
        MenuItem::Home =&gt; rect.render_widget(render_home(), chunks[1]),
        MenuItem::Pets =&gt; {
            ...
        }
    }
...

fn render_home&lt;'a&gt;() -&gt; Paragraph&lt;'a&gt; {
    let home = Paragraph::new(vec![
        Spans::from(vec![Span::raw(&quot;&quot;)]),
        Spans::from(vec![Span::raw(&quot;Welcome&quot;)]),
        Spans::from(vec![Span::raw(&quot;&quot;)]),
        Spans::from(vec![Span::raw(&quot;to&quot;)]),
        Spans::from(vec![Span::raw(&quot;&quot;)]),
        Spans::from(vec![Span::styled(
            &quot;pet-CLI&quot;,
            Style::default().fg(Color::LightBlue),
        )]),
        Spans::from(vec![Span::raw(&quot;&quot;)]),
        Spans::from(vec![Span::raw(&quot;Press 'p' to access pets, 'a' to add random new pets and 'd' to delete the currently selected pet.&quot;)]),
    ])
    .alignment(Alignment::Center)
    .block(
        Block::default()
            .borders(Borders::ALL)
            .style(Style::default().fg(Color::White))
            .title(&quot;Home&quot;)
            .border_type(BorderType::Plain),
    );
    home
}
<span class="boring">}
</span></code></pre></pre>
<p>我们匹配<code>active_menu_item</code>，如果是<code>Home</code>，则简单的渲染一个基本的欢迎信息告诉用户他们在哪儿，并给他们一些说明如何与这个 app 进行交互。</p>
<p>这就是我们需要的输入处理的全部内容。如果我们运行这段代码，我们已经可以与 tab 进行交互了。但是我们还缺少宠物管理应用程序的实质：宠物的处理。</p>
<h2 id="在-tui-中创建有状态的部件"><a class="header" href="#在-tui-中创建有状态的部件">在 TUI 中创建有状态的部件</a></h2>
<p>第一步是从 JSON 文件中加载宠物然后在左侧展示宠物的名字，以及在右侧展示选中宠物的细节(默认选中第一个)。</p>
<p>在此申明一下，由于本教程的范围有限，因此该应用程序无法处理错误；如果读取文件失败，则应用程序将会崩溃，而不显示有用的错误。从本质上将，错误处理与其他 UI 应用程序中的工作方式相同：对错误进行分类，如：像用户显示有用的错误<code>Paragraph</code>，以提示纠正问题或采取某个行为。</p>
<p>顺便说一句，让我们看一下上一节中<code>active_menu_item</code>匹配项的缺失部分：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match active_menu_item {
    MenuItem::Home =&gt; rect.render_widget(render_home(), chunks[1]),
    MenuItem::Pets =&gt; {
        let pets_chunks = Layout::default()
            .direction(Direction::Horizontal)
            .constraints(
                [Constraint::Percentage(20), Constraint::Percentage(80)].as_ref(),
            )
            .split(chunks[1]);
        let (left, right) = render_pets(&amp;pet_list_state);
        rect.render_stateful_widget(left, pets_chunks[0], &amp;mut pet_list_state);
        rect.render_widget(right, pets_chunks[1]);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们在<code>Pets</code>页面，我们创建一个新的布局。这一次，我们想要一个水平布局，因为我们想要彼此相邻的展示两个元素：列表视图以及详情视图。在这里，我们想要列表视图占据屏幕的 20%，剩下的留给详情视图。</p>
<p>请注意，在<code>.split</code>中，我们使用<code>chunk[1]</code>而不是矩形的大小。这意味着我们将描述的<code>chunk[1]</code>矩形区域分割成两块水平视图。然后调用<code>render_pets</code>，返回我们要渲染的左右部分，我们只需将它们渲染到响应的<code>pets_chunks</code>中即可。</p>
<p>但是等一下，这是什么？我们为列表视图调用<code>render_stateful_widget</code>，这代表什么意思？</p>
<p>TUI，作为一个完整且出色的框架，它具有创建有状态的部件的能力。<code>List</code>部件是可以带状态的部件之一。为此，我们需要先在渲染循环之前创建一个<code>ListState</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pet_list_state = ListState::default();
pet_list_state.select(Some(0));

loop {
...
<span class="boring">}
</span></code></pre></pre>
<p>我们初始化宠物列表状态并默认选择第一个项。我们还将<code>pet_list_state</code>传入<code>render_pets</code>函数中。这个函数执行以下所有逻辑：</p>
<ul>
<li>从数据库文件中获取宠物信息</li>
<li>将它们转换成列表项</li>
<li>创建宠物列表</li>
<li>查找当前选中的宠物</li>
<li>使用选中的宠物数据渲染一个表格</li>
<li>返回这两个部件</li>
</ul>
<p>这内容有点多，因此代码比较长，但是我们将逐行介绍：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_db() -&gt; Result&lt;Vec&lt;Pet&gt;, Error&gt; {
    let db_content = fs::read_to_string(DB_PATH)?;
    let parsed: Vec&lt;Pet&gt; = serde_json::from_str(&amp;db_content)?;
    Ok(parsed)
}

fn render_pets&lt;'a&gt;(pet_list_state: &amp;ListState) -&gt; (List&lt;'a&gt;, Table&lt;'a&gt;) {
    let pets = Block::default()
        .borders(Borders::ALL)
        .style(Style::default().fg(Color::White))
        .title(&quot;Pets&quot;)
        .border_type(BorderType::Plain);

    let pet_list = read_db().expect(&quot;can fetch pet list&quot;);
    let items: Vec&lt;_&gt; = pet_list
        .iter()
        .map(|pet| {
            ListItem::new(Spans::from(vec![Span::styled(
                pet.name.clone(),
                Style::default(),
            )]))
        })
        .collect();

    let selected_pet = pet_list
        .get(
            pet_list_state
                .selected()
                .expect(&quot;there is always a selected pet&quot;),
        )
        .expect(&quot;exists&quot;)
        .clone();

    let list = List::new(items).block(pets).highlight_style(
        Style::default()
            .bg(Color::Yellow)
            .fg(Color::Black)
            .add_modifier(Modifier::BOLD),
    );

    let pet_detail = Table::new(vec![Row::new(vec![
        Cell::from(Span::raw(selected_pet.id.to_string())),
        Cell::from(Span::raw(selected_pet.name)),
        Cell::from(Span::raw(selected_pet.category)),
        Cell::from(Span::raw(selected_pet.age.to_string())),
        Cell::from(Span::raw(selected_pet.created_at.to_string())),
    ])])
    .header(Row::new(vec![
        Cell::from(Span::styled(
            &quot;ID&quot;,
            Style::default().add_modifier(Modifier::BOLD),
        )),
        Cell::from(Span::styled(
            &quot;Name&quot;,
            Style::default().add_modifier(Modifier::BOLD),
        )),
        Cell::from(Span::styled(
            &quot;Category&quot;,
            Style::default().add_modifier(Modifier::BOLD),
        )),
        Cell::from(Span::styled(
            &quot;Age&quot;,
            Style::default().add_modifier(Modifier::BOLD),
        )),
        Cell::from(Span::styled(
            &quot;Created At&quot;,
            Style::default().add_modifier(Modifier::BOLD),
        )),
    ]))
    .block(
        Block::default()
            .borders(Borders::ALL)
            .style(Style::default().fg(Color::White))
            .title(&quot;Detail&quot;)
            .border_type(BorderType::Plain),
    )
    .widths(&amp;[
        Constraint::Percentage(5),
        Constraint::Percentage(20),
        Constraint::Percentage(20),
        Constraint::Percentage(5),
        Constraint::Percentage(20),
    ]);

    (list, pet_detail)
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们定义了<code>read_db</code>函数，它简单的读取 JSON 文件并将它解析成宠物的<code>Vec</code>。</p>
<p>然后在<code>render_pets</code>中，该函数返回<code>List</code>和<code>Table</code>的元组(都是 TUI 部件)，我们首先为列表视图定义周围的<code>pets</code>块。</p>
<p>在获取到宠物数据之后，我们将宠物名字转换成<code>ListItems</code>。然后，我们试图在基于<code>pet_list_state</code>的列表中查找选中的宠物。如果失败或者我们没有宠物，在这个简单的版本中，该应用将会崩溃，因为我们正如上面所说，没有做任何有意义的错误处理。</p>
<p>一旦我们有了一个选中的宠物，我们将使用列表项创建一个<code>List</code>部件，定义一个高亮的风格，因此我们可以看到当前选中的是哪一个宠物。</p>
<p>最后，我们创建了<code>pet_details</code>表格，其中为宠物结构中的列名设置一个硬编码的 header。我们还定义了<code>Rows</code>列表，它包含每个宠物数据转换后的字符串。</p>
<p>我们将此表格渲染为带有<code>Details</code>标题和边框的基本块。并使用百分比定义五列的相对宽度。因此，该表格在调整大小时也会做出响应。</p>
<p>这是宠物的整个渲染逻辑。剩下的要添加的唯一功能是添加随机新宠物和删除所选宠物的功能，以使该应用更具交互性。</p>
<p>首先，我们先添加两个辅助函数来新增和删除宠物：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_random_pet_to_db() -&gt; Result&lt;Vec&lt;Pet&gt;, Error&gt; {
    let mut rng = rand::thread_rng();
    let db_content = fs::read_to_string(DB_PATH)?;
    let mut parsed: Vec&lt;Pet&gt; = serde_json::from_str(&amp;db_content)?;
    let catsdogs = match rng.gen_range(0, 1) {
        0 =&gt; &quot;cats&quot;,
        _ =&gt; &quot;dogs&quot;,
    };

    let random_pet = Pet {
        id: rng.gen_range(0, 9999999),
        name: rng.sample_iter(Alphanumeric).take(10).collect(),
        category: catsdogs.to_owned(),
        age: rng.gen_range(1, 15),
        created_at: Utc::now(),
    };

    parsed.push(random_pet);
    fs::write(DB_PATH, &amp;serde_json::to_vec(&amp;parsed)?)?;
    Ok(parsed)
}

fn remove_pet_at_index(pet_list_state: &amp;mut ListState) -&gt; Result&lt;(), Error&gt; {
    if let Some(selected) = pet_list_state.selected() {
        let db_content = fs::read_to_string(DB_PATH)?;
        let mut parsed: Vec&lt;Pet&gt; = serde_json::from_str(&amp;db_content)?;
        parsed.remove(selected);
        fs::write(DB_PATH, &amp;serde_json::to_vec(&amp;parsed)?)?;
        pet_list_state.select(Some(selected - 1));
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>在这两个函数中，我们加载宠物列表，操作后将其写回文件。在<code>remove_pet_at_index</code>中，我们也需要减少<code>pet_list_state</code>，因此如果我们在列表中最后一个宠物上时，我们将自动跳到前一个宠物上。</p>
<p>最后，我们需要使用<code>Up</code>和<code>Down</code>在宠物列表中为导航添加错误处理，用法和使用<code>a</code>和<code>d</code>对宠物进行增减一样。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>KeyCode::Char('a') =&gt; {
    add_random_pet_to_db().expect(&quot;can add new random pet&quot;);
}
KeyCode::Char('d') =&gt; {
    remove_pet_at_index(&amp;mut pet_list_state).expect(&quot;can remove pet&quot;);
}
KeyCode::Down =&gt; {
    if let Some(selected) = pet_list_state.selected() {
        let amount_pets = read_db().expect(&quot;can fetch pet list&quot;).len();
        if selected &gt;= amount_pets - 1 {
            pet_list_state.select(Some(0));
        } else {
            pet_list_state.select(Some(selected + 1));
        }
    }
}
KeyCode::Up =&gt; {
    if let Some(selected) = pet_list_state.selected() {
        let amount_pets = read_db().expect(&quot;can fetch pet list&quot;).len();
        if selected &gt; 0 {
            pet_list_state.select(Some(selected - 1));
        } else {
            pet_list_state.select(Some(amount_pets - 1));
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在<code>Up</code>和<code>Down</code>这两种情况中，我们需要确定列表不会下溢或上溢。在这里简单的例子中，我们只是在这些键被按下时读取宠物列表，这非常的低效，但是足够简单。比如：在真实的应用中，当前数量的宠物将在共享内存的某个地方中持有，但是在本篇教程中，这种幼稚的方法就足够 (suffice) 了。</p>
<p>在任何情况下，我们只需增加或减少<code>pet_list_state</code>选择的值，可以让用户使用<code>Up</code>和<code>Down</code>滚动浏览宠物列表。如果使用<code>cargo run</code>启动应用，你可以测试不同的热键绑定，使用<code>a</code>添加一些随机的宠物，导航到宠物列表并再次使用<code>d</code>删除它们。</p>
<p>你可以在 <a href="https://github.com/zupzup/rust-commandline-example">Github</a> 上找到本教程的完整代码。</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>正如我在本教程的介绍中所提到的，Rust 创建终端应用的生态非常好，我希望这篇文章可以帮助你了解到使用　TUI 和 Crossterm 之类的库都能干些什么。</p>
<p>我是命令行应用的脑残粉。它们真的非常块，轻量且足够小，而且作为 Vimer，我对于使用键盘来与应用进行交互不是很恐惧。终端 UI 的另一个好处是它们可以被用于无头 (headless) 的环境，如：使用 SSH 登陆的远程服务器或者在恢复/调试的场景。</p>
<p>Rust 及其丰富的生态系统使构建命令行应用变得轻而易举，我为人们将来在该领域构建和发布的内容感到兴奋。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../lang/rust/15-解释Rust中的原子性.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../lang/rust/17-在Android中运行Rust.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../lang/rust/15-解释Rust中的原子性.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../lang/rust/17-在Android中运行Rust.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../../theme/ferris.js"></script>
        
        
    </body>
</html>
