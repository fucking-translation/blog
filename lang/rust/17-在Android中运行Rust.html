<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>在 Android 中运行 Rust - Blog Translation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../theme/ferris.css">
        
        <link rel="stylesheet" href="../../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item expanded "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item expanded "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item expanded "><a href="../../lang/rust/17-在Android中运行Rust.html" class="active"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item expanded "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item expanded "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li></ol></li><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="在-android-中运行-rust"><a class="header" href="#在-android-中运行-rust">在 Android 中运行 Rust</a></h1>
<p><a href="https://blog.svgames.pl/article/running-rust-on-android">原文</a></p>
<p>为了我目前的一位客户，我们决定将 Rust 作为我们主要的编程语言。做出这个决定的原因有很多：除了技术优势 (merit) 外，还有一个无可争议的 (undisputable) 事实就是：Rust 仍然是一门相对较新的语言，花哨 (fancy) 且时髦 (hip) - 当你是一家初创公司 (startup) 时，使用十几年前的技术可能会让你陷入困境。我的意思是 - 不使用创新的技术如何进行创新？最快的成功方式就是对其大肆宣传 (aboard the hype train)。</p>
<p>”用户持有自己的数据“应该是产品的一个卖点，它不能是一个完全通过浏览器访问的服务，而应该是一种可以分发给用户，并让其运行在用户设备上的某个东西。我们在内部已经运行了一些 headless (一种无界面的软件运行模式) 实例，只要再完成一些琐碎的 (trivial) 工作，就可以为 Windows 和 Linux 系统制作可重新分发的程序包。但是我们知道如果程序包只能运行在桌面操作系统中时，将会严重阻碍应用的普及 - 如果我们想让它脱颖而出 (take off)，则需要该应用程序的移动版本。这意味着我们必须要知道如何让我们的程序运行在 Android 或者 iOS 系统中。因为我对交叉编译与自动化构建已经有了一些经验，我主动的研究了这个主题。</p>
<h2 id="获取工具"><a class="header" href="#获取工具">获取工具</a></h2>
<p>先从基础开始，我需要获取 Rust 交叉编译器。幸运的是，Rust 让此操作变得十分简单，因为只需要调用以下命令：</p>
<pre><code class="language-console">$ rustup target add armv7-linux-androideabi  # For 32-bit ARM.
$ rustup target add aarch64-linux-android    # For 64-bit ARM.

# x86_64 is mainly useful for running your app in the emulator.
# Speaking of hardware, there are some commercial x86-based tablets,
# and there's also hobbyists running Android-x86 on their laptops.
$ rustup target add x86_64-linux-android
</code></pre>
<p><em>（注意：以后只会显示 aarch64 架构的所有示例）</em></p>
<p>我还需要 Android 的构建工具。在经过一番调研之后，我来到 <a href="https://developer.android.com/studio#command-tools">Android Studio 的下载页面</a> 并抓取了归档的命令行工具。尽管 SDK 包有 80+ MiB 大小，却依然只有所需工具的最小子集，所以我听从了互联网的建议并使用<code>sdkmanager</code>来安装额外的部件。</p>
<pre><code class="language-console">$ cd ~/android/sdk/cmdline-tools/bin/
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'build-tools;29.0.2'
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'cmdline-tools;latest'
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'platform-tools'
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'platforms;android-29'
</code></pre>
<p>尽管 Android 支持运行 native 代码，但是大多数应用还是采用 Java 或者 Kotlin 来编写，SDK 反应了这一点。为了能够使用 native 代码，我还需要一个工具 - 原生开发工具套件 (Native Development kit)。<a href="https://developer.android.com/ndk/downloads">NDK 下载页面</a> 提供了几个版本以供选择 - 在经过一段深思熟虑后，我决定使用 LTS 版本：r21e。</p>
<h2 id="足够简单或想太多"><a class="header" href="#足够简单或想太多">足够简单！或想太多？</a></h2>
<p>搞定了开发工具之后，我决定试着直接编译项目。</p>
<pre><code class="language-console">$ cargo build --target=aarch64-linux-android
</code></pre>
<p>和预期的一样，构建失败了，并且错误信息占满了整个屏幕。经过筛选 (sift) 后，显示存在一个链接错误：</p>
<pre><code class="language-console">error: linking with `cc` failed: exit code: 1
/usr/bin/ld: startup.48656c6c6f20546865726521.o: Relocations in generic ELF (EM: 183)
/usr/bin/ld: startup.48656c6c6f20546865726521.o: error adding symbols: file in wrong format
collect2: error: ld returned 1 exit status
</code></pre>
<p>我认为这(错误提示)足够简单 - Cargo 试图使用系统的链接器 (linker) 而不是 Android NDK 的链接器。我可以使用<code>CC</code>和<code>LD</code>环境变量让 Cargo 指向正确的链接器。</p>
<pre><code class="language-console">$ export ANDROID_NDK_ROOT=&quot;${HOME}/android/ndk&quot;
$ export TOOLCHAIN=&quot;${ANDROID_NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64&quot;
$ export CC=&quot;${TOOLCHAIN}/bin/aarch64-linux-android29-clang&quot;
$ export LD=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ld&quot;
$ cargo build --target=aarch64-linux-android
</code></pre>
<p>让我失望的是，这并没有起作用。我不愿意花费一天的时间来和 Cargo 纠缠 (wrestle)，因此我决定寻找是否有其他人给出了解决方案 - 很快，我便找到看似十分完美的工具。</p>
<h2 id="cargo-apk"><a class="header" href="#cargo-apk">cargo-apk</a></h2>
<p><a href="https://crates.io/crates/cargo-apk">cargo-apk</a> 是一个可以简单的将 Cargo 项目构建成<code>.apk</code>的工具。你所需要做得就是安装这个工具，在<code>Cargo.toml</code>文件中添加一些配置，然后你就可以继续了。</p>
<pre><code class="language-toml"># cargo-apk compiles your code to an .so file,
# which is then loaded by the Android runtime
[lib]
path = &quot;src/main.rs&quot;
crate-type = [&quot;cdylib&quot;]
 
# Android-specic configuration follows.
[package.metadata.android]
# Name of your APK as shown in the app drawer and in the app switcher
apk_label = &quot;Hip Startup&quot;
 
# The target Android API level.
target_sdk_version = 29
min_sdk_version = 26
 
# See: https://developer.android.com/guide/topics/manifest/activity-element#screen
orientation = &quot;portrait&quot;
</code></pre>
<p>有了上面添加的配置，我试图使用<code>cargo-apk</code>来构建项目。</p>
<pre><code class="language-console">$ cargo install cargo-apk
$ export ANDROID_SDK_ROOT=&quot;${HOME}/android/sdk&quot;
$ export ANDROID_NDK_ROOT=&quot;${HOME}/android/ndk&quot;
$ cargo apk build --target aarch64-linux-android
</code></pre>
<p>令人惊奇的是，它成功了！(等等) 额，好吧，我再一次遇到了链接错误。但是这一次，它不是关于重定位和文件格式的神秘错误，而是一个缺少链接库的错误提示：</p>
<pre><code class="language-console">error: linking with `aarch64-linux-android29-clang` failed: exit code: 1
    aarch64-linux-android/bin/ld: cannot find -lsqlite3
    clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<h2 id="依赖依赖依赖"><a class="header" href="#依赖依赖依赖">依赖，依赖，依赖</a></h2>
<p>我们的项目使用 <a href="https://sqlite.org/">SQLite</a>，这是一个 C 库。尽管 Rust 社区在每个可能的场合都吹捧 (tout) ”用 Rust 重写“在某种程度上是臭名昭著的，但是实际上某些与流行库一起使用的 crate 并不需要重新实现，因为这需要大量的 (colossal) 工作。相反，它们仅提供在 Rust 代码中调用库的方式，既可以作为 C 函数重新导出，也可以提供更加友好的 API 并稍微抽象化 FFI 调用。我们使用的 <a href="https://crates.io/crates/rusqlite">rusqlite</a> 并没有什么不同，意味着我们也需要构建 SQLite。</p>
<p>SQLite 使用 GNU Autotool 进行构建。在对环境变量和用于配置的选项有了一些了解之后，我仔细浏览了 NDK 的文档 - 我找到了一个在各种构建系统(<a href="https://developer.android.com/ndk/guides/other_build_systems#autoconf">包括 Autotools</a>) 中使用 NDK 的文档页面。尽管 Google 提供了 LTS 版本的 NDK，以及最新版本的文档，但在 r21 LTS 和最新的 r22 之间发生了变化，事情变得稍微有点棘手。幸运的是，Wayback 机器具有该页面的<a href="http://web.archive.org/web/20200531051836/https://developer.android.com/ndk/guides/other_build_systems#autoconf">历史版本</a>，让我能够找到合适的 NDK r21 的说明。</p>
<pre><code class="language-console">$ ANDROID_API=29
$ TOOLCHAIN=&quot;${ANDROID_NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64&quot;i
$ export CC=&quot;${TOOLCHAIN}/bin/aarch64-linux-android${ANDROID_API}-clang&quot;
$ export CXX=&quot;${TOOLCHAIN}/bin/aarch64-linux-android${ANDROID_API}-clang++&quot;
$ export AR=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ar&quot;
$ export AS=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-as&quot;
$ export LD=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ld&quot;
$ export RANLIB=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ranlib&quot;
$ export STRIP=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-strip&quot;
$ ./configure --host=aarch64-linux-android --with-pic
$ make -j $(nproc)
</code></pre>
<h2 id="pick-me-up-scotty"><a class="header" href="#pick-me-up-scotty">Pick me up, Scotty</a></h2>
<p>使用上述方法，成功构建了 SQLite，生成了<code>libsqlite3.so</code>。现在只需要知道如何让 Cargo 使用它即可。在浏览 Cargo Book 时，我遇到了讲述<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html">环境变量</a>的一个章节，它提及了<code>RUSTFLAGS</code>。和 Make 或 CMake 对待<code>CFLAGS</code>和<code>CXXFLAGS</code>一样，<code>RUSTFLAGS</code>的内容被 Cargo 传递给<code>rustc</code>编译器，允许它影响编译器的行为。</p>
<p>尽管这种方式十分简单，但是对我来说不是很优雅，因此我进一步深入研究了其他选项。继续浏览 Cargo Book，我遇到了描述项目配置的章节，可以肯定的是，<a href="https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags">有一种方法可以指定 RUSTFLAGS</a>。然而，无论我如何尝试，我始终都会收到来自 Cargo 的提示，告诉我关于未使用的 manifest 键的信息。</p>
<pre><code class="language-console">warning: unused manifest key: target.aarch64-linux-android.rustflags
</code></pre>
<p>浏览 Cargo Book 的更多章节，我遇到了关于<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">构建脚本</a>的章节。它们毫无疑问是一个强大的工具，但是我已经花费了很多时间摸索 (fumble) 学习 Cargo 的配置，不想再花更多的时间阅读关于如何编写构建脚本的内容，因此，最终我选择了环境变量的解决方案，<del>并且可能会在之后尝试使用构建脚本的方式</del>(不可能)。</p>
<p>我在终端中输入命令，并焦急的观察它的执行过程。</p>
<pre><code class="language-console">$ RUSTFLAGS=&quot;-L $(pwd)/sqlite-autoconf-3340000/.libs/&quot; cargo apk build --target aarch64-linux-android
</code></pre>
<p>再一次，它。。。在某种程度上成功了。虽然链接器不再将错误解释成缺失库，但是<code>cargo-apk</code>无法找到该链接器并将其添加到最终的 APK 文件中。</p>
<pre><code class="language-console"> 'lib/arm64-v8a/libstartup.so'...
Shared library &quot;libsqlite3.so&quot; not found.
Verifying alignment of target/debug/apk/statup.apk (4)...
      49 AndroidManifest.xml (OK - compressed)
     997 lib/arm64-v8a/libstartup.so (OK - compressed)
Verification succesful
</code></pre>
<p>当我还没有编译<code>libsqlite3.so</code>时，我返回上一步仔细阅读了链接器产生的错误信息。链接器组合了很多的目标文件，这些目标文件都位于<code>target/aarch64-linux-android/debug/deps</code>目录下。如果我将<code>.so</code>文件放在这里会发生什么？</p>
<pre><code class="language-console">$ cp sqlite-autoconf-3340000/.libs/sqlite3.so target/aarch64-linux-android/debug/deps
$ cargo apk build --target aarch64-linux-android
</code></pre>
<p>让我惊讶的是，它成功了！</p>
<pre><code class="language-console"> 'lib/arm64-v8a/libstartup.so'...
 'lib/arm64-v8a/libsqlite3.so'...
Verifying alignment of target/debug/apk/startup.apk (4)...
      49 AndroidManifest.xml (OK - compressed)
     997 lib/arm64-v8a/libstatup.so (OK - compressed)
15881608 lib/arm64-v8a/libsqlite3.so (OK - compressed)
Verification succesful
</code></pre>
<p>我现在有了一个可以安装在 Android 手机上的<code>.apk</code>文件。真是个巨大的成功！</p>
<h2 id="应用-和-activity"><a class="header" href="#应用-和-activity">应用 和 Activity</a></h2>
<p>将 Rust 代码编译进<code>.apk</code>中后，我们剩下要做的就是要搞清楚如何将 Rust 代码与编写 UI 的 Java 代码合并。我天真的在 DuckDuckGo 中输入“如何组合 APK”。在阅读顶层几个结果后，明白了这明显是不可能的，至少在对 Android 应用的工作原理没有更深的了解的情况下是不可能的。但是，并不是说没有其他的方法，因为文章提出了另一种方法 - 将 <a href="https://developer.android.com/reference/android/app/Activity">Activity</a> 组合到一个应用程序里。</p>
<p>如果你像我一样，之前从未开发过 Android，可能会疑惑“什么是 Activity”：当你设计一个应用时，它就是所谓的“界面”或者“视图”。例如，在购物应用中：</p>
<ul>
<li>登陆页面是一个 Activity</li>
<li>产品搜索页面是一个 Activity</li>
<li>所选产品的详情页面是一个 Activity</li>
<li>购物车页面是一个 Activity</li>
<li>结账页面是一个 Activity</li>
</ul>
<p>这里的每个页面可能都包含一些交互元素，如无处不在的汉堡包菜单。如果你愿意，从理论上来讲，你可以将整个应用程序放在一个单独的 Activity 中，但是开发难度比较大。当然，关于 Activity 还有很多内容可以介绍，但是目前和我们要讲的内容关系不大。</p>
<p>让我们继续介绍有关 Rust 的内容。虽然我的问题的解决方案是将 Activity 组合到一个应用程序中，但是我不确定用 Rust 构建的<code>.apk</code>文件是如何与所有这些联系在一起的。在仔细研究了 <a href="https://github.com/rust-windowing/android-ndk-rs/blob/b430a5e274dea8fd7c45e176d5d19c31b73a20ac/ndk-glue/src/lib.rs#L132">cargo-apk</a> 代码之后，我意识到它本质是将我的代码封装进一些胶水 (glue) 代码中，并为 Android 的运行创建 <a href="https://developer.android.com/reference/android/app/NativeActivity">NativeActivity</a>。</p>
<p>为了将 Activity 组合进一个应用中，我需要修改 (tinker with) 应用程序的<code>AndroidManifest.xml</code>文件，在文档中添加合适的 <a href="https://developer.android.com/guide/topics/manifest/activity-element">Activity 节点</a>。但是我应该如何知道<code>cargo-apk</code>生成的 NativeActivity 的属性呢？幸运的是，当<code>cargo-apk</code>工作时，它会生成一个最小版的<code>AndroidManifest.xml</code>文件，并将其放在生成的<code>.apk</code>旁边。其中 NativeActivity 的声明如下所示：</p>
<pre><code class="language-xml">&lt;activity
    android:name=&quot;android.app.NativeActivity&quot;
    android:label=&quot;startup&quot;
    android:screenOrientation=&quot;portrait&quot;
    android:launchMode=&quot;standard&quot;
    android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;&gt;
    &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;startup&quot; /&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>我要做的就是将上面的代码片段复制并粘贴到 Java 应用程序的 manifest 中。</p>
<p>当然，这只是在应用的 manifest 中添加了一条语句，告诉应用将要包含哪些 Activity。Java 应用程序的构建过程不会知道<code>libstartup.so</code>文件的位置，并自动的将其包含在内。幸运的是，我只需要将<a href="https://developer.android.com/studio/projects/gradle-external-native-builds#jniLibs">库文件复制到指定的文件夹下</a>即可，Gradle (Android 应用的构建工具) 会自动将它们采集起来。</p>
<pre><code class="language-console">$ mkdir -p android/app/src/main/jniLibs/arm64-v8a
$ cp sqlite-autoconf-3340000/.libs/libsqlite3.so android/app/src/main/jniLibs/arm64-v8a/
$ cp target/aarch64-linux-android/debug/libstatup.so android/app/src/main/jniLibs/arm64-v8a/
$ cd android/ &amp;&amp; ./gradlew &amp;&amp; ./gradlew build
</code></pre>
<p>这些都完成后，我启动了构建，它成功了！我将<code>.apk</code>安装在我闲置的 (laying around) Android 设备中，但是...好像有哪里不太对劲呢！</p>
<p><img src="./img/two-launcher-activities.png" alt="two-launcher-activities" /></p>
<p>我的应用一旦安装成功后，会在应用的启动界面产生两个快捷方式。其中一个启动 Java 的 UI 界面，而另一个启动包含 Rust 代码的 NativeActivity。在阅读了更多关于 Activity 和 AndroidManifest 的内容后，我了解到，造成此问题的部分是 NativeActivity 的 <a href="https://developer.android.com/guide/topics/manifest/intent-filter-element"><intent-filter></a> - 即 (namely) <a href="https://developer.android.com/reference/android/content/Intent#CATEGORY_LAUNCHER">category</a> 节点声明应在启动器中显示它。一旦我将它移除，一切就会恢复正常，NativeActivity 不再显示在启动器中。</p>
<p>但是，仍然存在一个问题：我如何让 Java 的 Activity 要求 Rust 的Activity 为其工作？</p>
<h2 id="恶意的-malicious-intent"><a class="header" href="#恶意的-malicious-intent">恶意的 (Malicious) Intent</a></h2>
<p>Android 中的 Activity 可以毫无问题的相互启动 - 如果这不可能，则无法真正在两者之间传递用户信息。调用另一个 Activity 的标准方法是通过 <a href="https://developer.android.com/reference/android/app/Activity#starting-activities-and-getting-results">startActivity()</a> 方法，该方法接收一个参数：<a href="https://developer.android.com/reference/android/content/Intent.html">Intent</a> 类实例。</p>
<p>尽管 Intent 类的名称是不言而喻的 (self-explanatory)，但是起初它的用法可能有点不直观。在它最基本的形式中，它仅包含对调用 Activity 实例的引用，以及我们要调用的 Activity 的类句柄。(确切的说，一个 Intent 需要调用一个 <a href="https://developer.android.com/reference/android/content/Context.html">Context</a>。Activity 只是 Context 的一种类型)。</p>
<p>但是，Intent 也可以用于传达为什么一个 Activity 会调用另一个 Activity 的信息(例如 <a href="https://developer.android.com/reference/android/content/Intent#standard-activity-actions">action</a>)，可以用来区分例如“显示某些内容”和“编辑某些内容”；或要操作的数据 URI 及其 MIME 类型。除了 get/set 方法，Intent 还可以容纳几乎任何数量的“额外”数据，这些数据通常作为键值对存储。</p>
<p>Intent 提供了一种在 Activity 之间传递信息的标准化方式。调用者向被调用者提供处理其请求所需的一切信息，并且它可以接收包含所有请求信息的另一个 Intent 作为返回值。使用 Java 编写代码时，没有什么问题，但是，将 Rust 代码放入 NativeActivity 会发生什么？</p>
<p>如果你查看继承树，你可以看到 NativeActivity 继承了 Activity - 这意味着它可以访问 Activity 所有非私有方法。我可以调用<code>getIntent()</code>并从调用者中获取数据。除此之外，由于这是 Java 方法，并且我是在 native 代码中运行，因此需要使用 JNI (Java Native Interface) 执行函数调用。不幸的是，NativeActivity 没有任何其他的机制来传递信息或使用 Intent。这让我十分沮丧 (dismay)，因为这意味着我必须要与 JNI 一起工作。</p>
<h2 id="jni-之旅"><a class="header" href="#jni-之旅">JNI 之旅</a></h2>
<p>在这一点上，我花了太多时间却没有取得明显的 (tangible) 成果，这让我感到十分沮丧。另一方面，我意识到使用 JNI 带来了一些新的可能 - 不必使用 Activity 和 Intent，我可以将代码粘贴在函数中，并通过调用参数和返回值进行通信。有了这个新思路，我开始了对 JNI 的研究。</p>
<p>因为在 Java 中，万物皆对象，并且代码不能存在于类之外的部分 - native 代码也必须是类的一部分。因为我不需要持久化，因此简单的使用静态方法就很有用。</p>
<pre><code class="language-java">package com.startup.hip;
 
public class RustCode {
    public static native void doStuff();
}
</code></pre>
<p>上面是一个 Java 类的最小示例，其中带有一个标记为<code>native</code>的静态方法。有了这个，我需要实现相应的功能。但是我应该如何正确的使用函数签名呢？</p>
<p>幸运的是，Java 具有为 JNI 生成 C 语言头文件的功能。在 Java SE9 之前，它是一个独立的工具 - <a href="https://docs.oracle.com/javase/9/tools/javah.htm">javah</a>；后来，它作为<code>-h</code>选项合并到了主要的<code>javac</code>编译器可执行文件中。该选项需要一个目录参数，用来放置生成的<code>.h</code>文件。用法十分简单。</p>
<pre><code class="language-console">$ javac -h ./ RustCode.java
</code></pre>
<p>调用上面的命令将创建一个<code>com_startup_hip_RustCode.h</code>文件，其中包含函数定义。</p>
<pre><code class="language-cpp">#include &lt;jni.h&gt;
JNIEXPORT void JNICALL Java_com_startup_hip_RustCode_doStuff(JNIEnv *, jclass);
</code></pre>
<p>有了这些知识，我就可以继续在 Rust 中创建适当的函数了。</p>
<h2 id="c-闪回"><a class="header" href="#c-闪回">C++ 闪回</a></h2>
<p>当处理外部代码时，Rust 和 C 很像，主要是使用 <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">extern 块</a>。此外，与 C++ 一样，Rust 可以使用 <a href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a> - 这不足为奇，因为这门语言对范型和宏提供了强大的支持。幸运的是，Rust 提供了一种简单的方式来禁用 name mangling - 使用 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#calling-rust-functions-from-other-languages">#[no mangle]</a> 注解。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jni::{objects::JClass, JNIEnv};
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff(
    _env: JNIEnv,
    _class: JClass,
) {}
<span class="boring">}
</span></code></pre></pre>
<p>创建了函数声明之后，接下来我需要编写对应的实现。</p>
<h2 id="接收参数"><a class="header" href="#接收参数">接收参数</a></h2>
<p>通常，native 函数需要接收一些参数。在本例中，它是一个包含代码的字符串，该代码随后将被传递给服务端。</p>
<pre><code class="language-java">package com.startup.hip;
 
public class RustCode {
    public static native void doStuff(String code);
}
</code></pre>
<p>修改 Java 代码之后，我重新生成了 C 语言的头文件并据此编辑了 Rust 代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jni::{objects::JClass, JNIEnv};
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff(
    _env: JNIEnv,
    _class: JClass,
    code: JString,
) {}
<span class="boring">}
</span></code></pre></pre>
<p>这很简单。现在我需要从 Java 字符串中提取文本并将其传递给 Rust 代码。这比我预期 (anticipate) 要复杂的多。问题在于，JVM 内部使用 <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/types.html#modified-utf-8-strings">UTF-8 的修改版本</a>存储字符串，而 Rust 字符串必须是有效的 <a href="https://doc.rust-lang.org/std/string/struct.String.html#utf-8">UTF-8</a>。尽管 Rust 具有用于<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">处理任意字符串</a>的类型，但是我们的代码仅使用“经典”的字符串类型，对其进行全部修改需要大量工作。</p>
<p>幸运的是，<code>jni</code>库带有内置的机制，可以通过特殊的 <a href="https://docs.rs/jni/0.19.0/jni/strings/struct.JNIStr.html">JNIStr</a> 类型在标准 UTF-8 和 JVM 修改后的 UTF-8 之间进行转换。在仔细阅读了文档之后，我想到了以下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert from JString – a thinly wrapped JObject – to a JavaStr
let code_jvm = env.get_string(code).unwrap();
// Create a String from JavaStr, causing text conversion
let code_rust = String::from(code_jvm);
<span class="boring">}
</span></code></pre></pre>
<p>现在我有了一个 Rust 字符串，可以将其传递给之后的 Rust 代码。又是个巨大的成功！</p>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<p>接收参数只是故事的一半，我还需要一个返回值，巧的是，它也是一个字符串 - 一个代表服务端返回值的字符串。</p>
<pre><code class="language-java">package com.startup.hip;
 
public class RustCode {
    public static native String doStuff(String code);
}
</code></pre>
<p>我再一次修改了 Java 代码，重新生成了 C 语言的头文件，并据此编辑 Rust 代码。</p>
<pre><code class="language-java">use jni::{objects::JClass, JNIEnv};
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff&lt;'a&gt;(
    env: JNIEnv&lt;'a&gt;,
    _class: JClass,
    code: JString,
) -&gt; JString&lt;'a&gt;
{
    // function body here
}
</code></pre>
<p>如你所见，JNI 中的返回值仍然作为返回值处理。剩下要做的事就是创建保存结果的 JString。与<code>get_string()</code>类似，<code>JNIEnv</code>结构还包含一个<code>new_string()</code>函数，该函数的功能与名称指代的完全相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copy-pasted from earlier snippet 
let code_rust = String::from(env.get_string(code_jni).unwrap());
 
let result = match some_rust_function(code_rust) {
    Ok(value) =&gt; format!(&quot;OK {}&quot;, value),
    Err(e) =&gt; format!(&quot;ER {:?}&quot;, e),
};
return env.new_string(result).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>就像这样，我的 JNI 封装器就完成了。现在，我可以在 Java 代码中调用 Rust 函数，将值传递给调用并接收返回值。</p>
<h2 id="rust-的错误处理"><a class="header" href="#rust-的错误处理">Rust 的错误处理</a></h2>
<p>尽管代码如预期一样执行，但是我不喜欢出现的<code>.unwrap()</code>调用次数。毕竟，错误处理是 Rust 的重要组成部分，仅仅因为我正在进行语言的互操作，并不意味着就可以忽略此事。恰恰相反，我认为两种语言的接触面应该尽可能简单，以防止最终发现一些晦涩的错误是由于互操作性差而引起的。而且，必须检查 Java 的返回值以确定调用是否成功，这使得整个过程使用起来有些笨拙 (clunky)。</p>
<p>我没有重复造轮子，而是对如何更好的将 Rust 的 <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result&lt;A, B&gt;</a> 方式转换成 Java 侧的代码进行了思考。幸运的是，我的 Rust 函数的返回值都是字符串。至于错误，大多数错误要么是不可恢复的，要么是由错误的输入引起的 - 这意味着我可以放弃 (forego) 使用精确的错误代码，而仅仅依靠正确格式的错误信息 - 这又是指字符串。因此<code>Result&lt;A, B&gt;</code>可以变成<code>Result&lt;String, String&gt;</code>。</p>
<h2 id="定义-java-类"><a class="header" href="#定义-java-类">定义 Java 类</a></h2>
<p>尽管 Java 支持范型(虽然有点<a href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">欺骗</a>的感觉)，但是我不想从 JNI 中深入了解使用范型的细节。我决定创建一个 Java 类，大致表示<code>Result&lt;String, String&gt;</code>语义。</p>
<pre><code class="language-java">public class Result {
    private boolean ok;
    private String value;
 
    public Result(boolean is_ok, String value) {
        this.ok = is_ok;
        this.value = value;
    }
 
    public boolean isOk() {
        return this.ok;
    }
 
    public boolean isError() {
        return !this.ok;
    }
 
    public String getValue() {
        return this.ok ? this.value : null;
    }
 
    public String getError() {
        return this.ok ? null : this.value;
    }
}
</code></pre>
<p>尽管完成了这项工作，但与 Rust 相比，它有一些缺点 - 最严重的就是当访问错误的结果变量时返回<code>null</code>。由于 null 对于 Java 字符串来说是一个没有问题的值，因此调用<code>getValue()</code>可能没有注意并将其传递给其他地方导致在无关紧要的代码中弹出 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html">NullPointerException</a>。尽管可以通过抛出异常来轻松地改善这个问题，我仍决定使用最好的方式来处理这个问题，以便此处以后永远也不需要添加新的内容。</p>
<h2 id="从-jni-中返回一个对象"><a class="header" href="#从-jni-中返回一个对象">从 JNI 中返回一个对象</a></h2>
<p>剩下的唯一一件事就是从 Rust 函数中返回 Result 类的实例。经过一番搜索后，我找到了名为 <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/functions.html#newobject-newobjecta-newobjectv">NewObject()</a> 的 JNI 函数。该函数有四个参数：</p>
<ul>
<li>JNI 环境的句柄</li>
<li>我们想要创建的类的句柄</li>
<li>构造函数签名</li>
<li>构造函数的参数</li>
</ul>
<p>Rust 函数将 JNI 环境句柄作为其参数之一，因此已经进行了处理。构造函数参数可以作为数组传递，我需要找到另外两个函数参数。</p>
<p>为了获取该函数的句柄，JNI 提供了<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/functions.html#findclass">FindClass()</a>函数。它有两个参数：环境句柄和类的完全限定名 - 简单的说就是类的“导入名”，但是<code>.</code>用<code>/</code>代替。例如<code>java.lang.String</code>变成<code>java/lang/String</code>。在本例中是指，<code>com.startup.hip.Result</code>变成<code>com/startup/hip/Result</code>。</p>
<p>构造函数签名是一个字符串，它很好的描述了构造函数签名需要多少个参数以及哪些类型。乍一看，这让人有些困惑 - 但后来我想起 Java 支持函数重载，并且还包括构造函数。由于一个类可能有多个构造函数，所以我必须让 JNI 知道我想使用哪个构造函数。在互联网上搜索了之后，我发现最简单的学习函数签名的方法就是编译 Java 类。然后使用 Java 的反汇编工具：<a href="https://docs.oracle.com/en/java/javase/11/tools/javap.html">javap</a>。</p>
<pre><code class="language-console">$ javac android/app/src/main/java/com/startup/hip/Result.java
$ javap -s android/app/src/main/java/com/startup/hip/Result.class
Compiled from &quot;Result.java&quot;
public class com.startup.hip.Result {
  public com.startup.hip.Result(boolean, java.lang.String);
    descriptor: (ZLjava/lang/String;)V

  public boolean isOk();
    descriptor: ()Z

  public boolean isError();
    descriptor: ()Z

  public java.lang.String getValue();
    descriptor: ()Ljava/lang/String;

  public java.lang.String getError();
    descriptor: ()Ljava/lang/String;
}
</code></pre>
<p>执行了上述的命令，现在我知道了我想要使用的函数签名是<code>(ZLjava/lang/String;)V</code>。</p>
<p>在所有步骤都准备就绪之后，是时候创建持有构造函数参数的数组，并调用<code>NewObject()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_java_result&lt;'e&gt;(
    env: &amp;JNIEnv&lt;'e&gt;,
    is_ok: bool,
    value: &amp;str,
) -&gt; JObject&lt;'e&gt;
{
    let class = env
        .find_class(&quot;com/startup/hip/Result&quot;)
        .unwrap();
    let args: [JValue&lt;'e&gt;; 2] = [
        JValue::Bool(u8::from(is_ok)),
        JValue::Object(JObject::from(env.new_string(value).unwrap())),
    ];
    env.new_object(class, &quot;(ZLjava/lang/String;)V&quot;, &amp;args)
        .unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我可以从 native 函数中返回自定义的<code>Result</code> Java 类了。</p>
<h2 id="使用更通用的解决方案"><a class="header" href="#使用更通用的解决方案">使用更通用的解决方案</a></h2>
<p>尽管上面的代码可以很好的实现这个目的，但是它有一个缺点：它显示地采用了布尔值和字符串，要求调用者自己处理 Result 并使用适当的参数调用函数。编写“错误应该尽早返回”的逻辑很繁琐 (tedious)，但是幸运的是，Rust 为此提供了一个解决方案 - <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html">?</a> 运算符。但是我们的代码从不同的库中调用函数，这些函数又使用了不同的错误类型 - 这意味着我们无法使用<code>Result&lt;OurType, OurError&gt;</code>，并且必须执行类似 (akin) <code>Result&lt;OurType, std::error::Error&gt;</code>的操作 - 这是不可能的，因为 Rust 不允许将特征用作函数的返回类型。</p>
<p>解决此问题的标准方法是使用 <a href="https://doc.rust-lang.org/rust-by-example/trait/dyn.html">Box<dyn Trait></a>，但为了使事情变得更加简单，我决定使用 <a href="https://crates.io/crates/anyhow">anyhow</a> 库，该库允许按我的喜好混合和匹配错误。不管怎样，我可以这样编写代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rust_result_to_java_result&lt;'e, T&gt;(
    env: &amp;JNIEnv&lt;'e&gt;,
    result: anyhow::Result&lt;T&gt;,
) -&gt; JObject&lt;'e&gt;
where
    T: Display,
{
    let (is_ok, value) = match result {
        Ok(v) =&gt; (true, format!(&quot;{}&quot;, v)),
        Err(e) =&gt; (false, format!(&quot;{:?}&quot;, e)),
    };
    create_java_result(env, is_ok, value)
}
 
fn actually_do_stuff&lt;'a&gt;(
    env: JNIEnv&lt;'a&gt;,
    code: JString,
) -&gt; anyhow::Result&lt;String&gt;
{
    let code = String::from(env.get_string(code)?);
    let intermediate_value = some_rust_function(code)?;
    other_rust_function(intermediate_value)
}
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff&lt;'a&gt;(
    env: JNIEnv&lt;'a&gt;,
    _class: JClass,
    code: JString,
) -&gt; JObject&lt;'a&gt;
{
    rust_result_to_java_result(actually_do_stuff(env, code))
}
<span class="boring">}
</span></code></pre></pre>
<p>更简单了！现在我可以返回任何想要的结果，并将其转换为 Java 类的实例，以供 Java 代码使用。</p>
<h2 id="封装"><a class="header" href="#封装">封装</a></h2>
<p>在 Android 中运行 Rust 并不是一件容易的事，但是我对最终找到的解决方案感到满意。我们使用及其普通 (bog-standard) 的 Rust 编写代码并将其编译到共享库中，然后由 JVM 在运行时加载。尽管 JNI 乍一看有点令人生畏 (intimidate)，但是使用此标准化解决方案意味着 Java 代码和 Gradle 构建系统都不关心我们的 native 代码是用 Rust 编写的。使用 Cargo 进行交叉编译仍然有些棘手 (tricky)，因为事实证明<code>cargo-apk</code>设置了许多<a href="https://github.com/rust-windowing/android-ndk-rs/blob/7936944edc699d3e7f380cfa87515f8899ce7027/ndk-build/src/cargo.rs#L6">环境变量</a>以使整个过程正常运行。我们的代码还依赖于外部库 - 但是所有的这些都可以通过一堆 shell 脚本来解决。</p>
<p>如果你想要自己尝试一下，我已经准备了一个公共 <a href="https://github.com/suve/rust-on-android/">Github</a> 仓库，其中包含了一个最小的 Android 应用程序，既包含用 Rust 编写的部分，还依赖于外部的 C 库。该项目的许可证是 <a href="https://tldrlegal.com/license/zlib-libpng-license-%28zlib%29">zlib</a>。因此可以随意的获取源代码并将其用于你的个人目的。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://developer.android.com/ndk/guides/other_build_systems#autoconf">Android NDK documentation: other build systems: Autoconf</a></li>
<li><a href="https://crates.io/crates/cargo-apk">crates.io: cargo-apk</a></li>
<li><a href="https://github.com/rust-windowing/android-ndk-rs/blob/b430a5e274dea8fd7c45e176d5d19c31b73a20ac/ndk-glue/src/lib.rs#L132">cargo-apk: ndk-glue/src/lib.rs</a></li>
<li><a href="https://github.com/rust-windowing/android-ndk-rs/blob/7936944edc699d3e7f380cfa87515f8899ce7027/ndk-build/src/cargo.rs#L6">cargo-apk: nkd-build/src/cargo.rs</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/activity-element">Android developer documentation: app manifest: <activity></a></li>
<li><a href="https://developer.android.com/reference/android/app/Activity">Android developer documentation: Activity</a></li>
<li><a href="https://developer.android.com/reference/android/app/NativeActivity">Android developer documentation: NativeActivity</a></li>
<li><a href="https://developer.android.com/reference/android/content/Intent.html">Android developer documentation: Intent</a></li>
<li><a href="https://crates.io/crates/jni">crates.io: jni</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html">Java SE 11: JNI specification</a></li>
<li><a href="https://docs.oracle.com/javase/9/tools/javah.htm">Java SE 9: tools: javah</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#calling-rust-functions-from-other-languages">The Rust Programming Language: Calling Rust Functions from Other Languages</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/11/tools/javap.html">Java SE 11: tools: javap</a></li>
<li><a href="https://www.thorntech.com/2012/08/using-jni-with-java-for-android-sawbix-case-study-part-ii/">Thorn Technologies: Using JNI to call C functions from Android Java</a></li>
<li><a href="https://coderanch.com/t/446953/java/create-NewObject-JNI-methods">Code Ranch: How to create new objects with JNI</a></li>
<li><a href="https://stackoverflow.com/questions/22038466/jni-signature-for-method">Stack Overflow: Java signature for method</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../theme/ferris.js"></script>
        

        

    </body>
</html>
