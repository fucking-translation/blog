<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 异步执行器 - Blog Translation</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../../theme/ferris.css">
                <link rel="stylesheet" href="../../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html" class="active"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li><li class="chapter-item "><a href="../../lang/rust/20-rust如何实现线程安全.html"><strong aria-hidden="true">1.20.</strong> Rust 如何实现线程安全</a></li><li class="chapter-item "><a href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html"><strong aria-hidden="true">1.21.</strong> 无需 fork Clippy 就可以编写 Rust lint</a></li><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.22.</strong> 标准库</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.22.1.</strong> std::pin</a></li><li class="chapter-item "><a href="../../lang/rust/std/21-std-condvar.html"><strong aria-hidden="true">1.22.2.</strong> std::sync::Condvar</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li><li class="chapter-item "><a href="../../oci/summary.html"><strong aria-hidden="true">3.</strong> Open Container Initiative</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../oci/01-oci-spec-overview.html"><strong aria-hidden="true">3.1.</strong> OCI 规范概述</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-异步执行器"><a class="header" href="#rust-异步执行器">Rust 异步执行器</a></h1>
<p><a href="https://jblog.andbit.net/2019/11/10/rust-async-execution/">原文</a></p>
<p>作为从事大量并发工作(尤其是在 <a href="https://fanout.io/">Fanout</a> 的网络工作)的老牌 C/C++ 程序员，<a href="https://www.rust-lang.org/">Rust</a> 编程语言及其最近的<a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">异步</a>功能引起了我的兴趣 (intrigued)。</p>
<p>像 C/C++ 一样，Rust 没有运行时。有趣的是，即使引入了异步也同样如此。使用<code>async</code>和<code>await</code>关键字可以并发的运行代码。你需要使用自己的运行时(如：Tokio 或 async-std) 与语言的核心元素进行交互。</p>
<p>但是，你也可以实现自己的运行时！在过去的几个月中，我一直在学习所有的实现细节。在本文中，我将描述如何仅使用标准库来执行 Rust 的异步函数。</p>
<p>关于 异步以及 future 其他文章已经写了很多，因此本文主要关注于如何构建执行程序。</p>
<h2 id="语言-vs-运行时"><a class="header" href="#语言-vs-运行时">语言 vs 运行时</a></h2>
<p>Rust 提供了一下几种基本特性：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/future/trait.Future.html">Future</a> 特征：允许逐步执行某项操作。</li>
<li><code>async</code>关键字：重写你的代码以实现<code>Future</code>。</li>
<li><code>await</code>关键字：允许在生成的异步代码中使用其他的<code>Future</code>实例。</li>
</ul>
<p>就是这样。值得注意的是，Rust 在你使用<code>async</code>关键字生成<code>Future</code>之外并没有提供<code>Future</code>的具体实现。</p>
<p>为了使用 Rust 的异步特性做一些有用的事情，你将需要一些<code>Future</code>实现(仅使用生成的<code>Future</code>是没有意义的)，以及一种执行<code>Future</code>实例的方法。</p>
<p>我个人认为这是一个出色的设计。Rust 能够提供相当不错的异步语法，而不用提交给特定的运行时。</p>
<p>请注意，尽管听起来好像语言本身没有提供太多的功能，但是其内置的异步代码生成却是一个具有<a href="https://tmandry.gitlab.io/blog/posts/optimizing-await-1/">挑战性的问题</a>。</p>
<h2 id="实现一个-future"><a class="header" href="#实现一个-future">实现一个 Future</a></h2>
<p>下面是对<code>Future</code>特征的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以手动实现一个<code>Future</code>。举个例子：下面这个 Future 可以产生一个整数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::task::{Context, Poll};

struct IntFuture {
    x: i32,
}

impl Future for IntFuture {
    type Output = i32;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;i32&gt; {
        Poll::Ready(self.x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>或者你可以通过<code>async</code>关键字来构建具有同样功能的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn int_future(x: i32) -&gt; i32 {
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>在以上两种情况下，我们最终都具有满足<code>Future&lt;Output = i32&gt;</code>的类型：</p>
<pre><pre class="playground"><code class="language-rust">fn eat&lt;F: Future&lt;Output = i32&gt;&gt;(_: F) {}

fn main() {
    eat(IntFuture { x: 42 });
    eat(int_future(42));
}
</code></pre></pre>
<h2 id="嵌入的-future"><a class="header" href="#嵌入的-future">嵌入的 future</a></h2>
<p>如果你有一个异步函数的调用链，举个例子：一个 HTTP 请求的异步函数调用 TCP I/O 的异步函数，它将被编译为单个封装的<code>Future</code>。对这个 future 进行轮询将导致对其内部的 future 进行轮询。进行轮询的任何操作都不会对内部 future 有任何感知。</p>
<p>举个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_audience() -&gt; &amp;'static str {
    &quot;world&quot;
}

async fn make_greeting() -&gt; String {
    let audience = get_audience().await;

    format!(&quot;hello {}&quot;, audience)
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面的代码中，如果调用<code>make_greeting()</code>来获取一个 future，轮询这个 future 将会依次轮询由<code>get_audience()</code>生成的 future，但这可以视为<code>make_greeting()</code>的实现细节。</p>
<p>所有这一切都说明：在执行 future 时，我们实际上只需要考虑最顶层的 future 即可。</p>
<h2 id="调用-poll"><a class="header" href="#调用-poll">调用 poll</a></h2>
<p>创建一个<code>Future</code>有点简单。轮询 future，也没有太多内容。我们再来看一下<code>poll()</code>的签名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>我们需要一个<code>Pin</code>和一个<code>Context</code>。你可能要问，这些到底是什么？</p>
<h2 id="pin"><a class="header" href="#pin">Pin</a></h2>
<p><code>Pin</code>是一种表示某些内存不会被移动的方式。通常，可以将结构从一个内存位置移动到另一个内存位置，而不会出现任何问题。这是因为 Rust 禁止在<code>safe</code>代码中进行自引用。举个例子，一个结构可以存储在栈上，然后被移动到堆上的<code>Box</code>中，并且 Rust 可以通过简单的复制字节来执行移动操作。然而，Rust 异步最伟大的成就之一就是可以在 await 点之间进行借用，这需要稍微调整规则。异步生成的 future 需要具有在使用 await 时保留对其内部内存引用的能力，因此需要确保其内存不会在<code>poll()</code>调用之间移动。</p>
<p>这里使用<code>Pin</code>的方式有点不直观。<code>poll()</code>函数消耗<code>Pin</code>。这意味着为了轮询一个 future，每次轮询的时候你都需要实例化一个新的<code>Pin</code>。看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut f = IntFuture { x: 42 };

let mut cx = ... // we'll talk about this later

let p = unsafe { Pin::new_unchecked(&amp;mut f) };

match p.poll(&amp;mut cx) {
    Poll::Ready(x) =&gt; println!(&quot;got int: {}&quot;, x),
    Poll::Pending =&gt; println!(&quot;future not ready&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>(请注意：有趣的是<code>Pin</code>可以被用作<code>self</code>类型。看起来 Rust 虽然将<code>self</code>限制为<code>T</code>，<code>&amp;T</code>以及<code>&amp;mut T</code>，还允许使用<a href="https://doc.rust-lang.org/reference/items/associated-items.html#methods">固定列表</a>中的其他类型)。</p>
<p>一旦通过<code>poll()</code>方法消耗并消毁了<code>Pin</code>，你是否就不打算保留固定的内存了？没有！对<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html#safety">文档</a>的质疑，“这个值一旦固定，就必须永远固定”。事实上，这就是为什么构建<code>Pin</code>是 unsafe 的原因。unsafe 的部分是你最终会丢失<code>Pin</code>，但是尽管没有<code>Pin</code>保护你了，你仍然需要坚持固定 (pinning) 合约。</p>
<h2 id="context-和-waker"><a class="header" href="#context-和-waker">Context 和 Waker</a></h2>
<p>当前，<code>Context</code>唯一要做的就是提供对<code>Waker</code>的访问。<code>Waker</code>用于指示如果<code>poll()</code>返回了<code>Poll::Pending</code>，则应在何时再次轮询 future。<code>poll()</code>采用<code>Context</code>而不是简单的<code>Waker</code>是为了实现扩展。在更高版本的 Rust 中，其他内容可能会添加到<code>Context</code>上。</p>
<p>构建<code>Context</code>需要一些努力。它唯一 (sole) 的构造函数<a href="https://doc.rust-lang.org/std/task/struct.Context.html#method.from_waker">Context::from_waker</a> 需要一个<code>Waker</code>。<code>Waker</code> 唯一的构造函数 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html#method.from_raw">Waker::from_raw</a> 需要一个<code>RawWaker</code>。并且<code>RawWaker</code>唯一的构造函数 <a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html#method.new">RawWaker::new</a> 需要一个<code>RawWakerVTable</code>。</p>
<p>让我们实现一个迷你版，不带任何操作的<code>RawWakerVTable</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::task::{RawWaker, RawWakerVTable};

unsafe fn vt_clone(data: *const ()) -&gt; RawWaker {
    RawWaker::new(data, &amp;VTABLE)
}

unsafe fn vt_wake(_data: *const ()) {
}

unsafe fn vt_wake_by_ref(_data: *const ()) {
}

unsafe fn vt_drop(_data: *const ()) {
}

static VTABLE: RawWakerVTable = RawWakerVTable::new(
    vt_clone,
    vt_wake,
    vt_wake_by_ref,
    vt_drop
);
<span class="boring">}
</span></code></pre></pre>
<p>然后我们可以像这样构建一个<code>Waker</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rw = RawWaker::new(&amp;(), &amp;VTABLE);

let w = unsafe { Waker::from_raw(rw) };
<span class="boring">}
</span></code></pre></pre>
<p>所有的这些 vtable 都是为了允许我们提供自己的唤醒行为。<code>RawWaker</code> 只是一个数据指针和一个 vtable。<code>Waker</code>对此进行了封装，并实现了熟悉的 Rust 特征，如<code>Clone</code>和<code>Drop</code>。<code>Waker</code>构造函数是 unsafe 的，因此 vtable 函数可能需要对原始指针进行解引用。</p>
<p>你可能想知道为什么 Rust 使用此自定义的 vtable 而不是使<code>Waker</code>成为特征。我相信这样做是为了使<code>Waker</code>可以被拥有，同时避免了堆分配。使用特征可能需要在某处添加<code>Box</code>。</p>
<p>最后，我们可以构建一个<code>Context</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut cx = Context::from_waker(&amp;w);
<span class="boring">}
</span></code></pre></pre>
<p>当然，在真实的应用中我们需要<code>Waker</code>做些什么。我们将在后面讨论这个问题。</p>
<h2 id="这次是真的调用-poll-了"><a class="header" href="#这次是真的调用-poll-了">这次是真的调用 poll() 了</a></h2>
<p>既然我们知道如何构建一个<code>Pin</code>和一个<code>Context</code>，我们可以调用<code>poll()</code>了。以下是轮询一个 future 程序的完整源代码：</p>
<pre><pre class="playground"><code class="language-rust">use std::future::Future;
use std::pin::Pin;
use std::task::{Poll, Context, Waker, RawWaker, RawWakerVTable};

unsafe fn vt_clone(data: *const ()) -&gt; RawWaker {
    RawWaker::new(data, &amp;VTABLE)
}

unsafe fn vt_wake(_data: *const ()) {
}

unsafe fn vt_wake_by_ref(_data: *const ()) {
}

unsafe fn vt_drop(_data: *const ()) {
}

static VTABLE: RawWakerVTable = RawWakerVTable::new(
    vt_clone,
    vt_wake,
    vt_wake_by_ref,
    vt_drop
);

async fn get_greeting() -&gt; &amp;'static str {
    &quot;hello world&quot;
}

fn main() {
    let mut f = get_greeting();

    let rw = RawWaker::new(&amp;(), &amp;VTABLE);
    let w = unsafe { Waker::from_raw(rw) };
    let mut cx = Context::from_waker(&amp;w);

    let p = unsafe { Pin::new_unchecked(&amp;mut f) };
    assert_eq!(p.poll(&amp;mut cx), Poll::Ready(&quot;hello world&quot;));
}
</code></pre></pre>
<h2 id="触发-waker"><a class="header" href="#触发-waker">触发 Waker</a></h2>
<p>让我们来创建一个知道如何唤醒自己的 future。</p>
<p>以下是计时器的实现。可以以期望的持续时间构建它。第一次轮询时，它会产生一个线程并返回<code>Poll::Pending</code>。下次轮询时，它将返回<code>Poll::Ready</code>。线程休眠然后调用<code>wake()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time;
use std::thread;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct TimerFuture {
    duration: time::Duration,
    handle: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl TimerFuture {
    fn new(duration: time::Duration) -&gt; Self {
        Self {
            duration,
            handle: None,
        }
    }
}

impl Future for TimerFuture {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;()&gt; {
        match &amp;self.handle {
            None =&gt; {
                let duration = self.duration;
                let waker = cx.waker().clone();
                self.handle = Some(thread::spawn(move || {
                    thread::sleep(duration);
                    waker.wake();
                }));
                Poll::Pending
            },
            Some(_) =&gt; {
                let handle = self.handle.take().unwrap();
                handle.join().unwrap();
                Poll::Ready(())
            },
        }
    }
}

// convenience wrapper for use in async functions
fn sleep(duration: time::Duration) -&gt; TimerFuture {
    TimerFuture::new(duration)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Waker</code>已被克隆，因此我们可以在<code>poll()</code>返回后继续使用它。事实上，我们还可以将其移动到另一个线程。</p>
<p>请注意，在实际的应用程序中，你不希望为每个计时器都生成一个线程。取而代之的是，计时器可能会在某些事件反应堆 (evented reactor) 中注册。不过在此示例中，我们将使其保持简单。</p>
<h2 id="管理不同类型的-future"><a class="header" href="#管理不同类型的-future">管理不同类型的 future</a></h2>
<p>在我们接触执行器之前，我们需要解决最后一个挑战：改变 future 的类型。</p>
<p>不同的 future 可以有不同的<code>Output</code>类型(如：<code>Future&lt;Output = i32&gt;</code>和<code>Future&lt;Output = String&gt;</code>)，因此，<code>poll()</code>也会有不同的返回值。这意味着如果我们要构建一个执行器，我们不能简单的通过将 future 放入类似<code>Vec&lt;Box&lt;dyn Future&gt;&gt;</code>的结构中，即使有可能，我们也无法使用相同的代码对其进行处理。</p>
<p>据我所知，解决方案是为执行器跟踪所有 future 选择一个共同的返回类型(即：顶级 future)。举个例子，你可以决定所有的顶级 future 都没有返回值类型，因此你可以将它们包含在<code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>中。请注意，嵌套的 future 仍然可以具有任意的 (arbitrary) 返回值类型。一个不带返回值的异步函数可以等待一个返回<code>String</code>的 future。之所以可行是因为所有的嵌套 future 都隐藏在外部的 future 中，而执行者只关心外部的 future。</p>
<p>我们的类型问题还不止于此。<code>poll()</code>函数需要其具体类型的固定引用。回忆一下前面大写的<code>Self</code>签名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这意味着即使两个不同的 future 实现都具有相同的<code>Output</code>类型并因此具有相同的特征，我们仍然无法使用非通用的代码来处理它们！</p>
<p>可能需要具体的类型，因此<code>Pin</code>可以保护一块已知大小的区域。无论如何，<code>dyn Future</code>都是没有用的。</p>
<p>解决此问题的一种方式是将细节隐藏在闭包中。我们可以使用单态化 (monomorphization) 为每个具体的 future 实现生成不同的代码，但是让闭包共享相同的函数签名。在下面，我们创建符合特征<code>dyn FnMut(&amp;mut Context) -&gt; Poll&lt;()&gt;</code>(对于带有<code>Output = ()</code>的 future) 的闭包，并将其装箱：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PollFn = dyn FnMut(&amp;mut Context) -&gt; Poll&lt;()&gt;;

struct WrappedFuture {
    poll_fn: Box&lt;PollFn&gt;,
}

impl WrappedFuture {
    pub fn new&lt;F&gt;(mut f: F) -&gt; Self
    where
        F: Future&lt;Output = ()&gt; + 'static
    {
        let c = move |cx: &amp;mut Context| {
            let p: Pin&lt;&amp;mut F&gt; = unsafe { Pin::new_unchecked(&amp;mut f) };
            match p.poll(cx) {
                Poll::Ready(_) =&gt; Poll::Ready(()),
                Poll::Pending =&gt; Poll::Pending,
            }
        };

        Self {
            poll_fn: Box::new(c),
        }
    }

    pub fn poll(&amp;mut self, cx: &amp;mut Context) -&gt; Poll&lt;()&gt; {
        (self.poll_fn)(cx)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用<code>WrappedFuture</code>，我们可以对所有 future 一视同仁：</p>
<pre><pre class="playground"><code class="language-rust">// generates Future&lt;Output = ()&gt;
async fn print_hello() {
    println!(&quot;hello&quot;);
}

// generates Future&lt;Output = ()&gt;
async fn print_goodbye() {
    println!(&quot;goodbye&quot;);
}

fn main() {
    let mut futures: Vec&lt;WrappedFuture&gt; = Vec::new();

    futures.push(WrappedFuture::new(print_hello()));
    futures.push(WrappedFuture::new(print_goodbye()));

    for f in futures.iter_mut() {
        let mut cx = ... // context
        assert_eq!(f.poll(&amp;mut cx), Poll::Ready(()));
    }
}
</code></pre></pre>
<h2 id="一个简单的执行器"><a class="header" href="#一个简单的执行器">一个简单的执行器</a></h2>
<p>为了执行我们的 future，我们需要做以下三件事：</p>
<ul>
<li>在某处跟踪 future</li>
<li>当创建 future 时，对其进行轮询</li>
<li>实现<code>Waker</code>以便我们可以知道何时再次轮询 future</li>
</ul>
<p>下面是一个基础的执行器。它使用两个向量(<code>need_poll</code>和<code>sleeping</code>)对 future 进行跟踪。调用<code>spawn</code>将一个 future 添加到<code>need_poll</code>中。</p>
<p>与其直接使用<code>WrappedFuture</code>，不如使用<code>Arc/Mutex</code>对其进行封装，以便可以在线程之间共享 future。我们声明一个别名(<code>SharedFuture</code>)，以减少噪音。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SharedFuture = Arc&lt;Mutex&lt;WrappedFuture&gt;&gt;;

struct ExecutorData {
    need_poll: Vec&lt;SharedFuture&gt;,
    sleeping: Vec&lt;SharedFuture&gt;,
}

struct Executor {
    data: Arc&lt;(Mutex&lt;ExecutorData&gt;, Condvar)&gt;,
}

impl Executor {
    pub fn new() -&gt; Self {
        let data = ExecutorData {
            need_poll: Vec::new(),
            sleeping: Vec::new(),
        };

        Self {
            data: Arc::new((Mutex::new(data), Condvar::new())),
        }
    }

    pub fn spawn&lt;F&gt;(&amp;self, f: F)
    where
        F: Future&lt;Output = ()&gt; + 'static
    {
        let (lock, _) = &amp;*self.data;

        let mut data = lock.lock().unwrap();

        data.need_poll.push(Arc::new(Mutex::new(WrappedFuture::new(f))));
    }

    pub fn wake(
        data: &amp;mut Arc&lt;(Mutex&lt;ExecutorData&gt;, Condvar)&gt;,
        wf: &amp;SharedFuture
    ) {
        let (lock, cond) = &amp;**data;

        let mut data = lock.lock().unwrap();

        let mut pos = None;
        for (i, f) in data.sleeping.iter().enumerate() {
            if Arc::ptr_eq(f, wf) {
                pos = Some(i);
                break;
            }
        }
        if pos.is_none() {
            // unknown future
            return
        }

        let pos = pos.unwrap();

        let f = data.sleeping.remove(pos);
        data.need_poll.push(f);

        cond.notify_one();
    }

    pub fn exec(&amp;self) {
        loop {
            let (lock, cond) = &amp;*self.data;

            let mut data = lock.lock().unwrap();

            if data.need_poll.is_empty() {
                if data.sleeping.is_empty() {
                    // no tasks, we're done
                    break;
                }

                data = cond.wait(data).unwrap();
            }

            let need_poll = mem::replace(
                &amp;mut data.need_poll,
                Vec::new()
            );

            mem::drop(data);

            let mut need_sleep = Vec::new();

            for f in need_poll {
                let w = MyWaker {
                    data: Arc::clone(&amp;self.data),
                    f: Arc::new(Mutex::new(Some(Arc::clone(&amp;f)))),
                }.into_task_waker();

                let mut cx = Context::from_waker(&amp;w);

                let result = {
                    f.lock().unwrap().poll(&amp;mut cx)
                };
                match result {
                    Poll::Ready(_) =&gt; {},
                    Poll::Pending =&gt; {
                        need_sleep.push(f);
                    },
                }
            }

            let mut data = lock.lock().unwrap();

            data.sleeping.append(&amp;mut need_sleep);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>exec</code>函数循环并轮询 future。首先，它检查是否有 future 需要被轮询。如果没有，它将会等待一个休眠的 future 被唤醒。一旦有要轮询的 future，便对其进行轮询。如果轮询返回了<code>Ready</code>，表示 future 已经完成，我们可以将其释放。如果轮询返回了<code>Pending</code>，我们将 future 移动到<code>sleeping</code>向量中。如果没有剩余的 future，则循环退出。</p>
<p>为了唤醒一个执行器，需要调用<code>Executor::wake</code>。这是一个关联函数，旨在由<code>MyWaker</code>从另一个线程中调用。</p>
<p><code>MyWaker</code>代码如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct MyWaker {
    data: Arc&lt;(Mutex&lt;ExecutorData&gt;, Condvar)&gt;,
    f: Arc&lt;Mutex&lt;Option&lt;SharedFuture&gt;&gt;&gt;,
}

impl MyWaker {
    ...

    fn wake(mut self) {
        self.wake_by_ref();
    }

    fn wake_by_ref(&amp;mut self) {
        let f: &amp;mut Option&lt;SharedFuture&gt; = &amp;mut self.f.lock().unwrap();
        if f.is_some() {
            let f: SharedFuture = f.take().unwrap();
            Executor::wake(&amp;mut self.data, &amp;f);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>唤醒器的实现旨在一次性使用，但是必须是可克隆的。这就是为什么内部<code>SharedFuture</code>由<code>Option</code>以及<code>Arc/Mutex</code>封装的原因。特定 future 的唤醒器集合可以安全共享单个<code>Option&lt;SharedFuture&gt;</code>的访问权限。在集合中的任何一个唤醒器上调用<code>wake()</code>时，都会唤醒 future，并将选项设置为<code>None</code>。</p>
<p>为了让我们的唤醒器实现可用，我们需要将其集成到 vtable 中，以便可以由<code>Waker</code>对其进行控制：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyWaker {
    ...

    fn into_task_waker(self) -&gt; Waker {
        let w = Box::new(self);
        let rw = RawWaker::new(Box::into_raw(w) as *mut (), &amp;VTABLE);
        unsafe { Waker::from_raw(rw) }
    }

    ...
}

unsafe fn vt_clone(data: *const ()) -&gt; RawWaker {
    let w = (data as *const MyWaker).as_ref().unwrap();
    let new_w = Box::new(w.clone());

    RawWaker::new(Box::into_raw(new_w) as *mut (), &amp;VTABLE)
}

unsafe fn vt_wake(data: *const ()) {
    let w = Box::from_raw(data as *mut MyWaker);
    w.wake();
}

unsafe fn vt_wake_by_ref(data: *const ()) {
    let w = (data as *mut MyWaker).as_mut().unwrap();
    w.wake_by_ref();
}

unsafe fn vt_drop(data: *const ()) {
    Box::from_raw(data as *mut MyWaker);
}
<span class="boring">}
</span></code></pre></pre>
<p>基本上，以上 unsafe 代码将 vtable 函数连接到<code>MyWaker</code>的常规 Rust 方法，以处理克隆 (clone) 和销毁 (drop) 操作。</p>
<p>很明显，这不是最复杂的 (sophisticated) 执行器，但它足以作为示例。</p>
<h2 id="使用执行器"><a class="header" href="#使用执行器">使用执行器</a></h2>
<p>让我们来试试看！<code>sleep</code>函数是我们之前定义的<code>TimerFuture</code>的封装。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let e = Executor::new();

    e.spawn(async {
        println!(&quot;a&quot;);
        sleep(time::Duration::from_millis(200)).await;
        println!(&quot;c&quot;);
    });

    e.spawn(async {
        sleep(time::Duration::from_millis(100)).await;
        println!(&quot;b&quot;);
        sleep(time::Duration::from_millis(200)).await;
        println!(&quot;d&quot;);
    });

    e.exec();
}
</code></pre></pre>
<p>以下输出如预期的一样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a
b
c
d
<span class="boring">}
</span></code></pre></pre>
<p>完整的代码见<a href="https://github.com/jkarneges/rust-executor-example">这里</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../lang/rust/08-图解Rust所有权与生命周期.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../lang/rust/10-Rust标准库特征指南.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../lang/rust/08-图解Rust所有权与生命周期.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../lang/rust/10-Rust标准库特征指南.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../../theme/ferris.js"></script>
        
        
    </body>
</html>
