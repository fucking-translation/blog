<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 的 Pin 与 Unpin - Blog Translation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../theme/ferris.css">
        
        <link rel="stylesheet" href="../../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">6.</strong> Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">7.</strong> Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">8.</strong> 图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">10.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">11.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/13-Rust的Pin与Unpin.html" class="active"><strong aria-hidden="true">12.</strong> Rust 的 Pin 与 Unpin</a></li><li class="chapter-item expanded "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">13.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">14.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item expanded "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">15.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="转rust-的-pin-和-unpin"><a class="header" href="#转rust-的-pin-和-unpin">「转」Rust 的 Pin 和 Unpin</a></h1>
<blockquote>
<p>转载：<a href="https://folyd.com/blog/rust-pin-unpin/">Rust 的 Pin 和 Unpin</a></p>
</blockquote>
</br>
<p>2019年2月28号，Rust 1.33版发布，增加了新的pinning API，主要包括这几个：</p>
<ul>
<li><code>std::pin::Pin</code></li>
<li><code>std::marker::Unpin</code></li>
<li><code>std::marker::PhantomPinned</code></li>
<li><code>impl !Unpin for T</code></li>
</ul>
<p>刚开始接触这些概念的时候感觉特别绕，有点难理解透彻。网上也有不少讲<code>Pin</code>和<code>Unpin</code>的文章，但总感觉讲得不是特别清楚。直接去看 <a href="https://doc.rust-lang.org/std/pin/index.html">std::pin 模块</a>的文档理解起来也挺有难度的。所以这篇文章我将尝试由浅入深的梳理一下<code>Pin</code>和<code>Unpin</code>，希望能帮助大家理解这些概念。</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p>我们先看一下<code>Pin</code>官方文档上的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its
/// value in place, preventing the value referenced by that pointer from being moved
/// unless it implements [`Unpin`].
#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[lang = &quot;pin&quot;]
#[fundamental]
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin&lt;P&gt; {
    pointer: P,
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我先来从宏观层面解读一下。<code>Pin</code>是一个这样的智能指针，他内部包裹了另外一个指针 P，并且只要 P 指针指向的内容（我们称为 T ）没有实现<code>Unpin</code>，则可以保证 T 永远不会被移动 (move)。<code>Pin</code>这个单词也很形象的表示<code>Pin</code>就像钉子一样可以把T钉住。所以<code>Pin</code>一般来说用<code>Pin&lt;P&lt;T&gt;&gt;</code>这种方式表示 (P 是 Pointer 的缩写，T 是 Type 的缩写)。这个定义初看有点绕，我们来划几个重点：</p>
<ul>
<li><code>Pin</code>自身是一个智能指针。为什么呢？因为他 impl 了<code>Deref</code>和<code>DerefMut</code>。</li>
<li><code>Pin</code>包裹的内容只能是指针，不能是其他普通类型。比如<code>Pin&lt;u32&gt;</code>就没有意义。</li>
<li><code>Pin</code>具有“钉住” T 不能移动的功能，这个功能是否生效取决于 T 是否 impl <code>Unpin</code>。简单的说，如果 T 实现了<code>Unpin</code>，<code>Pin</code>的“钉住”功能完全失效了，这时候的<code>Pin&lt;P&lt;T&gt;&gt;</code>就等价于<code>P&lt;T&gt;</code>。</li>
<li><code>Unpin</code>是一个<code>auto trait</code>，编译器默认会给所有类型实现<code>Unpin</code>。唯独有几个例外，他们实现的是<code>!Unpin</code>。这几个例外是<code>PhantomPinned</code>，编译器为<code>async/await desugar</code>之后生成的impl <code>Future</code>的结构体。</li>
<li>所以<code>Pin&lt;P&lt;T&gt;&gt;</code>默认情况下的“钉住”功能是不生效的，只针对上面说的这几个impl <code>!Unpin</code>的情况生效。</li>
</ul>
<p>看了这几条可能还有点懵，没关系，我们开始逐条剖析。首先要搞清楚的是到底什么是<code>move</code>以及为什么有些情况我们要防止<code>move</code>发生？</p>
<h2 id="到底什么是move"><a class="header" href="#到底什么是move">到底什么是move？</a></h2>
<p>根据官方定义：所有权转移的这个过程就是<code>move</code>。我们先看一个大家都非常熟悉的例子：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let mut s1 = String::from(&quot;Hello&quot;);
  let s2 = s1; // s1的所有权转移给了s2，这里发生了move
  // let s3 = s1; // s1的所有权以及转移走了，不能再move，否则会报错：error[E0382]: use of moved value: `s1`
}
</code></pre></pre>
<p>基本概念这里不多解释了，我们需要搞明白的是<code>let s2 = s1;</code>这一行到底发生了什么事情。</p>
<p><img src="./img/trpl04-04.svg" alt="trpl04-04" /></p>
<p>借用了 TRPL 书上的这张图。<code>s1</code>和<code>s2</code>两个变量都是在栈上分配内存，字符串 “Hello” 是在堆上分配内存，其中<code>ptr</code>字段就是指向该字符串的指针。<code>move</code>发生的时候编译器会在栈上开辟一块新内存<code>s2</code>，然后原封不动把<code>s1</code>栈上的内容拷贝到<code>s2</code>，随即立马让原<code>s1</code>的内存失效。</p>
<p>再看一个 move 的列子：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = String::from(&quot;xxx&quot;);
    let mut y = String::from(&quot;yyy&quot;);

    std::mem::swap(&amp;mut x, &amp;mut y);

    assert_eq!(&quot;yyy&quot;, &amp;x);
    assert_eq!(&quot;xxx&quot;, &amp;y);
}
</code></pre></pre>
<p>我们通过<code>std::mem::swap()</code>方法交换了两个可变借用<code>&amp;mut</code>的内容，这里也发生了<code>move</code>。</p>
<p>像这两种<code>move</code>在 Rust 里面很稀松平常，使用起来丝毫不会引发什么问题。那到底是什么情况需要防止<code>move</code>的发生呢？</p>
<p>还真有，那就是自引用结构体！</p>
<h2 id="自引用结构体的-move"><a class="header" href="#自引用结构体的-move">自引用结构体的 move</a></h2>
<p>自引用结构体 (Self-Referential Structs) 是一个这个样的结构体，它内部某个成员是对另外一个成员的引用。比如这样：</p>
<pre><pre class="playground"><code class="language-rust">struct Test&lt;'a&gt; {
    a: String,
    b: &amp;'a String,
}

fn main() {
    let a = String::from(&quot;Hello&quot;);
    let _test = Test { a, b: &amp;a };
//    let _test = Test { a, b: &amp;a };
//  |                        -     ^^ value borrowed here after move
//  |                        |
//  |                        value moved here
}
</code></pre></pre>
<p>但事实上我们没办法通过<code>Safe Rust</code>构造一个像 Test 这样的自引用结构体，Rust 目前对自引用结构体支持还很不完善。只能变通一下使用指针：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String, // 改成指针
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.a;
        self.b = self_ref;
    }

    fn a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(&amp;self) -&gt; &amp;String {
        unsafe {&amp;*(self.b)}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们来试一下这个自引用结构体的 move：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    // 使用swap()函数交换两者，这里发生了move
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    test1.a = &quot;I've totally changed now!&quot;.to_string();
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());
}
</code></pre></pre>
<p>这是打印结果：</p>
<pre><code class="language-console">a: test1, b: test1
a: test1, b: I've totally changed now!
</code></pre>
<p>有没有发现，出问题了！问题出在哪？原因是 Test 结构体中的字段 b 是一个指向字段 a 的指针，它在栈上存的是字段 a 的地址。通过<code>swap()</code>函数交换两个 Test 结构体之后，字段 a, b 分别移动到对方的内存区域上，但是 a 和 b 本身的内容没有变。也就是指针 b 依然指向的是原来的地址，但是这个地址现在已经属于另外一个结构体了！这不仅不是自引用结构体了，更可怕的是这个指针可能导致更危险的问题，这是 Rust 决不允许出现的！👇下面这张图可以帮助理解：</p>
<p><img src="./img/swap_problem.jpeg" alt="swap_problem" /></p>
<p>更关键的是 Rust 的<code>Generator</code>和<code>async/await</code>这一套都是基于自引用结构体实现的。如果不能从根源上解决这个问题，Rust 号称的<code>Memory Safe</code>的根基就完全动摇了。</p>
<blockquote>
<p>更多关于async/await的原理，强烈推荐阅读这两本书：</p>
<ul>
<li>https://rust-lang.github.io/async-book</li>
<li>https://cfsamson.github.io/books-futures-explained</li>
</ul>
</blockquote>
<p>所以我们来找一下导致这个问题的根源，然后想办法从根源上解决它！</p>
<h2 id="根源是什么"><a class="header" href="#根源是什么">根源是什么？</a></h2>
<p>我们发现上面的例子最关键的一行代码是<code>std::mem::swap(&amp;mut test1, &amp;mut test2)</code>，就是它导致了我们自引用结构体失效引发了内存安全问题。所以我们是不是只要避免这个<code>swap()</code>函数应用到我们自引用结构体上就行？可是怎么去避免呢？我们来看一下<code>swap()</code>方法的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T) {
    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the
    // constraints on `ptr::swap_nonoverlapping_one`
    unsafe {
        ptr::swap_nonoverlapping_one(x, y);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它的参数要求是可变借用<code>&amp;mut</code>，所以只要我们想办法让<code>Safe Rust</code>下不暴露可变借用即可！</p>
<p>还是以 Test 为例，它自身没办法限制自己不能可变借用，因为我们直接用<code>&amp;mut Test{...}</code>就可以轻松拿到。那从标准库中去找找，<code>Box&lt;T&gt;</code>呢？先不考虑它性能问题，我们把结构体 T 包裹在<code>Box</code>中，看<code>Box</code>能不能保证不暴露<code>&amp;mut T</code>出去。看一下 API 文档，很遗憾不能。<code>Box::leak()</code>返回值就是&amp;mut T，更甚者<code>Box</code> impl 了<code>DerefMut</code>，就算不用<code>leak()</code>我们也可以通过<code>* &amp;mut Box&lt;T&gt;</code>解引用轻松拿到<code>&amp;mut T</code>！</p>
<p>不用找了，在<code>Pin</code>之前的标准库中确实没有这样的 API 能够防止在<code>Safe Rust</code>下不暴露<code>&amp;mut T</code>。</p>
<p>所以，接下来是该<code>Pin</code>登场的时候了！</p>
<h2 id="pin-闪亮登场"><a class="header" href="#pin-闪亮登场">Pin 闪亮登场</a></h2>
<p>我们找到了问题的根源在哪，<code>Pin</code>就是从根源上解决这个问题的。现在我们很清晰了，似乎是不是可以用一句话概括：<code>Pin</code>就是一个不会让你在<code>Safe Rust</code>暴露可变借用<code>&amp;mut</code>的智能指针?</p>
<p>答案是：不全正确。这就是<code>Pin</code>概念起初让大家一脸懵逼的地方。下面让<code>Pin</code>自己来解答大家的疑惑，<code>Pin</code>说：“你们不是想让我保证被我包裹的指针<code>P&lt;T&gt;</code>永远钉住不让<code>move</code>吗？我可以答应，但我有一个原则。那就是我永远不能钉住持有通行证的朋友，这张通行证就是<code>Unpin</code>。如果没有这张通行证，请放心，我会把你钉得死死的！”</p>
<p>举个例子。比如我是<code>Pin</code>，你是<code>P&lt;T&gt;</code>，如果你 impl 了<code>Unpin</code>，我会提供两种办法让你在<code>Safe Rust</code>下拿到<code>&amp;mut T</code>：</p>
<ul>
<li>第一种，使用：<code>Pin::get_mut()</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a mut T&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub fn get_mut(self) -&gt; &amp;'a mut T where T: Unpin {
        self.pointer
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>第二种，我 impl 了<code>DerefMut</code>，你可以解引用拿到<code>&amp;mut T</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可<code>rustc</code>爸爸太宽容了，他默认给你们所有类型发了通行证（都实现了<code>Unpin</code>）！搞得我都几乎快要失业了！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[lang = &quot;unpin&quot;]
pub auto trait Unpin {}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;'a, T: ?Sized + 'a&gt; Unpin for &amp;'a T {}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;'a, T: ?Sized + 'a&gt; Unpin for &amp;'a mut T {}

#[stable(feature = &quot;pin_raw&quot;, since = &quot;1.38.0&quot;)]
impl&lt;T: ?Sized&gt; Unpin for *const T {}

#[stable(feature = &quot;pin_raw&quot;, since = &quot;1.38.0&quot;)]
impl&lt;T: ?Sized&gt; Unpin for *mut T {}
<span class="boring">}
</span></code></pre></pre>
<p>唯一让我欣慰的是，他给我留了一个叫<code>PhantomPinned</code>的小伙伴。别看他名字很奇怪，他可是我很喜欢的得力助手！因为他实现的是<code>!Unpin</code>！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct PhantomPinned;

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl !Unpin for PhantomPinned {}
<span class="boring">}
</span></code></pre></pre>
<p><code>rustc</code>爸爸还说，你们如果想“改邪归正”去掉<code>Unpin</code>也可以，有两种办法：</p>
<ul>
<li>使用<code>PhantomPinned</code>。有了它，<code>rustc</code>爸爸不会让你实现<code>Unpin</code>。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
   a: String,
   b: *const String,
   _marker: PhantomPinned,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>得自己手动impl <code>!Unpin</code>。前提是你要使用<code>nightly</code>版本，并且需要引入<code>#![feature(negative_impls)]</code>：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]
<span class="boring">fn main() {
</span>#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl !Unpin for Test {}
<span class="boring">}
</span></code></pre></pre>
<p>满足以上任意两个条件之一的话，我就会保证你没办法在<code>Safe Rust</code>下拿到可变借用<code>&amp;mut T</code>（不信你去翻翻我的 API），拿不到<code>&amp;mut T</code>你就没办法作用到<code>std::mem::swap()</code>上，也就是说你被我钉住了！你以为<code>rustc</code>爸爸给我施了魔法么？你错了，我的工作原理就是这么简单！感谢 Rust 世界丰富而强大的类型系统，我的其他兄弟<code>Sync</code>，<code>Send</code>也是这样，我们都没有所谓的魔法！</p>
<p>当然我还是提供了一个<code>unsafe</code>的<code>get_unchecked_mut()</code>，不管你有没有实现<code>Unpin</code>，你都可以通过调用这个方法拿到<code>&amp;mut T</code>，但是你需要遵守<code>Pin</code>的契约（参考下面），否则出了什么问题后果自负！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a mut T&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub unsafe fn get_unchecked_mut(self) -&gt; &amp;'a mut T {
        self.pointer
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="pin的契约"><a class="header" href="#pin的契约">Pin的契约：</a></h3>
<blockquote>
<p>对于<code>Pin&lt;P&lt;T&gt;&gt;</code>，</p>
<ul>
<li>如果<code>P&lt;T&gt;</code>符合<code>Unpin</code>，那<code>P&lt;T&gt;</code>从被<code>Pin</code>包裹到被销毁，都要一直保证<code>P&lt;T&gt;</code>不被钉住</li>
<li>如果<code>P&lt;T&gt;</code>符合<code>!Unpin</code>，那<code>P&lt;T&gt;</code>从被<code>Pin</code>包裹到被销毁，都要一直保证<code>P&lt;T&gt;</code>被钉住</li>
</ul>
</blockquote>
<p>通过以上<code>Pin</code>的自述，我们再用一句话来总结：如果你实现了<code>Unpin</code>，<code>Pin</code>可以让你在<code>Safe Rust</code>下拿到<code>&amp;mut T</code>，否则会把你在<code>Safe Rust</code>下钉住(也就是拿不到<code>&amp;mut T</code>)。</p>
<p>接下来我们使用<code>Pin</code>来修复一下上面自引用结构体的问题。</p>
<h2 id="如何构造一个-pin"><a class="header" href="#如何构造一个-pin">如何构造一个 Pin</a></h2>
<p>首先我们要梳理清楚怎样把<code>P&lt;T&gt;</code>用<code>Pin</code>包裹起来，也就是怎样构造一个<code>Pin</code>。查看文档会发现主要有这几种方式：</p>
<h3 id="pinnew"><a class="header" href="#pinnew">Pin::new()</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub fn new(pointer: P) -&gt; Pin&lt;P&gt; {
        // Safety: the value pointed to is `Unpin`, and so has no requirements
        // around pinning.
        unsafe { Pin::new_unchecked(pointer) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你的 P 指向的 T 是<code>Unpin</code>的话，你可以安全的调用<code>Pin::new()</code>构造一个<code>Pin</code>。可以看到它底层实际上是调用<code>unsafe</code>的<code>Pin::new_unchecked()</code>，之所以<code>Pin::new()</code>是安全的，是因为<code>Unpin</code>的情况下<code>Pin</code>的”钉住“效果是不起作用的，跟正常的指针一样了。</p>
<h3 id="pinnew_unchecked"><a class="header" href="#pinnew_unchecked">Pin::new_unchecked()</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P: Deref&gt; Pin&lt;P&gt; {
    #[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
    #[inline(always)]
    pub unsafe fn new_unchecked(pointer: P) -&gt; Pin&lt;P&gt; {
        Pin { pointer }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个方法很简单，但它是<code>unsafe</code>的。标为<code>unsafe</code>的原因是编译器没办法保证使用者后续操作一定遵守<code>Pin</code>的契约。只要有存在违反契约的可能性，就必须用<code>unsafe</code>标记，因为这是使用者的问题，编译器没办法保证。如果使用者通过<code>Pin::new_unchecked()</code>构造一个<code>Pin&lt;P&lt;T&gt;&gt;</code>之后<code>Pin</code>的生命周期结束了，但<code>P&lt;T&gt;</code>依然存在，则后续操作依然可能被<code>move</code>，造成内存不安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::pin::Pin;

fn move_pinned_ref&lt;T&gt;(mut a: T, mut b: T) {
    unsafe {
        let p: Pin&lt;&amp;mut T&gt; = Pin::new_unchecked(&amp;mut a);
        // This should mean the pointee `a` can never move again.
    }
    mem::swap(&amp;mut a, &amp;mut b);
    // The address of `a` changed to `b`'s stack slot, so `a` got moved even
    // though we have previously pinned it! We have violated the pinning API contract.
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<p>包括<code>Box::pin()</code>，<code>Rc::pin()</code>和<code>Arc::pin()</code>等，底层都是调用上面的<code>Pin::new_unchecked()</code>，不再阐述。</p>
<h2 id="pin-的应用"><a class="header" href="#pin-的应用">Pin 的应用</a></h2>
<p><code>Pin</code>可以分为栈上还是堆上，取决于你要<code>Pin</code>的那个指针 P 是在栈上还是堆上。比如<code>Pin&lt;&amp;mut T&gt;</code>是栈上，<code>Pin&lt;Box&lt;T&gt;&gt;</code>是在堆上。</p>
<h3 id="pin-到栈上"><a class="header" href="#pin-到栈上">Pin 到栈上</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }

    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
        let self_ptr: *const String = &amp;self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut Test::new(&quot;test1&quot;)) };
    Test::init(test1.as_mut());

    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut Test::new(&quot;test2&quot;)) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
</code></pre></pre>
<p>我们尝试把<code>&amp;mut Test</code>钉在栈上，然后尝试去调用<code>get_mut()</code>作为参数传给<code>std::mem::swap()</code>，发现编译不通过。Rust 编译器从编译阶段就阻止我们去犯错了。</p>
<pre><code class="language-console">|     std::mem::swap(test1.get_mut(), test2.get_mut());
  |                          ^^^^^^^ within `Test`, the trait `Unpin` is not implemented for `PhantomPinned`
  |
</code></pre>
<h3 id="pin-到堆上"><a class="header" href="#pin-到堆上">Pin 到堆上</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &amp;boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test2 = Test::new(&quot;test2&quot;);

    println!(&quot;a: {}, b: {}&quot;,test1.as_ref().a(), test1.as_ref().b());
    // std::mem::swap(test1.get_mut(), test2.get_mut());
    // std::mem::swap(&amp;mut *test1, &amp;mut *test2);
    println!(&quot;a: {}, b: {}&quot;,test2.as_ref().a(), test2.as_ref().b());
}
</code></pre></pre>
<p>这里使用<code>Box::pin()</code>把 Test 钉在了堆上。取消注释任意一行都会编译不通过，因为 Test 是<code>!Unpin</code>的。</p>
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;futures_api&quot;, since = &quot;1.36.0&quot;)]
pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来讲一下<code>Pin</code>目前最重要的一个应用：<code>Future</code>。当初 2018 年官方异步组引入<code>Pin</code> API的初衷就是为了解决<code>Future</code>内部自引用的问题。因为<code>async/await</code>就是通过<code>Generator</code>实现的，<code>Generator</code>是通过匿名结构体实现的。如果<code>async</code>函数中存在跨<code>await</code>的引用，会导致底层<code>Generator</code>存在跨<code>yield</code>的引用，那根据<code>Generator</code>生成的匿名结构体就会是一个自引用结构体！然后这个自引用结构体会impl <code>Future</code>，异步的<code>Runtime</code>在调用<code>Future::poll()</code>函数查询状态的时候，需要一个可变借用(即<code>&amp;mut Self</code>)。如果这个<code>&amp;mut Self</code>不包裹在<code>Pin</code>里面的话，开发者自己impl <code>Future</code>就会利用<code>std::mem::swap()</code>之类的函数<code>move</code>掉<code>&amp;mut Self</code>！所以这就是<code>Future</code>的<code>poll()</code>必须要使用<code>Pin&lt;&amp;mut Self&gt;</code>的原因。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个async块中存在跨await的借用！
let mut fut = async {
    let to_borrow = String::from(&quot;Hello&quot;);
    let borrowed = &amp;to_borrow;
    SomeResource::some_task().await;
    println!(&quot;{} world!&quot;, borrowed);
};
<span class="boring">}
</span></code></pre></pre>
<p>当然还有非常重要的一点不能忘了！<code>Pin</code>只对实现<code>!Unpin</code>的类型才有钉住的效果，这个impl <code>Future</code>的匿名结构体有impl <code>!Unpin</code>吗？当然有，前面说了只有几种特例是默认<code>!Unpin</code>，这个匿名结构体就是其中之一。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
where
    T: Generator&lt;ResumeTy, Yield = ()&gt;,
{
    #[rustc_diagnostic_item = &quot;gen_future&quot;]
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    // We rely on the fact that async/await futures are immovable in order to create
    // self-referential borrows in the underlying generator.
    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection.
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };

            // Resume the generator, turning the `&amp;mut Context` into a `NonNull` raw pointer. The
            // `.await` lowering will safely cast that back to a `&amp;mut Context`.
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}
<span class="boring">}
</span></code></pre></pre>
<p>划重点<code>impl &lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}</code>，只有亲眼所见才能让大家信服。</p>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<p><code>Pin</code>除了上面这些内容外还有其他几个概念，比如<code>Pin projection</code>，<code>Structural pin</code>和<code>Non-structural pin</code>，笔者自己用的也不多，详细可以看官方文档或查阅其他资料。</p>
<p><a href="https://docs.rs/futures">futures-rs</a> 中还有不少和<code>Pin</code>有关的 API，如果深入使用<code>futures-rs</code>的话，不可避免的需要频繁的和<code>Pin</code>打交道。</p>
<p><img src="./img/futures-rs.png" alt="futures-rs" /></p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>下面是摘抄自官方 <a href="https://github.com/rust-lang/async-book">Async Book</a> 上关于<code>Pin</code>的黄金8条作为总结，这些几乎就是<code>Pin</code> API 的全部了。</p>
<blockquote>
<ul>
<li>If T: Unpin (which is the default), then Pin&lt;'a, T&gt; is entirely equivalent to &amp;'a mut T. in other words: Unpin means it's OK for this type to be moved even when pinned, so Pin will have no effect on such a type.</li>
<li>Getting a &amp;mut T to a pinned T requires unsafe if T: !Unpin.</li>
<li>Most standard library types implement Unpin. The same goes for most &quot;normal&quot; types you encounter in Rust. A Future generated by async/await is an exception to this rule.</li>
<li>You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.</li>
<li>You can either pin data to the stack or to the heap.</li>
<li>Pinning a !Unpin object to the stack requires unsafe</li>
<li>Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.</li>
<li>For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.</li>
</ul>
</blockquote>
<p>2018 年 Rust 异步组的核心成员 @withoutboats 在他个人博客分享了稳定<code>async/await</code>的整个心路历程，感觉这一路也是充满曲折。比如<code>Pin</code>刚开始还需要区分<code>Pin</code>，<code>PinMut</code>，<code>PinBox</code>等，现在精简到只需要一个<code>Pin&lt;P&gt;</code>就能搞定。还有更早的时候还计划引入一个叫<code>Move</code>的 trait 来标记该类型是否可以<code>move</code>等等。我这篇文章里面的代码基于 1.48 版，不确定<code>Pin</code>以后会不会有更新，而且<code>Pin</code>目前还存在一个<code>unsoundness</code>的问题。不管怎样，一切简单优雅的设计背后一定隐藏着复杂和艰辛，感谢 Rust 官方过去的努力，让我们能够有内存安全、无畏并发和符合人体工程的编程体验！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../lang/rust/14-使用GDB调试Rust应用.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../lang/rust/14-使用GDB调试Rust应用.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../theme/ferris.js"></script>
        

        

    </body>
</html>
