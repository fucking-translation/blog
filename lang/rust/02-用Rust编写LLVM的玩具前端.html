<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>用 Rust 编写 LLVM 的玩具前端 - Blog Translation</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../../theme/ferris.css">
                <link rel="stylesheet" href="../../theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html" class="active"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item "><a href="../../lang/rust/10-Rust标准库特征指南.html"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li><li class="chapter-item "><a href="../../lang/rust/20-rust如何实现线程安全.html"><strong aria-hidden="true">1.20.</strong> Rust 如何实现线程安全</a></li><li class="chapter-item "><a href="../../lang/rust/22-无需fork_Clippy就可以编写Rust_lints.html"><strong aria-hidden="true">1.21.</strong> 无需 fork Clippy 就可以编写 Rust lint</a></li><li class="chapter-item "><a href="../../lang/rust/23-使用Mio编写底层TCP服务器.html"><strong aria-hidden="true">1.22.</strong> 使用 Mio 编写底层 TCP 服务器</a></li><li class="chapter-item "><a href="../../lang/rust/24-UnsafeRust的取舍.html"><strong aria-hidden="true">1.23.</strong> 「转」Unsafe Rust 的取舍</a></li><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.24.</strong> 标准库</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lang/rust/std/20-std-pin.html"><strong aria-hidden="true">1.24.1.</strong> std::pin</a></li><li class="chapter-item "><a href="../../lang/rust/std/21-std-condvar.html"><strong aria-hidden="true">1.24.2.</strong> std::sync::Condvar</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li><li class="chapter-item "><a href="../../架构/ServiceMesh/02-xDS与gRPC协议.html"><strong aria-hidden="true">2.2.</strong> xDS 与 gRPC 协议</a></li></ol></li><li class="chapter-item "><a href="../../oci/summary.html"><strong aria-hidden="true">3.</strong> Open Container Initiative</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../oci/01-oci-spec-overview.html"><strong aria-hidden="true">3.1.</strong> OCI 规范概述</a></li></ol></li><li class="chapter-item "><a href="../../网络协议/summary.html"><strong aria-hidden="true">4.</strong> 网络协议</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../网络协议/kcp/详解KCP协议的原理和实现.html"><strong aria-hidden="true">4.1.</strong> 「转」详解 KCP 协议的原理和实现</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="用rust编写llvm的玩具编译器"><a class="header" href="#用rust编写llvm的玩具编译器">用Rust编写LLVM的玩具编译器</a></h1>
<h4 id="a-hrefhttpsblogulysseioposta-toy-front-end-for-llvm-written-in-rust原文a"><a class="header" href="#a-hrefhttpsblogulysseioposta-toy-front-end-for-llvm-written-in-rust原文a"><a href="https://blog.ulysse.io/post/a-toy-front-end-for-llvm-written-in-rust/">原文</a></a></h4>
</br>
<p>我目前的副业是用Rust编写一个可以将代码转换成LLVM IR的编译器。LLVM的API对于新手（noobs）来说有点令人生畏（daunting），而且没有很多有关的教程（有限的教程大多数还是基于C++的，如何使用Rust做同样的事并不总是那么明确）。我希望当我准备做一件事情时，有人可以手把手的教我，这也是我要写这篇文章的原因。</p>
<p>对于Rust，与LLVM的接口交互的最佳选择是使用<code>llvm-sys</code>。互联网上的一些热心朋友在<a href="http://rustdoc.taricorp.net/llvm-sys/llvm_sys/">这里</a>托管了一些关于<code>llvm-sys</code>的文档。当然，你还应该去查看LLVM的<a href="http://llvm.org/docs/tutorial/LangImpl01.html">官方指南</a>，因为它可以帮助你理解LLVM是如何“思考”的。这篇文章基本上是LLVM官方指南的Rust翻译。</p>
<p>你可以从这里获取最终的<a href="https://github.com/ucarion/llvm-rust-getting-started">代码</a>。</p>
<h2 id="搭建开发环境"><a class="header" href="#搭建开发环境">搭建开发环境</a></h2>
<p>对于新手，使用LLVM开发有一个可以复用的方式：</p>
<pre><code class="language-shell"># `curl` is just so we can next install Rust
sudo apt-get -y install clang curl llvm-3.8-dev
curl https://sh.rustup.rs -sSf | sh

# The `llvm-sys` crate expects something called `llvm-config` on your PATH.
sudo ln -s /usr/bin/llvm-config-3.8 /usr/bin/llvm-config
</code></pre>
<p>如果你是在Ubuntu上执行上面的语句（你可能需要执行<code>apt-get update</code>），你就可以继续了。如果不是，你需要使用下面的<code>Vagrantfile</code>文件在Vagrant Box中运行上述语句。</p>
<pre><code class="language-shell">Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;bento/ubuntu-16.04&quot;
end
</code></pre>
<p>你可以从执行<code>cargo init llvm-example --bin</code>开始，并将下面（从llvm-sys中拷贝）的代码写入<code>src/main.rs</code>中：</p>
<pre><pre class="playground"><code class="language-rust">//! Construct a function that does nothing in LLVM IR.

extern crate llvm_sys as llvm;

use std::ptr;

fn main() {
    unsafe {
        // Set up a context, module and builder in that context.
        let context = llvm::core::LLVMContextCreate();
        let module = llvm::core::LLVMModuleCreateWithName(b&quot;nop\0&quot;.as_ptr() as *const _);
        let builder = llvm::core::LLVMCreateBuilderInContext(context);

        // Get the type signature for void nop(void);
        // Then create it in our module.
        let void = llvm::core::LLVMVoidTypeInContext(context);
        let function_type = llvm::core::LLVMFunctionType(void, ptr::null_mut(), 0, 0);
        let function = llvm::core::LLVMAddFunction(module, b&quot;nop\0&quot;.as_ptr() as *const _, function_type);

        // Create a basic block in the function and set our builder to generate
        // code in it.
        let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function,b&quot;entry\0&quot;.as_ptr() as *const _);
        llvm::core::LLVMPositionBuilderAtEnd(builder, bb);

        // Emit a `ret void` into the function
        llvm::core::LLVMBuildRetVoid(builder);

        // Dump the module as IR to stdout.
        llvm::core::LLVMDumpModule(module);

        // Clean up. Values created in the context mostly get cleaned up there.
        llvm::core::LLVMDisposeBuilder(builder);
        llvm::core::LLVMDisposeModule(module);
        llvm::core::LLVMContextDispose(context);
    }
}
</code></pre></pre>
<p>并在你的<code>Cargo.toml</code>文件中：</p>
<pre><code class="language-toml">[package]
name = &quot;llvm-example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Ulysse Carion &lt;ulysse@ulysse.io&gt;&quot;]

[[bin]]
name = &quot;main&quot;

[dependencies]
llvm-sys = &quot;0.2&quot;
</code></pre>
<p>你可以获得：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cargo run
   Compiling llvm-example v0.1.0 (file:///vagrant)
     Running `target/debug/main`
; ModuleID = 'nop'

define void @nop() {
entry:
  ret void
}
</code></pre>
<p>完美！现在我们可以开始编写自己的东西了。</p>
<h2 id="一个不太平凡的程序"><a class="header" href="#一个不太平凡的程序">一个不太平凡的程序</a></h2>
<p>首先，让我们编译一个程序，该程序通过从main函数中返回一个整数来简单的设置一个返回码。</p>
<p>下面是我使用的方式（我们有时候需要使用一个解析器，所以我先添加了<code>peg</code>库）：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(plugin)]
#![plugin(peg_syntax_ext)]

extern crate llvm_sys as llvm;

use std::ffi::CString;
use std::fs::File;
use std::io::Read;
use std::ptr;

fn main() {
    let mut input = String::new();
    let mut f = File::open(&quot;in.ex&quot;).unwrap();
    f.read_to_string(&amp;mut input).unwrap();

    let parsed_input = parser::program(&amp;input).unwrap();

    unsafe {
        codegen(parsed_input);
    }
}

peg! parser(r#&quot;
    #[pub]
    program -&gt; String
        = i:int_literal &quot;\n&quot; { i }

    int_literal -&gt; String
        = [0-9]+ { match_str.to_owned() }
&quot;#);

unsafe fn codegen(input: String) {
    let context = llvm::core::LLVMContextCreate();
    let module = llvm::core::LLVMModuleCreateWithName(b&quot;example_module\0&quot;.as_ptr() as *const _);
    let builder = llvm::core::LLVMCreateBuilderInContext(context);

    // In LLVM, you get your types from functions.
    let int_type = llvm::core::LLVMInt64TypeInContext(context);
    let function_type = llvm::core::LLVMFunctionType(int_type, ptr::null_mut(), 0, 0);
    let function = llvm::core::LLVMAddFunction(module, b&quot;main\0&quot;.as_ptr() as *const _, function_type);

    let entry_name = CString::new(&quot;entry&quot;).unwrap();
    let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function, entry_name.as_ptr());
    llvm::core::LLVMPositionBuilderAtEnd(builder, bb);

    // The juicy part: construct a `LLVMValue` from a Rust value:
    let int_value: u64 = input.parse().unwrap();
    let int_value = llvm::core::LLVMConstInt(int_type, int_value, 0);

    llvm::core::LLVMBuildRet(builder, int_value);

    // Instead of dumping to stdout, let's write out the IR to `out.ll`
    let out_file = CString::new(&quot;out.ll&quot;).unwrap();
    llvm::core::LLVMPrintModuleToFile(module, out_file.as_ptr(), ptr::null_mut());

    llvm::core::LLVMDisposeBuilder(builder);
    llvm::core::LLVMDisposeModule(module);
    llvm::core::LLVMContextDispose(context);
}
</code></pre></pre>
<p>它起作用了！测试一下：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cat in.ex
42
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ lli-3.8 out.ll ; echo $?
42
</code></pre>
<p>有点酷哦！顺便提一下，下面是<code>out.ll</code>文件的内容：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  ret i64 42
}
</code></pre>
<h2 id="算术"><a class="header" href="#算术">算术</a></h2>
<p>让我们添加对数字的加减乘除操作的支持。为了实现这个，我们需要扩展我们的语法。我们引入一个枚举来代表AST（抽象语法树）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Literal(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>并扩展语法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `product` and `sum` are that way to get operator precedence
peg! parser(r#&quot;
    use super::Expr;

    #[pub]
    program -&gt; Expr
        = e:expression &quot;\n&quot; { e }

    expression -&gt; Expr
        = sum

    sum -&gt; Expr
        = a:product _ &quot;+&quot; _ b:sum { Expr::Add(Box::new(a), Box::new(b)) }
        / a:product _ &quot;-&quot; _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) }
        / product

    product -&gt; Expr
        = a:int_literal _ &quot;*&quot; _ b:product { Expr::Mul(Box::new(a), Box::new(b)) }
        / a:int_literal _ &quot;/&quot; _ b:product { Expr::Div(Box::new(a), Box::new(b)) }
        / int_literal

    int_literal -&gt; Expr
        = [0-9]+ { Expr::Literal(match_str.to_owned()) }

    _ = &quot; &quot;*
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<p>接下来，可以提交代码。你可以指定诸如“addtmp”的字符串，这些字符串将被用作IR中对应“寄存器”名称的一部分。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When you write out instructions in LLVM, you get back `LLVMValueRef`s. You
// can then use these references in other instructions.
unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        Expr::Literal(int_literal) =&gt; {
            let int_type = llvm::core::LLVMInt64TypeInContext(context);
            llvm::core::LLVMConstInt(int_type, int_literal.parse().unwrap(), 0)
        },

        Expr::Add(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;addtmp&quot;).unwrap();
            llvm::core::LLVMBuildAdd(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Sub(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;subtmp&quot;).unwrap();
            llvm::core::LLVMBuildSub(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Mul(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;multmp&quot;).unwrap();
            llvm::core::LLVMBuildMul(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Div(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;divtmp&quot;).unwrap();
            llvm::core::LLVMBuildUDiv(builder, lhs, rhs, name.as_ptr())
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，你可以执行<code>10 * 4 + 20/2 - 8</code>之类的程序！如果你问我，那可真是太酷了。</p>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>我们将采用简单的方式并假设程序不会执行任何烦人的操作，如引用未定义的变量等。我们只将变量存储在寄存器中，并将它们存在<code>HashMap&lt;String, LLVMValueRef&gt;</code>中，之所以有用是因为运行该程序只有这一种方式。</p>
<p>我们扩展语言和解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Literal(String),
    Ref(String),
    Assign(String, Box&lt;Expr&gt;),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
}

peg! parser(r#&quot;
    use super::Expr;

    #[pub]
    program -&gt; Vec&lt;Expr&gt;
        = e:(expression ** &quot;\n&quot;) &quot;\n&quot; { e }

    expression -&gt; Expr
        = i:identifier _ &quot;=&quot; _ s:sum { Expr::Assign(i, Box::new(s)) }
        / sum

    sum -&gt; Expr
        = a:product _ &quot;+&quot; _ b:sum { Expr::Add(Box::new(a), Box::new(b)) }
        / a:product _ &quot;-&quot; _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) }
        / product

    product -&gt; Expr
        = a:ref_or_literal _ &quot;*&quot; _ b:product { Expr::Mul(Box::new(a), Box::new(b)) }
        / a:ref_or_literal _ &quot;/&quot; _ b:product { Expr::Div(Box::new(a), Box::new(b)) }
        / ref_or_literal

    ref_or_literal -&gt; Expr
        = i:identifier { Expr::Ref(i) }
        / int_literal

    identifier -&gt; String
        = [a-zA-Z]+ { match_str.to_owned() }

    int_literal -&gt; Expr
        = [0-9]+ { Expr::Literal(match_str.to_owned()) }

    _ = &quot; &quot;*
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<p>然后为这两个新的表达式添加支持：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, names: &amp;mut HashMap&lt;String, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        // ...

        Expr::Ref(name) =&gt; {
            *names.get(&amp;name).unwrap()
        },

        Expr::Assign(name, expr) =&gt; {
            let new_value = codegen_expr(context, builder, names, *expr);
            names.insert(name, new_value);
            new_value
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>并迅速的在<code>codegen</code>函数中更新：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zero = llvm::core::LLVMConstInt(int_type, 0, 0);

let mut names = HashMap::new();
let mut return_value = zero; // return value on empty program
for expr in input {
    return_value = codegen_expr(context, builder, &amp;mut names, expr);
}
llvm::core::LLVMBuildRet(builder, return_value);
<span class="boring">}
</span></code></pre></pre>
<p>现在让我们来一探究竟：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vagrant@vagrant:/vagrant$ cat in.ex
a = 3
b = 76
a + b
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ cat out.ll
; ModuleID = 'example_module'

define i64 @main() {
entry:
  ret i64 79
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<p>在使用<code>if</code>关键字的时候遇到一些麻烦。让<code>if</code>起作用的最简单的方式就是将所有的变量存储在堆栈上。并让LLVM做一些优化。在LLVM中，你可以通过<code>alloca</code>指令创建一个栈变量，并使用<code>load/store</code>进行读写。</p>
<p>为了实现这个，我们通过添加新的解析规则再一次扩展了语言和语法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>expression -&gt; Expr
    = if_expression
    / i:identifier _ &quot;=&quot; _ s:expression { Expr::Assign(i, Box::new(s)) }
    / sum

if_expression -&gt; Expr
    = &quot;if&quot; _ e:expression _ &quot;{\n&quot; _ then_body:statements _ &quot;}&quot; _ &quot;else&quot; _ &quot;{\n&quot; _ else_body:statements _ &quot;}&quot; {
        Expr::If(Box::new(e), then_body, else_body)
    }
<span class="boring">}
</span></code></pre></pre>
<p>并在AST节点上添加了一个新的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Literal(String),
    Ref(String),
    Assign(String, Box&lt;Expr&gt;),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    If(Box&lt;Expr&gt;, Vec&lt;Expr&gt;, Vec&lt;Expr&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，完成关于<code>if</code>表达式的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, func: LLVMValueRef, names: &amp;mut HashMap&lt;String, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        // ...

        Expr::If(condition, then_body, else_body) =&gt; {
            let condition_value = codegen_expr(context, builder, func, names, *condition);
            let int_type = llvm::core::LLVMInt64TypeInContext(context);
            let zero = llvm::core::LLVMConstInt(int_type, 0, 0);

            // `is_nonzero` is a 1-bit integer
            let name = CString::new(&quot;is_nonzero&quot;).unwrap();
            let is_nonzero = llvm::core::LLVMBuildICmp(builder, llvm::LLVMIntPredicate::LLVMIntNE, condition_value, zero, name.as_ptr());

            // It's fine to create blocks first, and then fill them in later.
            let entry_name = CString::new(&quot;entry&quot;).unwrap();
            let then_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());
            let else_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());
            let merge_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());

            llvm::core::LLVMBuildCondBr(builder, is_nonzero, then_block, else_block);

            llvm::core::LLVMPositionBuilderAtEnd(builder, then_block);
            let mut then_return = zero;
            for expr in then_body {
                then_return = codegen_expr(context, builder, func, names, expr);
            }
            llvm::core::LLVMBuildBr(builder, merge_block);

            llvm::core::LLVMPositionBuilderAtEnd(builder, else_block);
            let mut else_return = zero;
            for expr in else_body {
                else_return = codegen_expr(context, builder, func, names, expr);
            }
            llvm::core::LLVMBuildBr(builder, merge_block);

            // Position the builder so that it's ready to work on the next
            // expression.
            llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block);
            zero
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>代码有点多，但是完成了你所期待的事情。现在，你可以像这样来运行程序：</p>
<pre><code class="language-groovy">a = 1
if a {
    a = 42
} else {
    a = 13
}
a
</code></pre>
<p>上述代码对应的IR如下所示：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  %a = alloca i64
  store i64 1, i64* %a
  %a1 = load i64, i64* %a
  %is_nonzero = icmp ne i64 %a1, 0
  br i1 %is_nonzero, label %entry2, label %entry3

entry2:                                           ; preds = %entry
  store i64 42, i64* %a
  br label %entry4

entry3:                                           ; preds = %entry
  store i64 13, i64* %a
  br label %entry4

entry4:                                           ; preds = %entry3, %entry2
  %a5 = load i64, i64* %a
  ret i64 %a5
}
</code></pre>
<p>然而，我们还没有结束。目前，我们的“if”表达式的返回结果始终为zero(见上述<code>codegen_expr</code>函数中If分支的返回值)。而我们想要的正好与其相反，如果我们执行了“then”路径，则if的求值结果应该为then_return，否则返回else_return。</p>
<p>你如何使用LLVM跟踪它执行了哪个分支？通过使用“Phi”节点。你给phi指令一个(block, value)对，该phi节点将会返回与先前执行的块相对应的值。</p>
<p>我们可以这样结束if。注意，我们必须更新then_block和else_block，因为这是我们在“then/else”分支中需要的最后一个块，并且前面的then_block是“then/else”的第一个块。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is mostly the same code as before, just note the new calls to
// `LLVMGetInsertBlock`.

llvm::core::LLVMPositionBuilderAtEnd(builder, then_block);
let mut then_return = zero;
for expr in then_body {
    then_return = codegen_expr(context, builder, func, names, expr);
}
llvm::core::LLVMBuildBr(builder, merge_block);
let then_block = llvm::core::LLVMGetInsertBlock(builder);

llvm::core::LLVMPositionBuilderAtEnd(builder, else_block);
let mut else_return = zero;
for expr in else_body {
    else_return = codegen_expr(context, builder, func, names, expr);
}
llvm::core::LLVMBuildBr(builder, merge_block);
let else_block = llvm::core::LLVMGetInsertBlock(builder);

// Insert the phi node
llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block);
let phi_name = CString::new(&quot;iftmp&quot;).unwrap();
let phi = llvm::core::LLVMBuildPhi(builder, int_type, phi_name.as_ptr());

let mut values = vec![then_return, else_return];
let mut blocks = vec![then_block, else_block];

llvm::core::LLVMAddIncoming(phi, values.as_mut_ptr(), blocks.as_mut_ptr(), 2);
phi
<span class="boring">}
</span></code></pre></pre>
<p>然后，你就得到了一个令人惊叹的编译器：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cat in.ex
a = 1
b = 0
c = if a {
    if b {
        11
    } else {
        40
    }
} else {
    if b {
        10
    } else {
        20
    }
}
c + 2
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ lli-3.8 out.ll ; echo $?
42
</code></pre>
<p>太酷了！下面是我们提供的示例输入程序的IR：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  %a = alloca i64
  %b = alloca i64
  %c = alloca i64
  store i64 1, i64* %a
  store i64 0, i64* %b
  %a1 = load i64, i64* %a
  %is_nonzero = icmp ne i64 %a1, 0
  br i1 %is_nonzero, label %entry2, label %entry3

entry2:                                           ; preds = %entry
  %b5 = load i64, i64* %b
  %is_nonzero6 = icmp ne i64 %b5, 0
  br i1 %is_nonzero6, label %entry7, label %entry8

entry3:                                           ; preds = %entry
  %b10 = load i64, i64* %b
  %is_nonzero11 = icmp ne i64 %b10, 0
  br i1 %is_nonzero11, label %entry12, label %entry13

entry4:                                           ; preds = %entry14, %entry9
  %iftmp16 = phi i64 [ %iftmp, %entry9 ], [ %iftmp15, %entry14 ]
  store i64 %iftmp16, i64* %c
  %c17 = load i64, i64* %c
  %addtmp = add i64 %c17, 2
  ret i64 %addtmp

entry7:                                           ; preds = %entry2
  br label %entry9

entry8:                                           ; preds = %entry2
  br label %entry9

entry9:                                           ; preds = %entry8, %entry7
  %iftmp = phi i64 [ 11, %entry7 ], [ 40, %entry8 ]
  br label %entry4

entry12:                                          ; preds = %entry3
  br label %entry14

entry13:                                          ; preds = %entry3
  br label %entry14

entry14:                                          ; preds = %entry13, %entry12
  %iftmp15 = phi i64 [ 10, %entry12 ], [ 20, %entry13 ]
  br label %entry4
}

</code></pre>
<p>请注意：这些块具有以下的模式：不包含第一个条目，它们三个为一组，第一个是“then”分支，然后是“else”分支，最后是“merge”块（带有可识别的phi指令）。每一次我们遇到“if”表达式时都会在main后面附加三个新块。因为要在AST中递归查询三元组，所以块的三元组是有序的。</p>
<p>这就是我想要分享的全部内容！希望在这一点上你可以有足够的实力来决定你的命运。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../lang/rust/01-用Rust学习解析器组合器.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../lang/rust/03-使用nom解析url.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../lang/rust/01-用Rust学习解析器组合器.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../lang/rust/03-使用nom解析url.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../../theme/ferris.js"></script>
        
        
    </body>
</html>
