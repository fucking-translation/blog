<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>libp2p 教程: 使用 Rust 构建 p2p 应用 - Blog Translation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">6.</strong> Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">7.</strong> Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">8.</strong> 图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">10.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html" class="active"><strong aria-hidden="true">11.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">12.</strong> Rust 的 Pin 与 Unpin</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="libp2p-教程使用-rust-构建-p2p-应用"><a class="header" href="#libp2p-教程使用-rust-构建-p2p-应用">libp2p 教程：使用 Rust 构建 p2p 应用</a></h1>
<p><a href="https://blog.logrocket.com/libp2p-tutorial-build-a-peer-to-peer-app-in-rust/">原文</a></p>
<p><img src="./img/macro_in_rust.webp" alt="p2p" /></p>
</br>
<p>在过去几年中，由于围绕区块链和加密货币 (cryptocurrencies) 的火热炒作 (hype)，去中心化应用的发展势头风光一时无两。人们对去中心化的兴趣日益浓厚的另一个因素是，人们越来越意识到在数据隐私与垄断 (monopolization) 方面，将大多数网络信息交到一小部分公司手中的弊端 (downside)。</p>
<p>不管怎样，除了 (aside from) 所有的加密与区块链技术外，最近在去中心化软件领域出现了一些非常有趣的进展。</p>
<p>值得关注的包括 <a href="https://ipfs.io/">IPFS</a>；全新的分布式编码平台 <a href="https://radicle.xyz/">Radicle</a>；去中心化社交网络 <a href="https://scuttlebutt.nz/">Scuttlebutt</a>；以及 <a href="https://fediverse.party/">Fediverse</a> 中的其他应用程序，如 <a href="https://joinmastodon.org/">Mastodon</a>。</p>
<p>在这篇教程中，我们将会向你展示如何使用 Rust 和 <a href="https://github.com/libp2p/rust-libp2p">libp2p</a> 来构建一个非常简单的 p2p 应用程序。其中 <a href="https://github.com/libp2p/rust-libp2p">libp2p</a> 是一个非常棒的库，对于不同语言，它处于不同的成熟阶段。</p>
<p>我们将使用简单的命令行界面构建一个烹饪食谱应用程序，使我们能够：</p>
<ul>
<li>创建食谱</li>
<li>发布食谱</li>
<li>列出本地食谱清单</li>
<li>列出我们在网络中发现的其他成员</li>
<li>列出指定成员发布的食谱</li>
<li>列出我们其他成员的所有食谱</li>
</ul>
<p>我们将通过 300 行左右的 Rust 代码来实现所有上述功能。让我们开始吧！</p>
<h2 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h2>
<p>为了继续以下内容，你需要的只是安装最新的 Rust 版本 (1.47+)。</p>
<p>首先，创建一个新的 Rust 工程：</p>
<pre><code class="language-console">cargo new rust-p2p-example
cd rust-p2p-example
</code></pre>
<p>然后，编辑<code>Cargo.toml</code>文件并添加你所需要的依赖：</p>
<pre><code class="language-toml">[dependencies]
libp2p = { version = &quot;0.31&quot;, features = [&quot;tcp-tokio&quot;, &quot;mdns-tokio&quot;] }
tokio = { version = &quot;0.3&quot;, features = [&quot;io-util&quot;, &quot;io-std&quot;, &quot;stream&quot;, &quot;macros&quot;, &quot;rt&quot;, &quot;rt-multi-thread&quot;, &quot;fs&quot;, &quot;time&quot;, &quot;sync&quot;] }
serde = {version = &quot;=1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
once_cell = &quot;1.5&quot;
log = &quot;0.4&quot;
pretty_env_logger = &quot;0.4&quot;
</code></pre>
<p>就像上面所说的一样，我们将会使用 <a href="https://github.com/libp2p/rust-libp2p">libp2p</a> 来开发 p2p 应用的网络部分。更值得一提的是，我们将使其与 tokio 异步运行时配合使用 (use it in concert with)。我们将使用 Serde 作为 Json 的序列化与反序列化器，以及其他用于日志打印以及初始化状态的帮助类库。</p>
<h2 id="什么是-libp2p"><a class="header" href="#什么是-libp2p">什么是 <code>libp2p</code>？</a></h2>
<p><a href="https://libp2p.io/">libp2p</a> 是一个专注于模块化构建 p2p 应用的协议簇。</p>
<p><a href="https://libp2p.io/">libp2p</a> 有多语言的实现类库，如：JavaScript，Go 以及 Rust。这些库都实现了相同的<code>libp2p</code>规范，因此，一个 Go 语言的<code>libp2p</code>客户端可以无缝的与 JavaScript 实现的另一个客户端进行交互，只要它们在选择的协议栈方面兼容即可。这些协议涵盖了从基本网络传输协议到安全层协议以及多路复用的广泛范围。</p>
<p>在本文中我们不会深入讲解<code>libp2p</code>的细节，但是如果你想要更深入的学习，<a href="https://docs.libp2p.io/concepts/">libp2p 官方文档</a>将很好地概述我们在此过程中会遇到的各种概念。</p>
<h2 id="libp2p-是如何工作的"><a class="header" href="#libp2p-是如何工作的"><code>libp2p</code> 是如何工作的</a></h2>
<p>为了查看<code>libp2p</code>的实际效果，我们将从定义一些需要的常量和类型开始构建食谱应用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const STORAGE_FILE_PATH: &amp;str = &quot;./recipes.json&quot;;

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;&gt;;

static KEYS: Lazy&lt;identity::Keypair&gt; = Lazy::new(|| identity::Keypair::generate_ed25519());
static PEER_ID: Lazy&lt;PeerId&gt; = Lazy::new(|| PeerId::from(KEYS.public()));
static TOPIC: Lazy&lt;Topic&gt; = Lazy::new(|| Topic::new(&quot;recipes&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>我们将在名为<code>recipes.json</code>的 JSON 文件中存储本地食谱，应用的可执行程序将与其放在同一目录下。我们将定义一个名为<code>Result</code>的帮助类型，它将有助于传播任意的错误。</p>
<p>然后，我们使用<code>once_cell::Lazy</code>来懒加载一些东西。首要的是，我们使用它来生成密钥对，并从公钥中派生所谓的 (so-called) <code>PeerId</code>。我们还创建了一个<code>Topic</code>，它是<code>libp2p</code>中另一个关键的概念。</p>
<p>这是什么意思呢？简而言之，在整个 p2p 网络中，<code>PeerId</code>是一个特定成员的唯一的标志符。我们从密钥对中派生它以确保它的唯一性。而且这个密钥对可以让我们与网络中其他的成员进行安全通信，确保没有人可以冒充 (impersonate) 我们。</p>
<p>另一方面，<code>Topic</code>是 Floodsub 中的概念，它实现了<code>libp2p</code>中的 <a href="https://github.com/libp2p/specs/tree/master/pubsub">pub/sub</a> 接口。<code>Topic</code>是一种我们可以订阅并发送消息的组件 - 举个例子，只监听 <code>pub/sub</code> 网络中流量的子集。</p>
<p>我们需要为食谱定义一些类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Recipes = Vec&lt;Recipe&gt;;

#[derive(Debug, Serialize, Deserialize)]
struct Recipe {
    id: usize,
    name: String,
    ingredients: String,
    instructions: String,
    public: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>以及一些我们想要发送的消息类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Deserialize)]
enum ListMode {
    ALL,
    One(String),
}

#[derive(Debug, Serialize, Deserialize)]
struct ListRequest {
    mode: ListMode,
}

#[derive(Debug, Serialize, Deserialize)]
struct ListResponse {
    mode: ListMode,
    data: Recipes,
    receiver: String,
}

enum EventType {
    Response(ListResponse),
    Input(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>这个食谱相当简单。它有一个 ID，一个名称，一些配料 (ingredient) 以及烹饪的方法。而且，我们还添加了一个<code>public</code>标记以便区分我们想要分享的食谱以及想要保留的食谱。</p>
<p>正如开头提到的，这里有两种方式可以拉到其他成员的食谱清单：拉取全部获取某一个成员的食谱清单，通过<code>ListMode</code>来表示。</p>
<p><code>ListRequest</code>和<code>ListResponse</code>仅仅是<code>ListMode</code>的封装，以及使用它们的发送时间。</p>
<p><code>EventType</code>枚举用来区分来自其他成员的响应以及我们自己的输入。稍后我们将介绍为什么这种差异很重要。</p>
<h2 id="创建一个libp2p客户端"><a class="header" href="#创建一个libp2p客户端">创建一个<code>libp2p</code>客户端</a></h2>
<p>让我们开始编写 main 函数，以便在 p2p 网络中创建一个成员。</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    pretty_env_logger::init();

    info!(&quot;Peer Id: {}&quot;, PEER_ID.clone());
    let (response_sender, mut response_rcv) = mpsc::unbounded_channel();

    let auth_keys = Keypair::&lt;X25519Spec&gt;::new()
        .into_authentic(&amp;KEYS)
        .expect(&quot;can create auth keys&quot;);
</code></pre></pre>
<p>我们初始化日志并创建了一个异步<code>channel</code>来与应用的其他部分进行通信。稍后，我们将使用此<code>channel</code>将来自<code>libp2p</code>网络栈的响应发送回我们的应用程序以进行处理。</p>
<p>另外，我们为 <a href="https://noiseprotocol.org/">Noise</a> 加密协议创建了一些授权密钥，这些密钥将用于保护网络中的流量。为了达到这个目的，我们创建了一个新的密钥对，然后使用<code>into_authentic</code>函数通过身份密钥对其进行签名。</p>
<p>下一步很重要并涉及<code>libp2p</code>的核心概念：创建所谓的<code>Transport</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let transp = TokioTcpConfig::new()
    .upgrade(upgrade::Version::V1)
    .authenticate(NoiseConfig::xx(auth_keys).into_authenticated())
    .multiplex(mplex::MplexConfig::new())
    .boxed();
<span class="boring">}
</span></code></pre></pre>
<p>transport 是一个面向连接的与其他成员进行通信的网络协议蔟。在同一个应用程序中可能也会使用多个 transport - 举个例子，TCP/IP，Websocket 或者 UDP 同时针对不同的用例进行通信。</p>
<p>在本例中，我们将使用 Tokio 的异步TCP 作为基础。一旦 TCP 连接建立，为了通信安全，我们将使用<code>Noise</code>对其进行<code>upgrade</code>操作。一个基于 web 的示例是在 HTTP 之上使用 TLS 创建安全连接。</p>
<p>我们将使用<code>NoiseConfig::xx</code>的握手模式，这是唯一一个可以与其他<code>libp2p</code>应用交互的选项。</p>
<p><code>libp2p</code>的好处是，我们可以编写一个 Rust 客户端，另一个编写 JavaScript 客户端，只要在两个语言版本的库中都实现了(相同的)协议，它们就可以轻松地进行通信。</p>
<p>最后，我们还对 transport 进行<a href="https://docs.libp2p.io/concepts/stream-multiplexing/">多路复用</a>，它可以让我们在相同的 transport 上复用多个 substream 或者连接。</p>
<p>理论性的东西有点多！但是所有这些都可以在 <a href="https://docs.libp2p.io/">libp2p 文档</a>中找到。这只是创建 p2p transport 众多方法中的其中一种。</p>
<p>下一个概念是<code>NetworkBehaviour</code>。这实际上是<code>libp2p</code>中定义网络和所有成员逻辑的部分 - 举个例子，当接收到事件应该做什么以及应该发送什么事件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut behaviour = RecipeBehaviour {
    floodsub: Floodsub::new(PEER_ID.clone()),
    mdns: TokioMdns::new().expect(&quot;can create mdns&quot;),
    response_sender,
};

behaviour.floodsub.subscribe(TOPIC.clone());
<span class="boring">}
</span></code></pre></pre>
<p>在这里，正如上面所提及的，我们将使用<code>FloodSub</code>协议处理这些事件。我们也使用 <a href="https://tools.ietf.org/html/rfc6762">mDNS</a>，这是一种在本地网络中发现其他成员的协议。我们还会在这放置 channel 中的<code>sender</code>，以便可以使用它将事件传播到应用程序的主要模块中。</p>
<p>现在，我们已经从 behavior 中订阅了在之前创建的<code>FloodSub</code>主题，这意味着我们将接收并可以发送该主题的事件。</p>
<p>我们几乎已经完成了<code>libp2p</code>的设置。我们需要了解的最后一个概念是<code>Swarm</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut swarm = SwarmBuilder::new(transp, behaviour, PEER_ID.clone())
    .executor(Box::new(|fut| {
        tokio::spawn(fut);
    }))
    .build();
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/libp2p/latest/libp2p/index.html#swarm">Swarm</a> 管理使用 transport 创建的连接，并执行我们创建的网络行为(如：触发或接收事件)，并为我们提供一种从外部获取它们的方法。</p>
<p>我们使用 transport，behavior和 PEER_ID 创建了<code>Swarm</code>。<code>执行器</code>告诉<code>Swarm</code>使用<code>Tokio</code>运行时在内部运行，但是我们也可以在这里使用其他的异步运行时。</p>
<p>剩下的唯一一件事就是启动我们的<code>Swarm</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Swarm::listen_on(
    &amp;mut swarm,
    &quot;/ip4/0.0.0.0/tcp/0&quot;
    .parse()
    .expect(&quot;can get a local socket&quot;))
    .expect(&quot;swarm can be started&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>与 TCP 服务器类似，我们仅使用本地 IP 调用<code>listen_on</code>，让操作系统为我们确定端口。这将以之前的所有设置来启动<code>Swarm</code>，但实际上我们还没有定义任何逻辑。</p>
<p>让我们从处理用户输入开始。</p>
<h2 id="在libp2p中处理用户输入"><a class="header" href="#在libp2p中处理用户输入">在<code>libp2p</code>中处理用户输入</a></h2>
<p>对于用户输入，我们仅仅依赖 STDIN。因此在调用<code>Swarm::listen_on</code>之前，我们将会添加：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stdin = tokio::io::BufReader::new(tokio::io::stdin()).lines();
<span class="boring">}
</span></code></pre></pre>
<p>它在 STDIN 之上定义了一个异步 reader，它可以逐行读取字节流。如果我们按下 enter 键，这里将会传入一个新的消息。</p>
<p>下一步我们将创建事件循环，它将会监听来自 STDIN，<code>Swarm</code>以及在上面定义的响应 channel 中的事件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let evt = {
        tokio::select! {
            line = stdin.next_line() =&gt; Some(EventType::Input(line.expect(&quot;can get line&quot;).expect(&quot;can read line from stdin&quot;))),
            event = swarm.next() =&gt; {
                info!(&quot;Unhandled Swarm Event: {:?}&quot;, event);
                None
            },
            response = response_rcv.recv() =&gt; Some(EventType::Response(response.expect(&quot;response exists&quot;))),
        }
    };
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用 Tokio 的<code>select</code>宏来等待几种异步流程，并处理第一个完成的流程。对于<code>Swarm</code>事件我们不做任何处理；这些事件都在之后将看到的<code>RecipeBehaviour</code>中进行处理，但我们仍需要调用<code>swarm.next()</code>以驱动<code>Swarm</code>转发。</p>
<p>让我们添加一些事件处理逻辑来取代上面的<code>...</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(event) = evt {
    match event {
        EventType::Response(resp) =&gt; {
            ...
        }
        EventType::Input(line) =&gt; match line.as_str() {
            &quot;ls p&quot; =&gt; handle_list_peers(&amp;mut swarm).await,
            cmd if cmd.starts_with(&quot;ls r&quot;) =&gt; handle_list_recipes(cmd, &amp;mut swarm).await,
            cmd if cmd.starts_with(&quot;create r&quot;) =&gt; handle_create_recipe(cmd).await,
            cmd if cmd.starts_with(&quot;publish r&quot;) =&gt; handle_publish_recipe(cmd).await,
            _ =&gt; error!(&quot;unknown command&quot;),
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果 evt 是一个事件，我们将会对其进行匹配并判断是否是<code>Response</code>还是<code>Input</code>事件。我们现在先看下<code>Input</code>事件。</p>
<ul>
<li><code>ls p</code> 列出所有的已知成员</li>
<li><code>ls r</code> 列出所有的本地食谱</li>
<li><code>ls r {peerId}</code> 列出指定成员发布的食谱</li>
<li><code>ls r all</code> 列出所有已知成员发布的食谱</li>
<li><code>publish r {recipeId}</code> 发布指定的食谱</li>
<li><code>create r {recipeName}|{recipeIngredients}|{recipeInstructions}</code> 通过给定的数据以及自增的 ID 创建一个新的食谱</li>
</ul>
<p>在这里，列出成员的所有食谱意味着要向所有成员发送一个关于食谱的请求并等待它们的响应，然后展示结果。在 p2p 网络中，这可能要花一点事件因为某些成员可能会在地球的另一端，我们甚至不知道它们是否会对我们进行响应。这和发送一个请求到 HTTP 服务器不一样，举个例子：</p>
<p>先看下列出成员清单的逻辑：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_list_peers(swarm: &amp;mut Swarm&lt;RecipeBehaviour&gt;) {
    info!(&quot;Discovered Peers:&quot;);
    let nodes = swarm.mdns.discovered_nodes();
    let mut unique_peers = HashSet::new();
    for peer in nodes {
        unique_peers.insert(peer);
    }
    unique_peers.iter().for_each(|p| info!(&quot;{}&quot;, p));
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们可以使用<code>mDNS</code>来发现所有的节点，遍历并展示它们。</p>
<p>接下来，让我们创建并发布食谱，在处理 (tackle) 列表命令之前：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_create_recipe(cmd: &amp;str) {
    if let Some(rest) = cmd.strip_prefix(&quot;create r&quot;) {
        let elements: Vec&lt;&amp;str&gt; = rest.split(&quot;|&quot;).collect();
        if elements.len() &lt; 3 {
            info!(&quot;too few arguments - Format: name|ingredients|instructions&quot;);
        } else {
            let name = elements.get(0).expect(&quot;name is there&quot;);
            let ingredients = elements.get(1).expect(&quot;ingredients is there&quot;);
            let instructions = elements.get(2).expect(&quot;instructions is there&quot;);
            if let Err(e) = create_new_recipe(name, ingredients, instructions).await {
                error!(&quot;error creating recipe: {}&quot;, e);
            };
        }
    }
}

async fn handle_publish_recipe(cmd: &amp;str) {
    if let Some(rest) = cmd.strip_prefix(&quot;publish r&quot;) {
        match rest.trim().parse::&lt;usize&gt;() {
            Ok(id) =&gt; {
                if let Err(e) = publish_recipe(id).await {
                    info!(&quot;error publishing recipe with id {}, {}&quot;, id, e)
                } else {
                    info!(&quot;Published Recipe with id: {}&quot;, id);
                }
            }
            Err(e) =&gt; error!(&quot;invalid id: {}, {}&quot;, rest.trim(), e),
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这两种情况下，我们都需要解析字符串以获取被<code>|</code>分隔的数据，如果是<code>public</code>，则需要解析给定的食谱 id，如果给定的输入不合法，则打印一下错误日志。</p>
<p>对于<code>create</code>，我们通过给定的数据调用<code>create_new_recipe</code>函数。让我们查看一下与食谱的本地 JSON 存储交互所需的所有辅助函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_new_recipe(name: &amp;str, ingredients: &amp;str, instructions: &amp;str) -&gt; Result&lt;()&gt; {
    let mut local_recipes = read_local_recipes().await?;
    let new_id = match local_recipes.iter().max_by_key(|r| r.id) {
        Some(v) =&gt; v.id + 1,
        None =&gt; 0,
    };
    local_recipes.push(Recipe {
        id: new_id,
        name: name.to_owned(),
        ingredients: ingredients.to_owned(),
        instructions: instructions.to_owned(),
        public: false,
    });
    write_local_recipes(&amp;local_recipes).await?;

    info!(&quot;Created recipe:&quot;);
    info!(&quot;Name: {}&quot;, name);
    info!(&quot;Ingredients: {}&quot;, ingredients);
    info!(&quot;Instructions:: {}&quot;, instructions);

    Ok(())
}

async fn publish_recipe(id: usize) -&gt; Result&lt;()&gt; {
    let mut local_recipes = read_local_recipes().await?;
    local_recipes
        .iter_mut()
        .filter(|r| r.id == id)
        .for_each(|r| r.public = true);
    write_local_recipes(&amp;local_recipes).await?;
    Ok(())
}

async fn read_local_recipes() -&gt; Result&lt;Recipes&gt; {
    let content = fs::read(STORAGE_FILE_PATH).await?;
    let result = serde_json::from_slice(&amp;content)?;
    Ok(result)
}

async fn write_local_recipes(recipes: &amp;Recipes) -&gt; Result&lt;()&gt; {
    let json = serde_json::to_string(&amp;recipes)?;
    fs::write(STORAGE_FILE_PATH, &amp;json).await?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>最基本的构造代码块是<code>read_local_recipes</code>以及<code>write_local_recipes</code>，它们仅从存储中读取并反序列化食谱，以及序列化食谱并将其写入本地存储。</p>
<p><code>publish_recipe</code>函数从文件中获取所有的食谱，通过给定的 ID 来查询食谱，并将它的<code>public</code>标记设置为 true。</p>
<p>当创建一个食谱时，我们也会从文件中读取所有的食谱，并在最后添加新的食谱，然后将全部数据写回并覆盖原文件。这不是很高效，但是它足够简单且可行。</p>
<h2 id="使用libp2p发送消息"><a class="header" href="#使用libp2p发送消息">使用<code>libp2p</code>发送消息</a></h2>
<p>接下来让我们看下<code>list</code>命令，并探索如何将消息发送给其他成员。</p>
<p>在<code>list</code>命令中，这里可能有三种情况：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_list_recipes(cmd: &amp;str, swarm: &amp;mut Swarm&lt;RecipeBehaviour&gt;) {
    let rest = cmd.strip_prefix(&quot;ls r &quot;);
    match rest {
        Some(&quot;all&quot;) =&gt; {
            let req = ListRequest {
                mode: ListMode::ALL,
            };
            let json = serde_json::to_string(&amp;req).expect(&quot;can jsonify request&quot;);
            swarm.floodsub.publish(TOPIC.clone(), json.as_bytes());
        }
        Some(recipes_peer_id) =&gt; {
            let req = ListRequest {
                mode: ListMode::One(recipes_peer_id.to_owned()),
            };
            let json = serde_json::to_string(&amp;req).expect(&quot;can jsonify request&quot;);
            swarm.floodsub.publish(TOPIC.clone(), json.as_bytes());
        }
        None =&gt; {
            match read_local_recipes().await {
                Ok(v) =&gt; {
                    info!(&quot;Local Recipes ({})&quot;, v.len());
                    v.iter().for_each(|r| info!(&quot;{:?}&quot;, r));
                }
                Err(e) =&gt; error!(&quot;error fetching local recipes: {}&quot;, e),
            };
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>我们解析输入的命令，剥离 (strip) <code>ls r</code>部分，并检查是否还有剩余的部分命令。如果没有，我们仅读取本地的食谱并使用在之前定义的辅助函数将它们打印出来。</p>
<p>如果我们遇到了<code>all</code>关键字，我们将创建一个带有<code>ListMode::ALL</code>集合的<code>ListRequest</code>，将其序列化成 JSON，并在<code>Swarm</code>中使用<code>FloodSub</code>实例将其发布到之前提到的<code>主题</code>中。</p>
<p>如果我们在命令中遇到成员 ID，我们将仅发送带有该成员 ID 的<code>ListMode::One</code>。我们可以检查它是否是一个合法的成员 ID，或者是否是一个我们已经发现的成员 ID，但是为了保持简单：如果其上没有任何监听，则不会做任何处理。</p>
<p>这就是我们要向网络中发送消息所需要的一切。现在的问题是，这些消息会发生什么？它们在哪里被处理？</p>
<p>在本例中的 p2p 应用中，请记住我们既是事件的<code>Sender</code>也是事件的<code>Receiver</code>，因此在我们的实现中，需要处理输入以及响应事件。</p>
<h2 id="使用libp2p对消息进行响应"><a class="header" href="#使用libp2p对消息进行响应">使用<code>libp2p</code>对消息进行响应</a></h2>
<p>我们的<code>RecipeBehaviour</code>终于在这里出现了。先对其进行定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NetworkBehaviour)]
struct RecipeBehaviour {
    floodsub: Floodsub,
    mdns: TokioMdns,
    #[behaviour(ignore)]
    response_sender: mpsc::UnboundedSender&lt;ListResponse&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>behavior 本身仅仅是一个结构体，但是我们使用了<code>libp2p</code>中的<code>NetworkBehaviour</code>派生宏，因此我们不需要手动实现特征的所有函数。</p>
<p>这个派生宏为结构体中所有未声明<code>behaviour(ignore)</code>的成员实现了 <a href="https://docs.rs/libp2p/latest/libp2p/swarm/trait.NetworkBehaviour.html">NetworkBehaviour</a> 特征。在这里我们忽略了 channel，因为它与我们的 behavior 没有直接的关系。</p>
<p>接下来就是为<code>FloodsubEvent</code>和<code>MdnsEvent</code>实现<code>jnject_event</code>函数。</p>
<p>先从<code>mDNS</code>开始：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NetworkBehaviourEventProcess&lt;MdnsEvent&gt; for RecipeBehaviour {
    fn inject_event(&amp;mut self, event: MdnsEvent) {
        match event {
            MdnsEvent::Discovered(discovered_list) =&gt; {
                for (peer, _addr) in discovered_list {
                    self.floodsub.add_node_to_partial_view(peer);
                }
            }
            MdnsEvent::Expired(expired_list) =&gt; {
                for (peer, _addr) in expired_list {
                    if !self.mdns.has_node(&amp;peer) {
                        self.floodsub.remove_node_from_partial_view(&amp;peer);
                    }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当这个处理器接收到一个事件时，将会调用<code>inject_event</code>函数。对于<code>mDNS</code>来说，这里只有两种事件<code>Discovered</code>和<code>Expired</code>，它们将在当我们在网络中发现一个新的成员或者一个成员离开时被触发。在这两种情况下，我们都可以在<code>FloodSub</code>的部分视图中将其添加或移除，该视图是要将消息传播到的节点列表。</p>
<p>对于 pub/sub 事件来说，<code>inject_event</code>有点复杂。我们需要对传入的<code>ListRequest</code>和<code>ListResponse</code>有效负载做出反应。如果我们发送了<code>ListRequest</code>，成员将会接收到一个请求，该请求会拉取它本地发布的食谱，并将其返回。</p>
<p>将它们返回给请求成员的唯一方式就是在网络中发布它们的食谱。由于 pub/sub 是我们唯一的机制，因此我们需要对传入的请求以及响应做出反应。</p>
<p>让我们来看它是如何工作的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NetworkBehaviourEventProcess&lt;FloodsubEvent&gt; for RecipeBehaviour {
    fn inject_event(&amp;mut self, event: FloodsubEvent) {
        match event {
            FloodsubEvent::Message(msg) =&gt; {
                if let Ok(resp) = serde_json::from_slice::&lt;ListResponse&gt;(&amp;msg.data) {
                    if resp.receiver == PEER_ID.to_string() {
                        info!(&quot;Response from {}:&quot;, msg.source);
                        resp.data.iter().for_each(|r| info!(&quot;{:?}&quot;, r));
                    }
                } else if let Ok(req) = serde_json::from_slice::&lt;ListRequest&gt;(&amp;msg.data) {
                    match req.mode {
                        ListMode::ALL =&gt; {
                            info!(&quot;Received ALL req: {:?} from {:?}&quot;, req, msg.source);
                            respond_with_public_recipes(
                                self.response_sender.clone(),
                                msg.source.to_string(),
                            );
                        }
                        ListMode::One(ref peer_id) =&gt; {
                            if peer_id == &amp;PEER_ID.to_string() {
                                info!(&quot;Received req: {:?} from {:?}&quot;, req, msg.source);
                                respond_with_public_recipes(
                                    self.response_sender.clone(),
                                    msg.source.to_string(),
                                );
                            }
                        }
                    }
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们匹配了传入的消息，并试图将其序列化成一个请求或响应。当我们接收到一个响应时，我们仅将带有调用者成员 ID 的响应打印出来，成员 ID 可以通过<code>msg.source</code>获取。当我们接收到一个请求时，我们需要区分<code>ALL</code>和<code>One</code>这两种情况。</p>
<p>对于<code>One</code>，我们检查给定的成员 ID 是否和我们一样 - 该请求其实是针对我们的。如果是，我们将返回发布的食谱，我们同样对<code>ALL</code>这样进行响应。</p>
<p>在这两种情况下，我们都将调用<code>respond_with_public_recipes</code>辅助函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn respond_with_public_recipes(sender: mpsc::UnboundedSender&lt;ListResponse&gt;, receiver: String) {
    tokio::spawn(async move {
        match read_local_recipes().await {
            Ok(recipes) =&gt; {
                let resp = ListResponse {
                    mode: ListMode::ALL,
                    receiver,
                    data: recipes.into_iter().filter(|r| r.public).collect(),
                };
                if let Err(e) = sender.send(resp) {
                    error!(&quot;error sending response via channel, {}&quot;, e);
                }
            }
            Err(e) =&gt; error!(&quot;error fetching local recipes to answer ALL request, {}&quot;, e),
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个辅助函数中，我们使用 Tokio 生成器异步执行 Future，该 Future 将读取所有的本地食谱，并以此创建一个<code>ListResponse</code>，然后通过<code>channel_sender</code>将数据发送给我们的事件循环，在事件循环中，我们将会这样处理：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>EventType::Response(resp) =&gt; {
    let json = serde_json::to_string(&amp;resp).expect(&quot;can jsonify response&quot;);
    swarm.floodsub.publish(TOPIC.clone(), json.as_bytes());
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们注意到“内部”通过<code>Response</code>事件发送，我们将其序列化成 JSON 格式并将其发送到网络中。</p>
<h2 id="使用libp2p进行测试"><a class="header" href="#使用libp2p进行测试">使用<code>libp2p</code>进行测试</a></h2>
<p>上面那些是实现过程，现在让我们对其进行测试。</p>
<p>为了检查我们的实现是否工作，让我们在多个命令行中使用以下命令启动应用程序：</p>
<pre><code class="language-console">RUST_LOG=info cargo run
</code></pre>
<p>请注意，应用程序需要一个同级目录下的<code>recipes.json</code>文件。</p>
<p>当应用启动时，我们获取以下日志，并打印出成员 ID：</p>
<pre><code class="language-console">INFO  rust_peer_to_peer_example &gt; Peer Id: 12D3KooWDc1FDabQzpntvZRWeDZUL351gJRy3F4E8VN5Gx2pBCU2
</code></pre>
<p>现在，我们需要输入 enter 来启动事件循环。</p>
<p>输入<code>ls p</code>之后，我们获取到了发现的成员列表：</p>
<pre><code class="language-console">ls p
 INFO  rust_peer_to_peer_example &gt; Discovered Peers:
 INFO  rust_peer_to_peer_example &gt; 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG
 INFO  rust_peer_to_peer_example &gt; 12D3KooWLGN85pv5XTDALGX5M6tRgQtUGMWXWasWQD6oJjMcEENA
</code></pre>
<p>使用 <code>ls r</code>，我们将获取到本地食谱：</p>
<pre><code class="language-console">ls r
 INFO  rust_peer_to_peer_example &gt; Local Recipes (3)
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 0, name: &quot; Coffee&quot;, ingredients: &quot;Coffee&quot;, instructions: &quot;Make Coffee&quot;, public: true }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 1, name: &quot; Tea&quot;, ingredients: &quot;Tea, Water&quot;, instructions: &quot;Boil Water, add tea&quot;, public: false }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 2, name: &quot; Carrot Cake&quot;, ingredients: &quot;Carrots, Cake&quot;, instructions: &quot;Make Carrot Cake&quot;, public: true }
</code></pre>
<p>调用<code>ls r all</code>将向其他所有成员发送一个请求，并返回它们的食谱：</p>
<pre><code class="language-console">ls r all
 INFO  rust_peer_to_peer_example &gt; Response from 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG:
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 0, name: &quot; Coffee&quot;, ingredients: &quot;Coffee&quot;, instructions: &quot;Make Coffee&quot;, public: true }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 2, name: &quot; Carrot Cake&quot;, ingredients: &quot;Carrots, Cake&quot;, instructions: &quot;Make Carrot Cake&quot;, public: true }
</code></pre>
<p>如果我们使用带有成员 ID 的<code>ls r</code>命令，将会发生同样的事情：</p>
<pre><code class="language-console">ls r 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG
 INFO  rust_peer_to_peer_example &gt; Response from 12D3KooWCK6X7mFk9HeWw69WF1ueWa3XmphZ2Mu7ZHvEECj5rrhG:
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 0, name: &quot; Coffee&quot;, ingredients: &quot;Coffee&quot;, instructions: &quot;Make Coffee&quot;, public: true }
 INFO  rust_peer_to_peer_example &gt; Recipe { id: 2, name: &quot; Carrot Cake&quot;, ingredients: &quot;Carrots, Cake&quot;, instructions: &quot;Make Carrot Cake&quot;, public: true }
</code></pre>
<p>它确实有用！你也可以在同样的网络中使用更多的客户端进行尝试。</p>
<p>你可以在 <a href="https://github.com/zupzup/rust-peer-to-peer-example">Github</a> 中获取本教程的完整代码示例。</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>在本文中我们介绍了如何使用 Rust 以及<code>libp2p</code>构建一个简单的，去中心化的应用程序。</p>
<p>如果你来自 web 后端，那么你对许多的网络概念可能都很熟悉，但是构建 p2p 应用程序仍然需要一种根本不同的设计和构建方法。</p>
<p><code>libp2p</code>类库已经十分成熟，并且由于 Rust 在加密领域十分流行，因此出现了一个新兴的 (emerge)，丰富的生态系统，用于构建功能强大的去中心化应用程序。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../lang/rust/11-Rust中的宏:带有示例的教程.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../lang/rust/13-Rust的Pin与Unpin.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../lang/rust/11-Rust中的宏:带有示例的教程.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../lang/rust/13-Rust的Pin与Unpin.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
