<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>「转」Rust 标准库特征指南 - Blog Translation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../theme/ferris.css">
        
        <link rel="stylesheet" href="../../theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../lang/rust/summary.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../lang/rust/01-用Rust学习解析器组合器.html"><strong aria-hidden="true">1.1.</strong> 用 Rust 学习解析器组合器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/02-用Rust编写LLVM的玩具前端.html"><strong aria-hidden="true">1.2.</strong> 用 Rust 编写 LLVM 的玩具前端</a></li><li class="chapter-item expanded "><a href="../../lang/rust/03-使用nom解析url.html"><strong aria-hidden="true">1.3.</strong> 使用 nom 解析 url</a></li><li class="chapter-item expanded "><a href="../../lang/rust/04-Rust中异步编程实用介绍.html"><strong aria-hidden="true">1.4.</strong> Rust 中异步编程实用介绍</a></li><li class="chapter-item expanded "><a href="../../lang/rust/05-tokio内幕-自底向上理解Rust的异步IO框架.html"><strong aria-hidden="true">1.5.</strong> tokio 内幕-自底向上理解 Rust 的异步 IO 框架</a></li><li class="chapter-item expanded "><a href="../../lang/rust/06-Rust中的Arenas.html"><strong aria-hidden="true">1.6.</strong> 「转」Rust 中的 Arenas</a></li><li class="chapter-item expanded "><a href="../../lang/rust/07-Rust异步IO:从mio到coroutine.html"><strong aria-hidden="true">1.7.</strong> 「转」Rust 异步 IO: 从 mio 到 coroutine</a></li><li class="chapter-item expanded "><a href="../../lang/rust/08-图解Rust所有权与生命周期.html"><strong aria-hidden="true">1.8.</strong> 「转」图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="../../lang/rust/09-Rust异步执行器.html"><strong aria-hidden="true">1.9.</strong> Rust 异步执行器</a></li><li class="chapter-item expanded "><a href="../../lang/rust/10-Rust标准库特征指南.html" class="active"><strong aria-hidden="true">1.10.</strong> 「转」Rust 标准库特征指南</a></li><li class="chapter-item expanded "><a href="../../lang/rust/11-Rust中的宏:带有示例的教程.html"><strong aria-hidden="true">1.11.</strong> Rust中的宏: 带有示例的教程</a></li><li class="chapter-item expanded "><a href="../../lang/rust/12-libp2p教程:使用Rust构建p2p应用.html"><strong aria-hidden="true">1.12.</strong> libp2p 教程: 使用 Rust 构建 p2p 应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/13-Rust的Pin与Unpin.html"><strong aria-hidden="true">1.13.</strong> 「转」Rust 的 Pin 与 Unpin</a></li><li class="chapter-item expanded "><a href="../../lang/rust/14-使用GDB调试Rust应用.html"><strong aria-hidden="true">1.14.</strong> 使用 GDB 调试 Rust 中的应用</a></li><li class="chapter-item expanded "><a href="../../lang/rust/15-解释Rust中的原子性.html"><strong aria-hidden="true">1.15.</strong> 解释 Rust 中的原子性</a></li><li class="chapter-item expanded "><a href="../../lang/rust/16-Rust和TUI:在Rust中构建命令行界面.html"><strong aria-hidden="true">1.16.</strong> Rust 和 TUI：在 Rust 中构建命令行界面</a></li><li class="chapter-item expanded "><a href="../../lang/rust/17-在Android中运行Rust.html"><strong aria-hidden="true">1.17.</strong> 在 Android 中运行 Rust</a></li><li class="chapter-item expanded "><a href="../../lang/rust/18-Rust中常见的有关生命周期的误解.html"><strong aria-hidden="true">1.18.</strong> 「转」Rust 中常见的有关生命周期的误解</a></li><li class="chapter-item expanded "><a href="../../lang/rust/19-生命周期型变示例.html"><strong aria-hidden="true">1.19.</strong> 生命周期型变示例</a></li></ol></li><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/summary.html"><strong aria-hidden="true">2.</strong> Service Mesh</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../架构/ServiceMesh/01-ServiceMesh.html"><strong aria-hidden="true">2.1.</strong> 模式：Service Mesh</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blog Translation</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/fucking-translation/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-标准库特征指南"><a class="header" href="#rust-标准库特征指南">Rust 标准库特征指南</a></h1>
<blockquote>
<p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/translations/zh-hans/tour-of-rusts-standard-library-traits.md">原文</a> / 译者：skanfd</p>
</blockquote>
<p><strong>目录</strong></p>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5">引入 Intro</a></li>
<li><a href="#%E7%89%B9%E6%80%A7%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">特性的基础知识 Trait Basics</a>
<ul>
<li><a href="#%E7%89%B9%E6%80%A7%E7%9A%84%E8%AE%B0%E5%8F%B7">特性的记号 Trait Items</a>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数 Functions</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法 Methods</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型 Associated Types</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0">泛型参数 Generic Parameters</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">泛型类型与关联类型 Generic Types vs Associated Types</a></li>
</ul>
</li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域 Scope</a></li>
<li><a href="#%E8%A1%8D%E7%94%9F%E5%AE%8F">衍生宏 Derive Macros</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现 Default Impls</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0">通用泛型实现 Generic Blanket Impls</a></li>
<li><a href="#%E5%AD%90%E7%89%B9%E6%80%A7%E4%B8%8E%E8%B6%85%E7%89%B9%E6%80%A7">子特性与超特性 Subtraits &amp; Supertraits</a></li>
<li><a href="#%E7%89%B9%E6%80%A7%E5%AF%B9%E8%B1%A1">特性对象 Trait Objects</a></li>
<li><a href="#%E4%BB%85%E7%94%A8%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84%E7%89%B9%E6%80%A7">仅用于标记的特性 Marker Traits</a></li>
<li><a href="#%E5%8F%AF%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%89%B9%E6%80%A7">可自动实现的特性 Auto Traits</a></li>
<li><a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%89%B9%E6%80%A7">不安全的特性 Unsafe Traits</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%89%B9%E6%80%A7">可自动实现的特性 Auto Traits</a>
<ul>
<li><a href="#send--sync">Send &amp; Sync</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7">常用特性 General Traits</a>
<ul>
<li><a href="#default">Default</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#any">Any</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%89%B9%E6%80%A7">文本格式化特性 Formatting Traits</a>
<ul>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%89%B9%E6%80%A7">算符重载特性 Operator Traits</a>
<ul>
<li><a href="#%E6%AF%94%E8%BE%83%E7%89%B9%E6%80%A7">比较特性 Comparison Traits</a>
<ul>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%9C%AF%E7%89%B9%E6%80%A7">算术特性 Arithmetic Traits</a>
<ul>
<li><a href="#add--addassign">Add &amp; AddAssign</a></li>
</ul>
</li>
<li><a href="#%E9%97%AD%E5%8C%85%E7%89%B9%E6%80%A7">闭包特性 Closure Traits</a>
<ul>
<li><a href="#fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7-other-traits">其它特性 Other Traits</a>
<ul>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
<li><a href="#index--indexmut">Index &amp; IndexMut</a></li>
<li><a href="#drop">Drop</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E7%89%B9%E6%80%A7">转换特性 Conversion Traits</a>
<ul>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理 Error Handling</a>
<ul>
<li><a href="#error">Error</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E7%89%B9%E6%80%A7%E6%B7%B1%E5%85%A5">转换特性深入 Conversion Traits Continued</a>
<ul>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
<li><a href="#fromstr">FromStr</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
<li><a href="#toowned">ToOwned</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E7%89%B9%E6%80%A7">迭代特性 Iteration Traits</a>
<ul>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#fromiterator">FromIterator</a></li>
</ul>
</li>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7">输入输出特性 I/O Traits</a>
<ul>
<li><a href="#read--write">Read &amp; Write</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语 Conclusion</a></li>
<li><a href="#%E8%AE%A8%E8%AE%BA">讨论 Discuss</a></li>
<li><a href="#%E9%80%9A%E5%91%8A">通告 Notifications</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%96%99">更多资料 Further Reading</a></li>
<li><a href="#%E7%BF%BB%E8%AF%91">翻译 Translation</a></li>
</ul>
<h2 id="引入-intro"><a class="header" href="#引入-intro">引入 Intro</a></h2>
<p>你是否曾对以下特性的区别感到困惑：</p>
<ul>
<li><code>Deref&lt;Target = T&gt;</code> ， <code>AsRef&lt;T&gt;</code> 和 <code>Borrow&lt;T&gt;</code>？</li>
<li><code>Clone</code> ， <code>Copy</code> 和 <code>ToOwned</code>？</li>
<li><code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>？</li>
<li><code>TryFrom&lt;&amp;str&gt;</code> 和 <code>FromStr</code>？</li>
<li><code>FnOnce</code> ， <code>FnMut</code> ， <code>Fn</code> 和 <code>fn</code>？</li>
</ul>
<p>或者有这样的疑问：</p>
<ul>
<li><em>“我应该在特性中使用关联类型还是泛型类型？”</em></li>
<li><em>&quot;什么是通用泛型实现？&quot;</em></li>
<li><em>&quot;子特性与超特性是如何工作的？&quot;</em></li>
<li><em>&quot;为什么某个特性没有实现任何方法？&quot;</em></li>
</ul>
<p>本文正是为你解答以上困惑而撰写！而且本文绝不仅仅只回答了以上问题。下面，我们将一起对 Rust 标准库中所有最流行、最常用的特性做一个走马观花般的概览！</p>
<p>你可以按顺序阅读本文，也可以直接跳读至你最感兴趣的特性。每节都会提供<strong>预备知识</strong>列表，它会帮助你获得相应的背景知识，不必担心跳读带来的理解困难。</p>
<h2 id="特性的基础知识"><a class="header" href="#特性的基础知识">特性的基础知识</a></h2>
<p>本章覆盖了特性的基础知识，相应内容在以后的章节中不再赘述。</p>
<h3 id="特性的记号"><a class="header" href="#特性的记号">特性的记号</a></h3>
<p>特性的记号指的是，在特性的声明中可使用的记号。</p>
<h4 id="self"><a class="header" href="#self">Self</a></h4>
<p><code>Self</code> 永远引用正被实现的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    // always returns i32
    // 总是返回 i32
    fn returns_num() -&gt; i32;

    // returns implementing type
    // 总是返回正被实现的类型
    fn returns_self() -&gt; Self;
}

struct SomeType;
struct OtherType;

impl Trait for SomeType {
    fn returns_num() -&gt; i32 {
        5
    }

    // Self == SomeType
    fn returns_self() -&gt; Self {
        SomeType
    }
}

impl Trait for OtherType {
    fn returns_num() -&gt; i32 {
        6
    }

    // Self == OtherType
    fn returns_self() -&gt; Self {
        OtherType
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="函数"><a class="header" href="#函数">函数</a></h4>
<p>特性的函数指的是，任何不以 <code>self</code> 关键字作为首参数的函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Default {
    // function
    // 函数
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>特性的函数同时声明在特性本身以及具体实现类型的命名空间中。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let zero: i32 = Default::default();
    let zero = i32::default();
}
</code></pre></pre>
<h4 id="方法"><a class="header" href="#方法">方法</a></h4>
<p>特性的方法指的是，任何以 <code>self</code> 关键字作为首参数的函数，其类型是 <code>Self</code> ， <code>&amp;Self</code> 或 <code>&amp;mut Self</code>。前者的类型也可以包裹在 <code>Box</code> ， <code>Rc</code> ， <code>Arc</code> 或 <code>Pin</code> 中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    // methods
    // 方法
    fn takes_self(self);
    fn takes_immut_self(&amp;self);
    fn takes_mut_self(&amp;mut self);

    // above methods desugared
    // 以上代码等价于
    fn takes_self(self: Self);
    fn takes_immut_self(self: &amp;Self);
    fn takes_mut_self(self: &amp;mut Self);
}

// example from standard library
// 来自于标准库的示例
trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>可以使用点算符在具体实现类型上调用方法：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let five = 5.to_string();
}
</code></pre></pre>
<p>并且，与函数相似地，方法也声明在特性本身以及具体实现类型的命名空间中。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let five = ToString::to_string(&amp;5);
    let five = i32::to_string(&amp;5);
}
</code></pre></pre>
<h4 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h4>
<p>特性内部可以声明关联类型。当我们希望在特性函数的签名中使用某种 <code>Self</code> 以外的类型，又不希望硬编码这种类型，而是希望后来的实现该特性的程序员来选择该类型具体是什么的时候，关联类型会很有用。</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    type AssociatedType;
    fn func(arg: Self::AssociatedType);
}

struct SomeType;
struct OtherType;

// any type implementing Trait can
// choose the type of AssociatedType
// 我们可以在实现 Trait 特性的时候
// 再决定 AssociatedType 的具体类型
// 而不必是在声明 Trait 特性的时候

impl Trait for SomeType {
    type AssociatedType = i8; // chooses i8
    fn func(arg: Self::AssociatedType) {}
}

impl Trait for OtherType {
    type AssociatedType = u8; // chooses u8
    fn func(arg: Self::AssociatedType) {}
}

fn main() {
    SomeType::func(-1_i8); // can only call func with i8 on SomeType
    OtherType::func(1_u8); // can only call func with u8 on OtherType
                           // 同一特性实现在不同类型上时，可以具有不同的函数签名
}
</code></pre></pre>
<h4 id="泛型参数"><a class="header" href="#泛型参数">泛型参数</a></h4>
<p>“泛型参数” 是泛型类型参数、泛型寿命参数以及泛型常量参数的统称。由于这些术语过于佶屈聱牙，我们通常将他们缩略为“泛型类型”，“泛型寿命”和“泛型常量”。鉴于标准库中的特性无一采用泛型常量，本文也略过不讲。</p>
<p>我们可以使用以下参数来声明特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// trait declaration generalized with lifetime &amp; type parameters
// 使用泛型寿命与泛型类型声明特性
trait Trait&lt;'a, T&gt; {
    // signature uses generic type
    // 在签名中使用泛型类型
    fn func1(arg: T);
    
    // signature uses lifetime
    // 在签名中使用泛型寿命
    fn func2(arg: &amp;'a i32);
    
    // signature uses generic type &amp; lifetime
    // 在签名中同时使用泛型类型与泛型寿命
    fn func3(arg: &amp;'a T);
}

struct SomeType;

impl&lt;'a&gt; Trait&lt;'a, i8&gt; for SomeType {
    fn func1(arg: i8) {}
    fn func2(arg: &amp;'a i32) {}
    fn func3(arg: &amp;'a i8) {}
}

impl&lt;'b&gt; Trait&lt;'b, u8&gt; for SomeType {
    fn func1(arg: u8) {}
    fn func2(arg: &amp;'b i32) {}
    fn func3(arg: &amp;'b u8) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>可以为泛型类型指定默认值，最常用的默认值是 <code>Self</code> ，此外任何其它类型都是可以的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// make T = Self by default
// T 的默认值是 Self
trait Trait&lt;T = Self&gt; {
    fn func(t: T) {}
}

// any type can be used as the default
// 任何其它类型都可用作默认值
trait Trait2&lt;T = i32&gt; {
    fn func2(t: T) {}
}

struct SomeType;

// omitting the generic type will
// cause the impl to use the default
// value, which is Self here
// 省略泛型类型时， impl 块使用默认值，在这里是 Self
impl Trait for SomeType {
    fn func(t: SomeType) {}
}

// default value here is i32
// 这里的默认值是 i32
impl Trait2 for SomeType {
    fn func2(t: i32) {}
}

// the default is overridable as we'd expect
// 默认值可以被重写，正如我们希望的那样
impl Trait&lt;String&gt; for SomeType {
    fn func(t: String) {}
}

// overridable here too
// 这里也可以重写
impl Trait2&lt;String&gt; for SomeType {
    fn func2(t: String) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>不仅可以为特性提供泛型，也可以独立地为函数或方法提供泛型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn func&lt;'a, T&gt;(t: &amp;'a T);
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="泛型类型与关联类型"><a class="header" href="#泛型类型与关联类型">泛型类型与关联类型</a></h4>
<p>通过使用泛型类型与关联类型，我们都可以将具体类型的选择问题抛给后来实现该特性的程序员来决定，这一节将解释我们如何在相似的两者之间做出选择。</p>
<p>按照惯常的经验：</p>
<ul>
<li>对于某一特性，每个类型仅应当有单一实现时，使用关联类型。</li>
<li>对于某一特性，每个类型可以有多个实现时，使用泛型类型。</li>
</ul>
<p>例如，我们声明一个 <code>Add</code> 特性，它允许将各值加总在一起。这是仅使用关联类型的初始设计：</p>
<pre><pre class="playground"><code class="language-rust">trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>例如，我们希望程序允许将 i32 类型的值与 Point 类型的值相加，其规则是该 i32 类型的值分别加到成员 <code>x</code> 与成员 <code>y</code> 。</p>
<pre><pre class="playground"><code class="language-rust">trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add for Point { // ❌
    type Rhs = i32;
    type Output = Point;
    fn add(self, rhs: i32) -&gt; Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
    
    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2); // ❌
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>编译出错：</p>
<pre><code class="language-none">error[E0119]: conflicting implementations of trait `Add` for type `Point`:
  --&gt; src/main.rs:23:1
   |
12 | impl Add for Point {
   | ------------------ first implementation here
...
23 | impl Add for Point {
   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`
</code></pre>
<p>由于 <code>Add</code> 特性未提供泛型类型，因而每个类型只能具有该特性的单一实现，这即是说一旦我们指定了 <code>Rhs</code> 和 <code>Output</code> 的类型后就不可再更改了！为了 Point 类型的值能同时接受 i32 类型和 Point 类型的值作为被加数，我们应当重构之以将 <code>Rhs</code> 从关联类型改为泛型类型，这将允许我们为 <code>Rhs</code> 指定不同的类型并为同一类型多次实现某一特性。</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;Rhs&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add&lt;Point&gt; for Point {
    type Output = Self;
    fn add(self, rhs: Point) -&gt; Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add&lt;i32&gt; for Point { // ✅
    type Output = Self;
    fn add(self, rhs: i32) -&gt; Self::Output {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
    
    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2); // ✅
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>例如，我们现在声明一个包含两个 <code>Point</code> 类型的新类型 <code>Line</code> ，要求当两个 <code>Point</code> 类型相加时返回 <code>Line</code> 而不是 <code>Point</code> 。在当前 <code>Add</code> 特性的设计中 <code>Output</code> 是关联类型，不能满足这一要求，重构之以将关联类型改为泛型类型：</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;Rhs, Output&gt; {
    fn add(self, rhs: Rhs) -&gt; Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add&lt;Point, Point&gt; for Point {
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add&lt;i32, Point&gt; for Point {
    fn add(self, rhs: i32) -&gt; Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

struct Line {
    start: Point,
    end: Point,
}

impl Add&lt;Point, Line&gt; for Point { // ✅
    fn add(self, rhs: Point) -&gt; Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3: Point = p1.add(p2);
    assert!(p3.x == 3 &amp;&amp; p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert!(p3.x == 3 &amp;&amp; p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let l: Line = p1.add(p2); // ✅
    assert!(l.start.x == 1 &amp;&amp; l.start.y == 1 &amp;&amp; l.end.x == 2 &amp;&amp; l.end.y == 2)
}
</code></pre></pre>
<p>所以说，哪一种 <code>Add</code> 特性最好？答案是具体问题具体分析！不管白猫黑猫，会捉老鼠就是好猫。</p>
<h3 id="作用域"><a class="header" href="#作用域">作用域</a></h3>
<p>特性仅当被引入当前作用域时才可以使用。绝大多数的初学者要在编写 I/O 程序时经历一番痛苦挣扎后，才能领悟到这一点，原因是 <code>Read</code> 和 <code>Write</code> 两个特性并未包含在标准库的 prelude 模块中。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = File::open(&quot;Cargo.toml&quot;)?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?; // ❌ read_to_string not found in File
                                       // ❌ 当前文件中找不到 read_to_string
    Ok(())
}
</code></pre></pre>
<p><code>read_to_string(buf: &amp;mut String)</code> 声明于 <code>std::io::Read</code> 特性，并实现于 <code>std::fs::File</code> 类型，若要调用该函数还须得 <code>std::io::Read</code> 特性处于当前作用域中：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;
use std::io::Read; // ✅

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = File::open(&quot;Cargo.toml&quot;)?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?; // ✅
    Ok(())
}
</code></pre></pre>
<p>诸如 <code>std::prelude::v1</code> ，prelude 是标准库的一类模块，其特点是该模块命名空间下的成员将被自动导入到任何其它模块的顶部，其作用等效于 <code>use std::prelude::v1::*</code> 。因此，以下 prelude 模块中的特性无需我们显式导入，它们永远存在于当前作用域：</p>
<ul>
<li><a href="#asref--asmut">AsMut</a></li>
<li><a href="#asref--asmut">AsRef</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#drop">Drop</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#fnonce-fnmut--fn">Fn</a></li>
<li><a href="#fnonce-fnmut--fn">FnMut</a></li>
<li><a href="#fnonce-fnmut--fn">FnOnce</a></li>
<li><a href="#from--into">From</a></li>
<li><a href="#from--into">Into</a></li>
<li><a href="#toowned">ToOwned</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
<li><a href="#send--sync">Send</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#send--sync">Sync</a></li>
<li><a href="#display--tostring">ToString</a></li>
<li><a href="#partialord--ord">Ord</a></li>
</ul>
<h3 id="衍生宏"><a class="header" href="#衍生宏">衍生宏</a></h3>
<p>标准库导出了一系列实用的衍生宏，我们可以利用它们方便快捷地为特定类型实现某种特性，前提是该类型的成员亦实现了相应的特性。衍生宏与它们各自所实现的特性同名：</p>
<ul>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">Ord</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
</ul>
<p>用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// macro derives Copy &amp; Clone impl for SomeType
// 利用宏的方式为特定类型衍生出 Copy 与 Clone 特性的具体实现
#[derive(Copy, Clone)]
struct SomeType;
<span class="boring">}
</span></code></pre></pre>
<p>注意：衍生宏仅是一种机械的过程，宏展开之后发生的事情并无一定之规。并没有绝对的规定要求衍生宏展开之后必须要为类型实现某种特性，又或者它们必须要求该类型的所有成员都必须实现某种特性才能为当前类型实现该特性，这仅仅是在标准库衍生宏的编纂过程中逐渐约定俗成的规则。</p>
<h3 id="默认实现"><a class="header" href="#默认实现">默认实现</a></h3>
<p>特性可为函数与方法提供默认的实现。</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(&amp;self) {
        println!(&quot;default impl&quot;);
    }
}

struct SomeType;
struct OtherType;

// use default impl for Trait::method
// 省略时使用默认实现
impl Trait for SomeType {}

impl Trait for OtherType {
    // use our own impl for Trait::method
    // 重写时覆盖默认实现
    fn method(&amp;self) {
        println!(&quot;OtherType impl&quot;);
    }
}

fn main() {
    SomeType.method(); // prints &quot;default impl&quot;
    OtherType.method(); // prints &quot;OtherType impl&quot;
}
</code></pre></pre>
<p>这对于实现特性中某些仅依赖于其它方法的方法来说极其方便。</p>
<pre><pre class="playground"><code class="language-rust">trait Greet {
    fn greet(&amp;self, name: &amp;str) -&gt; String;
    fn greet_loudly(&amp;self, name: &amp;str) -&gt; String {
        self.greet(name) + &quot;!&quot;
    }
}

struct Hello;
struct Hola;

impl Greet for Hello {
    fn greet(&amp;self, name: &amp;str) -&gt; String {
        format!(&quot;Hello {}&quot;, name)
    }
    // use default impl for greet_loudly
    // 省略时使用 greet_loudly 的默认实现
}

impl Greet for Hola {
    fn greet(&amp;self, name: &amp;str) -&gt; String {
        format!(&quot;Hola {}&quot;, name)
    }
    // override default impl
    // 重写时覆盖 greet_loudly 的默认实现
    fn greet_loudly(&amp;self, name: &amp;str) -&gt; String {
        let mut greeting = self.greet(name);
        greeting.insert_str(0, &quot;¡&quot;);
        greeting + &quot;!&quot;
    }
}

fn main() {
    println!(&quot;{}&quot;, Hello.greet(&quot;John&quot;)); // prints &quot;Hello John&quot;
    println!(&quot;{}&quot;, Hello.greet_loudly(&quot;John&quot;)); // prints &quot;Hello John!&quot;
    println!(&quot;{}&quot;, Hola.greet(&quot;John&quot;)); // prints &quot;Hola John&quot;
    println!(&quot;{}&quot;, Hola.greet_loudly(&quot;John&quot;)); // prints &quot;¡Hola John!&quot;
}
</code></pre></pre>
<p>标准库中的许多特性都为它们的方法提供默认实现。</p>
<h3 id="通用泛型实现"><a class="header" href="#通用泛型实现">通用泛型实现</a></h3>
<p>通用泛型实现是对泛型类型的实现，与之对应的是对特定类型的实现。我们将以 is_even 方法为例说明如何对数字类型实现通用泛型实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Even {
    fn is_even(self) -&gt; bool;
}

impl Even for i8 {
    fn is_even(self) -&gt; bool {
        self % 2_i8 == 0_i8
    }
}

impl Even for u8 {
    fn is_even(self) -&gt; bool {
        self % 2_u8 == 0_u8
    }
}

impl Even for i16 {
    fn is_even(self) -&gt; bool {
        self % 2_i16 == 0_i16
    }
}

// etc

#[test] // ✅
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
<span class="boring">}
</span></code></pre></pre>
<p>显而易见地，我们重复实现了近乎相同的逻辑，这非常的繁琐。进一步来讲，如果 Rust 在将来决定增加更多的数字类型（小概率事件并非绝不可能），那么我们将不得不重新回到这里对新增的数字类型编写代码。通用泛型实现恰可以解决这些问题：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -&gt; bool;
}

// generic blanket impl
// 通用泛型实现
impl&lt;T&gt; Even for T
where
    T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
    u8: TryInto&lt;T&gt;,
    &lt;u8 as TryInto&lt;T&gt;&gt;::Error: Debug,
{
    fn is_even(self) -&gt; bool {
        // these unwraps will never panic
        // 以下 unwrap 永远不会 panic
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

#[test] // ✅
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
<span class="boring">}
</span></code></pre></pre>
<p>默认实现可以重写，而通用泛型实现不可重写。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -&gt; bool;
}

impl&lt;T&gt; Even for T
where
    T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
    u8: TryInto&lt;T&gt;,
    &lt;u8 as TryInto&lt;T&gt;&gt;::Error: Debug,
{
    fn is_even(self) -&gt; bool {
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

impl Even for u8 { // ❌
    fn is_even(self) -&gt; bool {
        self % 2_u8 == 0_u8
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>编译出错：</p>
<pre><code class="language-none">error[E0119]: conflicting implementations of trait `Even` for type `u8`:
  --&gt; src/lib.rs:22:1
   |
10 | / impl&lt;T&gt; Even for T
11 | | where
12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
13 | |     u8: TryInto&lt;T&gt;,
...  |
19 | |     }
20 | | }
   | |_- first implementation here
21 | 
22 |   impl Even for u8 {
   |   ^^^^^^^^^^^^^^^^ conflicting implementation for `u8`
</code></pre>
<p>重叠的实现产生了冲突，于是 Rust 拒绝了该代码以确保特性一致性。特性一致性指的是，对任意给定类型，仅能对某一特性具有单一实现。Rust 强制实现特性一致性，而这一规则的潜在影响与变通方法超出了本文的讨论范围。</p>
<h3 id="子特性与超特性"><a class="header" href="#子特性与超特性">子特性与超特性</a></h3>
<p>子特性的“子”即为子集，超特性的“超”即为超集。若有下列特性声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Subtrait: Supertrait {}
<span class="boring">}
</span></code></pre></pre>
<p>所有实现了子特性的类型都是实现了超特性的类型的子集，也可以说，所有实现了超特性的类型都是实现了子特性的类型的超集。</p>
<p>以上代码等价于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Subtrait where Self: Supertrait {}
<span class="boring">}
</span></code></pre></pre>
<p>这是一种易于忽略但又至关重要的区别 —— 约束是 <code>Self</code> 的约束，而不是 <code>Subtrait</code> 的约束。后者没有任何意义，因为特性约束只能应用于具体类型。不能用一种特性去实现其它特性：</p>
<pre><pre class="playground"><code class="language-rust">trait Supertrait {
    fn method(&amp;self) {
        println!(&quot;in supertrait&quot;);
    }
}

trait Subtrait: Supertrait {
    // this looks like it might impl or
    // override Supertrait::method but it
    // does not
    // 这可能会令你产生超特性的方法被覆盖的错觉（实际不会）
    fn method(&amp;self) {
        println!(&quot;in subtrait&quot;)
    }
}


struct SomeType;

// adds Supertrait::method to SomeType
impl Supertrait for SomeType {}

// adds Subtrait::method to SomeType
impl Subtrait for SomeType {}

// both methods exist on SomeType simultaneously
// neither overriding or shadowing the other
// 两个同名方法同时存在于同一类型时，既不重写也不影射

fn main() {
    SomeType.method(); // ❌ ambiguous method call
                       // ❌ 不允许语义模糊的函数调用
    // must disambiguate using fully-qualified syntax
    // 必须使用完全限定的记号来明确你要使用的函数
    &lt;SomeType as Supertrait&gt;::method(&amp;st); // ✅ prints &quot;in supertrait&quot;
    &lt;SomeType as Subtrait&gt;::method(&amp;st); // ✅ prints &quot;in subtrait&quot;
}
</code></pre></pre>
<p>此外，对于特定类型如何同时实现子特性与超特性并没有规定。子、超特性之间的方法也可以相互调用。</p>
<pre><pre class="playground"><code class="language-rust">trait Supertrait {
    fn super_method(&amp;mut self);
}

trait Subtrait: Supertrait {
    fn sub_method(&amp;mut self);
}

struct CallSuperFromSub;

impl Supertrait for CallSuperFromSub {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
    }
}

impl Subtrait for CallSuperFromSub {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
        self.super_method();
    }
}

struct CallSubFromSuper;

impl Supertrait for CallSubFromSuper {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
        self.sub_method();
    }
}

impl Subtrait for CallSubFromSuper {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
    }
}

struct CallEachOther(bool);

impl Supertrait for CallEachOther {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
        if self.0 {
            self.0 = false;
            self.sub_method();
        }
    }
}

impl Subtrait for CallEachOther {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
        if self.0 {
            self.0 = false;
            self.super_method();
        }
    }
}

fn main() {
    CallSuperFromSub.super_method(); // prints &quot;in super&quot;
    CallSuperFromSub.sub_method(); // prints &quot;in sub&quot;, &quot;in super&quot;
    
    CallSubFromSuper.super_method(); // prints &quot;in super&quot;, &quot;in sub&quot;
    CallSubFromSuper.sub_method(); // prints &quot;in sub&quot;
    
    CallEachOther(true).super_method(); // prints &quot;in super&quot;, &quot;in sub&quot;
    CallEachOther(true).sub_method(); // prints &quot;in sub&quot;, &quot;in super&quot;
}
</code></pre></pre>
<p>通过以上示例，希望读者能够领会到，子特性与超特性之间的关系并未被一刀切的限制住。接下来我们将学习一种将所有这些复杂性巧妙地封装在一起的心智模型，在这之前我们先来回顾一下我们用来理解泛型类型与特性约束的关系的心智模型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T: Clone&gt;(t: T) {
    // impl
}
<span class="boring">}
</span></code></pre></pre>
<p>即便我们不知道这个函数的具体实现，我们仍旧可以有理有据地猜测 <code>t.clone()</code> 将在函数的某处被调用，因为当泛型类型被特性所约束的时候，会给人一种它依赖于该特性的强烈暗示。这就是一种理解泛型类型与特性约束的关系的心智模型，它简单且可凭直觉 —— 泛型类型依赖于它们的特性约束。</p>
<p>现在，让我们看看 <code>Copy</code> 特性的声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy: Clone {}
<span class="boring">}
</span></code></pre></pre>
<p>以上的记号和之前我们为泛型添加特性约束的记号非常相似，但是 <code>Copy</code> 却完全不依赖 <code>Clone</code> 。早前建立的心智模型现在不适用了。在我看来，理解子特性与超特性的关系的最简单和最优雅的心智模型莫过于 —— 子特性 <em>改良</em> 了超特性。</p>
<p>“改良”一词故意地预留了一些模糊的空间，它的具体含义在不同的上下文中有所不同：</p>
<ul>
<li>子特性可能比超特性的方法更加特异化、运行更快或使用更少内存等等，例如 <code>Copy: Clone</code> </li>
<li>子特性可能比超特性的方法具有额外的功能，例如 <code>Eq: PartialEq</code> ， <code>Ord: PartialOrd</code> 和 <code>ExactSizeIterator: Iterator</code> </li>
<li>子特性可能比超特性的方法更灵活和更易于调用，例如 <code>FnMut: FnOnce</code> 和 <code>Fn: FnMut</code></li>
<li>子特性可能扩展了超特性并添加了新的方法，例如 <code>DoubleEndedIterator: Iterator</code> 和 <code>ExactSizeIterator: Iterator</code> </li>
</ul>
<h3 id="特性对象"><a class="header" href="#特性对象">特性对象</a></h3>
<p>如果说泛型给了我们编译时的多态性，那么特性对象就给了我们运行时的多态性。通过特性对象，我们可以允许函数在运行时动态地返回不同的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(condition: bool, vec: Vec&lt;i32&gt;) -&gt; Box&lt;dyn Iterator&lt;Item = i32&gt;&gt; {
    let iter = vec.into_iter();
    if condition {
        // Has type:
        // Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
        // But is cast to:
        // Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
        Box::new(iter.map(|n| n * 2))
    } else {
        // Has type:
        // Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
        // But is cast to:
        // Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
        Box::new(iter.filter(|&amp;n| n &gt;= 2))
    }
}
        // 以上代码中，两种不同的指针类型转换成相同的指针类型
<span class="boring">}
</span></code></pre></pre>
<p>特性对象也允许我们在集合中存储不同类型的值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f64::consts::PI;

struct Circle {
    radius: f64,
}

struct Square {
    side: f64
}

trait Shape {
    fn area(&amp;self) -&gt; f64;
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f64 {
        PI * self.radius * self.radius
    }
}

impl Shape for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn get_total_area(shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt;) -&gt; f64 {
    shapes.into_iter().map(|s| s.area()).sum()
}

fn example() {
    let shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt; = vec![
        Box::new(Circle { radius: 1.0 }), // Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
        Box::new(Square { side: 1.0 }), // Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
    ];
    assert_eq!(PI + 1.0, get_total_area(shapes)); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<p>特性对象的结构体大小是未知的，所以必须要通过指针来引用它们。具体类型与特性对象在字面上的区别在于，特性对象必须要用 <code>dyn</code> 关键字来修饰前缀，了解了这一点我们可以轻松辨别二者。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;
trait Trait {}

// regular struct
// 这是一般的结构
&amp;Struct
Box&lt;Struct&gt;
Rc&lt;Struct&gt;
Arc&lt;Struct&gt;

// trait objects
// 这是特性对象
&amp;dyn Trait
Box&lt;dyn Trait&gt;
Rc&lt;dyn Trait&gt;
Arc&lt;dyn Trait&gt;
<span class="boring">}
</span></code></pre></pre>
<p>并非全部的特性都可以转换为特性对象，一个 “对象安全” 的特性必须满足：</p>
<ul>
<li>该特性不要求 <code>Self: Sized</code></li>
<li>该特性的所有方法都是 “对象安全” 的</li>
</ul>
<p>一个特性的方法若要是 “对象安全” 的，必须满足：</p>
<ul>
<li>该方法要求 <code>Self: Sized</code> </li>
<li>该方法仅在接收参数中使用 <code>Self</code> 类型</li>
</ul>
<p>关于具有这些限制条件的原因超出了本文的讨论范围且与下文无关，如果你对此深感兴趣不妨阅读 <a href="../../sizedness-in-rust.html">Sizedness in Rust</a> 以了解详情。</p>
<h3 id="仅用于标记的特性"><a class="header" href="#仅用于标记的特性">仅用于标记的特性</a></h3>
<p>仅用于标记的特性，即是某种声明体为空的特性。它们存在的意义在于 “标记” 所实现的类型，且该类型具有某种类型系统所无法表达的属性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impling PartialEq for a type promises
// that equality for the type has these properties:
// - symmetry: a == b implies b == a, and
// - transitivity: a == b &amp;&amp; b == c implies a == c
// But DOES NOT promise this property:
// - reflexivity: a == a
// 为特定类型实现 PartialEq 特性确保了该类型的相等算符具有以下性质：
// - 对称性： 若有 a == b ， 则必有 b == a
// - 传递性： 若有 a == b 和 b == c ， 则必有 a == c
// 但是不能确保具有以下性质：
// - 自反性： a == a
trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;
}

// Eq has no trait items! The eq method is already
// declared by PartialEq, but &quot;impling&quot; Eq
// for a type promises this additional equality property:
// - reflexivity: a == a
// Eq 特性的声明体是空的！ 而 eq 方法已经被 PartialEq 所声明，
// 但是对特定类型“实现” Eq 特性确保了额外的相等性质：
// - 自反性： a == a
trait Eq: PartialEq {}

// f64 impls PartialEq but not Eq because NaN != NaN
// i32 impls PartialEq &amp; Eq because there's no NaNs :)
// f64 实现了 PartialEq 特性但是没有实现 Eq 特性，因为 NaN != NaN
// i32 同时实现了 PartialEq 特性与 Eq 特性，因为没有 NaN 来捣乱 :)
<span class="boring">}
</span></code></pre></pre>
<h3 id="可自动实现的特性"><a class="header" href="#可自动实现的特性">可自动实现的特性</a></h3>
<p>可自动实现的特性指的是，存在这样一种特性，若给定类型的成员都实现了该特性，那么该类型就隐式地自动实现该特性。这里所说的 “成员” 依据上下文而具有不同的含义，包括而又不限于结构体的字段、枚举的变量、数组的元素和元组的内容等等。</p>
<p>所有可自动实现的特性都是仅用于标记的特性，反之则不是。正是由于可自动实现的特性必须是仅用于标记的特性，所以编译器才能够自动为其提供一个默认实现，反之编译器就无能为力了。</p>
<p>可自动实现的特性的示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// implemented for types which are safe to send between threads
// 实现 Send 特性的类型可以安全地往返于多个线程
unsafe auto trait Send {}

// implemented for types whose references are safe to send between threads
// 实现 Sync 特性的类型，其引用可以安全地往返于多个线程
unsafe auto trait Sync {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="不安全的特性"><a class="header" href="#不安全的特性">不安全的特性</a></h3>
<p>以 <code>unsafe</code> 修饰前缀的特性，意味着该特性的实现可能需要不安全的代码。<code>Send</code> 特性与 <code>Sync</code> 特性以 <code>unsafe</code> 修饰前缀意味着，如果特定类型没有自动实现该特性，那么说明该类型的成员并非都实现了该特性，这提示着我们手动实现该特性一定要谨慎小心，以确保没有发生数据竞争。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SomeType is not Send or Sync
// SomeType 没有实现 Send 和 Sync
struct SomeType {
    not_send_or_sync: *const (),
}

// but if we're confident that our impl doesn't have any data
// races we can explicitly mark it as Send and Sync using unsafe
// 倘若我们得以社会主义伟大成就的庇佑自信地写出没有数据竞争的代码
// 可以使用 unsafe 来修饰前缀，以显式地实现 Send 特性与 Sync 特性
unsafe impl Send for SomeType {}
unsafe impl Sync for SomeType {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="可自动实现的特性-1"><a class="header" href="#可自动实现的特性-1">可自动实现的特性</a></h2>
<h3 id="send--sync"><a class="header" href="#send--sync">Send &amp; Sync</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe auto trait Send {}
unsafe auto trait Sync {}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>Send</code> 特性的类型可以安全地往返于多线程。实现 <code>sync</code> 特性的类型，其引用可以安全地往返于多线程。用更加准确的术语来讲，当且仅当 <code>&amp;T</code> 实现 <code>Send</code> 特性时，<code>T</code> 才能实现 <code>Sync</code> 特性。</p>
<p>几乎所有类型都实现了 <code>Send</code> 特性和 <code>Sync</code> 特性。对于 <code>Send</code> 唯一需要注意的例外是 <code>Rc</code> ，对于 <code>Sync</code> 唯三需要注意的例外是 <code>Rc</code>，<code>Cell</code> 和 <code>RefCell</code> 。如果我们需要 <code>Send</code> 版的 <code>Rc</code> ，可以使用 <code>Arc</code> 。如果我们需要 <code>Sync</code> 版的 <code>Cell</code> 或 <code>RefCell</code> ，可以使用 <code>Mutex</code> 或 <code>RwLock</code> 。尽管我们可以使用 <code>Mutex</code> 或 <code>RwLock</code> 来包裹住原语类型，但通常使用标准库提供的原子原语类型会更好，诸如 <code>AtomicBool</code> ，<code>AtomicI32</code> 和 <code>AtomicUsize</code> 等等。</p>
<p>多亏了 Rust 严格的借用规则，几乎所有的类型都是 <code>Sync</code> 的。这对于一些人来讲可能会很惊讶，但事实胜于雄辩，甚至对于那些没有内部同步机制的类型来说也是如此。</p>
<p>对于同一数据，我们可以放心地将该数据的多个不可变引用传递给多个线程，因为只要当前存在一个该数据的不可变引用，那么 Rust 就会静态地确保该数据不会被改变：</p>
<pre><pre class="playground"><code class="language-rust">use crossbeam::thread;

fn main() {
    let mut greeting = String::from(&quot;Hello&quot;);
    let greeting_ref = &amp;greeting;
    
    thread::scope(|scoped_thread| {
        // spawn 3 threads
        // 产生三个线程
        for n in 1..=3 {
            // greeting_ref copied into every thread
            // greeting_ref 被拷贝到每个线程
            scoped_thread.spawn(move |_| {
                println!(&quot;{} {}&quot;, greeting_ref, n); // prints &quot;Hello {n}&quot;
            });
        }
        
        // line below could cause UB or data races but compiler rejects it
        // 下面这行代码可能导致数据竞争，于是编译器拒绝了它
        greeting += &quot; world&quot;; 
        // ❌ cannot mutate greeting while immutable refs exist
        // ❌ 当不可变引用存在时，不可以修改引用的数据
    });
    
    // can mutate greeting after every thread has joined
    // 当所有的线程结束之后，可以修改数据
    greeting += &quot; world&quot;; // ✅
    println!(&quot;{}&quot;, greeting); // prints &quot;Hello world&quot;
}
</code></pre></pre>
<p>同样地，我们可以将某个数据的单个可变引用传递给单个线程，在此过程中不必担心出现数据竞争，因为 Rust 静态地确保了不存在其它可变引用。以下数据即仅可通过已经存在的单个可变引用而改变：</p>
<pre><pre class="playground"><code class="language-rust">use crossbeam::thread;

fn main() {
    let mut greeting = String::from(&quot;Hello&quot;);
    let greeting_ref = &amp;mut greeting;
    
    thread::scope(|scoped_thread| {
        // greeting_ref moved into thread
        // greeting_ref 移动到当前线程
        scoped_thread.spawn(move |_| {
            *greeting_ref += &quot; world&quot;;
            println!(&quot;{}&quot;, greeting_ref); // prints &quot;Hello world&quot;
        });
        
        // line below could cause UB or data races but compiler rejects it
        // 下面这行代码可能导致数据竞争，于是编译器拒绝了它
        greeting += &quot;!!!&quot;; 
        // ❌ cannot mutate greeting while mutable refs exist
        // ❌ 可变引用存在时不可改变数据
    });
    
    // can mutate greeting after the thread has joined
    // 当所有的线程结束之后，可以修改数据
    greeting += &quot;!!!&quot;; // ✅
    println!(&quot;{}&quot;, greeting); // prints &quot;Hello world!!!&quot;
}
</code></pre></pre>
<p>这就是为什么绝大多数的类型都是 Sync 的而不需要实现任何显式的同步机制。对于数据 T ，如果我们试图从多个线程同时修改的话，编译器会对我们作出警告，除非我们将数据包裹在 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> 中。所以说，当我们真的需要显式的同步机制时，编译器会强制要求我们这样做的。</p>
<h3 id="sized"><a class="header" href="#sized">Sized</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
</ul>
<p>如果一个类型实现了 <code>Sized</code> ，那么说明该类型具体大小的字节数在编译时可以确定，并且也就说明该类型的实例可以存放在栈上。</p>
<p>类型的大小以及其所带来的潜在影响，是一个易于忽略但是又十分宏大的话题，它深刻地影响着本门语言的诸多方面。鉴于它的重要性，我已经写了一整篇文章（<a href="../../sizedness-in-rust.html">Sizedness in Rust</a>）来具体阐述其内容，我高度推荐对于希望深入 sizedness 的人阅读此篇文章。下面是此篇文章的要点：</p>
<ol>
<li>所有的泛型类型都具有隐式的 <code>Sized</code> 约束。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn func&lt;T&gt;(t: &amp;T) {}

// example above desugared
// 以上代码等价于
fn func&lt;T: Sized&gt;(t: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>由于所有的泛型类型都具有隐式的 <code>Sized</code> 约束，如果我们希望摆脱这样的隐式约束，那么我们需要使用特殊的 <em>“宽松约束”</em> 记号 <code>?Sized</code> ，目前这样的记号仅适用于 <code>Sized</code> 特性：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// now T can be unsized
// 现在 T 的大小可以是未知的
fn func&lt;T: ?Sized&gt;(t: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>所有的特性都具有隐式的 <code>?Sized</code> 约束。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// example above desugared
// 以上代码等价于
trait Trait: ?Sized {}
<span class="boring">}
</span></code></pre></pre>
<p>这就是为什么特性对象可以实现具体特性。再次，向您推荐关于一切真相的<a href="../../sizedness-in-rust.html">Sizedness in Rust</a>。</p>
<h2 id="常用特性-general-traits"><a class="header" href="#常用特性-general-traits">常用特性 General traits</a></h2>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>为特定类型实现 <code>Default</code> 特性时，即为该类型赋予了可选的默认值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color {
    r: u8,
    g: u8,
    b: u8,
}

impl Default for Color {
    // default color is black
    // 默认颜色是黑色
    fn default() -&gt; Self {
        Color {
            r: 0,
            g: 0,
            b: 0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这不仅利于快速原型设计，另外，在有时我们仅仅只是需要该类型的一个值，却完全不在意该值是什么的时候，这也非常方便。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // just give me some color!
    let color = Color::default();
}
</code></pre></pre>
<p>如此，我们可以明确地向该函数的用户传达出该函数某个参数的可选择性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Canvas;
enum Shape {
    Circle,
    Rectangle,
}

impl Canvas {
    // let user optionally pass a color
    // 用户可选地传入一个 color
    fn paint(&amp;mut self, shape: Shape, color: Option&lt;Color&gt;) {
        // if no color is passed use the default color
        // 若用户没有传入 color ，即使用默认的 color
        let color = color.unwrap_or_default();
        // etc
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在泛型编程的语境中，<code>Default</code> 特性也可显其威力。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn guarantee_length&lt;T: Default&gt;(mut vec: Vec&lt;T&gt;, min_len: usize) -&gt; Vec&lt;T&gt; {
    for _ in 0..min_len.saturating_sub(vec.len()) {
        vec.push(T::default());
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>另外，我们在使用 update 记号构造结构体时也可享受到 <code>Default</code> 特性带来的便利。我们以 <code>Color</code> 结构的 <code>new</code> 构造器函数为例，它接受该结构的全部成员作为参数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
    fn new(r: u8, g: u8, b: u8) -&gt; Self {
        Color {
            r,
            g,
            b,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>考虑以下更加便捷的构造器函数 —— 它仅接受该结构的部分成员作为参数，其它未指定的成员则回落到默认值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
    fn red(r: u8) -&gt; Self {
        Color {
            r,
            ..Color::default()
        }
    }
    fn green(g: u8) -&gt; Self {
        Color {
            g,
            ..Color::default()
        }
    }
    fn blue(b: u8) -&gt; Self {
        Color {
            b,
            ..Color::default()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Default</code> 特性也可以用衍生宏的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// default color is still black
// because u8::default() == 0
// 默认颜色仍旧是黑色
// 因为 u8::default() == 0
#[derive(Default)]
struct Color {
    r: u8,
    g: u8,
    b: u8
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Clone {
    fn clone(&amp;self) -&gt; Self;

    // provided default impls
    // 提供默认实现
    fn clone_from(&amp;mut self, source: &amp;Self);
}
<span class="boring">}
</span></code></pre></pre>
<p>对于实现了 <code>Clone</code> 特性的类型，我们可以将一个不可变的引用转换为自有的类型，比如 <code>&amp;T</code> -&gt; <code>T</code> 。<code>Clone</code> 特性对于这种转换的效率不做出保证，所以这样的转换速度可能很慢，代价可能很昂贵。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct SomeType {
    cloneable_member1: CloneableType1,
    cloneable_member2: CloneableType2,
    // etc
}

// macro generates impl below
// 宏展开后为
impl Clone for SomeType {
    fn clone(&amp;self) -&gt; Self {
        SomeType {
            cloneable_member1: self.cloneable_member1.clone(),
            cloneable_member2: self.cloneable_member2.clone(),
            // etc
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Clone</code> 特性也有利于在泛型编程的语境中构造类型。请看下例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn guarantee_length&lt;T: Clone&gt;(mut vec: Vec&lt;T&gt;, min_len: usize, fill_with: &amp;T) -&gt; Vec&lt;T&gt; {
    for _ in 0..min_len.saturating_sub(vec.len()) {
        vec.push(fill_with.clone());
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>克隆确是一个可以逃避借用检查器的好方法。倘若我们编写的代码无法通过借用检查，那么不妨通过克隆将这些引用转换为自有类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// oof, we gotta worry about lifetimes 😟
// 糟糕！我们真的有自信处理好 lifetime 吗？ 😟
struct SomeStruct&lt;'a&gt; {
    data: &amp;'a Vec&lt;u8&gt;,
}

// now we're on easy street 😎
// 好耶！人生苦短，我用 Clone ! 😎
struct SomeStruct {
    data: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果性能因素微不足道，我们不必羞于使用克隆。Rust 是一门底层语言，人们可以自由地控制程序行为的方方面面，这就很容易令人陷入盲目追求优化的陷阱，而不是专注于着手解决问题。对此我给出的建议是：正确第一，优雅第二，性能第三。只有程序初具雏形后，性能瓶颈的问题才可能凸显，这时我们再解决性能问题也不迟。与其说这是一条编程建议，更不如说这是一条人生建议，万事万物大抵如此，如果你现在不信，总有一天你会的。</p>
<h3 id="copy"><a class="header" href="#copy">Copy</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy: Clone {}
<span class="boring">}
</span></code></pre></pre>
<p>对于实现了 <code>Copy</code> 特性的类型，我们可以拷贝它，即 <code>T</code> -&gt; <code>T</code> 。<code>Copy</code> 特性确保了拷贝操作是按位的拷贝，所以它更快更高效。<code>Copy</code> 特性不可手动实现，必须由编译器提供其实现。注意：当使用衍生宏为类型实现 <code>Copy</code> 特性时，必须同时使用 <code>Clone</code> 衍生宏，因为 <code>Copy</code> 是 <code>Clone</code> 的子特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct SomeType;
<span class="boring">}
</span></code></pre></pre>
<p><code>Copy</code> 改良了 <code>Clone</code> 。克隆操作可能速度缓慢且代价昂贵，但是拷贝操作一定是高效低耗的，可以说拷贝就是一种物美价廉的克隆。<code>Copy</code> 特性的实现会令 <code>Clone</code> 特性的实现变得微不足道：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this is what the derive macro generates
// 衍生宏展开如下
impl&lt;T: Copy&gt; Clone for T {
    // the clone method becomes just a copy
    // 克隆实际上变成了一种拷贝
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>实现了 <code>Copy</code> 特性的类型，其在移动时的行为会发生变化。默认情况下，所有的类型都具有 <em>移动语义</em> ，但是一旦该类型实现了 <code>Copy</code> 特性，则会变为 <em>拷贝语义</em>。 请考虑下例中语义的不同：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a &quot;move&quot;, src: !Copy
// 移动语义，src 没有实现 Copy 特性
let dest = src; 

// a &quot;copy&quot;, src: Copy
// 拷贝语义，src 实现 Copy 特性
let dest = src;
<span class="boring">}
</span></code></pre></pre>
<p>事实上，这两种语义背后执行的操作是完全相同的，都是将 <code>src</code> 按位复制到 <code>dest</code> 。其不同在于，在移动语义下，借用检查器从此吊销了 <code>src</code> 的可用性，而在拷贝语义下，<code>src</code> 保持可用。</p>
<p>言而总之，拷贝就是移动，移动就是拷贝。它们在底层毫无二致，仅仅是借用检查器对待它们的方式不同。</p>
<p>对于移动行为来讲更具体的例子 —— 你可以将 <code>src</code> 想象为一个 <code>Vec&lt;i32&gt;</code>，它的结构体大致如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ data: *mut [i32], length: usize, capacity: usize }
<span class="boring">}
</span></code></pre></pre>
<p>执行 <code>desc = src</code> 的结果如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src = { data: *mut [i32], length: usize, capacity: usize }
dest = { data: *mut [i32], length: usize, capacity: usize }
<span class="boring">}
</span></code></pre></pre>
<p>此时 <code>src</code> 和 <code>dest</code> 就都是同一数据的可变引用了，这可就糟tm的大糕了，所以借用检查器就吊销了 <code>src</code> 的可用性，一旦再次使用 <code>src</code> 就会引发编译错误。</p>
<p>对于拷贝行为来讲更具体的例子 —— 你可以将 <code>src</code> 想象为一个 <code>Option&lt;i32&gt;</code> ，它的结构体大致如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ is_valid: bool, data: i32 }
<span class="boring">}
</span></code></pre></pre>
<p>执行 <code>desc = src</code> 的结果如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src = { is_valid: bool, data: i32 }
dest = { is_valid: bool, data: i32 }
<span class="boring">}
</span></code></pre></pre>
<p>此时两者同时可用！因为 <code>Option&lt;i32&gt;</code> 实现了 <code>Copy</code> 。</p>
<p>或许你已经注意到，令 <code>Copy</code> 特性成为可自动实现的特性在理论上是可行的。但是 Rust 语言的设计者认为，比之于在恰当时隐式地继承拷贝语义，显示地声明为拷贝语义更加的简单和安全。前者可能会导致 Rust 语言产生十分反人类的行为，也更容易出现 bug 。</p>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Any: 'static {
    fn type_id(&amp;self) -&gt; TypeId;
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 的多态性风格本身是参数化的，但如果我们希望临时使用一种更贴近于动态语言的多态性风格，可以借用 <code>Any</code> 特性来模拟。我们不需要手动实现 <code>Any</code> 特性，因为该特性通常由通用泛型实现所实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: 'static + ?Sized&gt; Any for T {
    fn type_id(&amp;self) -&gt; TypeId {
        TypeId::of::&lt;T&gt;()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>对于 <code>dyn Any</code> 的特性对象，我们可以使用 <code>downcast_ref::&lt;T&gt;()</code> 或 <code>downcast_mut::&lt;T&gt;()</code> 来尝试解析出 <code>T</code> 。</p>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&amp;mut self) {
        self.x += 1;
        self.y += 1;
    }
}

fn map_any(mut any: Box&lt;dyn Any&gt;) -&gt; Box&lt;dyn Any&gt; {
    if let Some(num) = any.downcast_mut::&lt;i32&gt;() {
        *num += 1;
    } else if let Some(string) = any.downcast_mut::&lt;String&gt;() {
        *string += &quot;!&quot;;
    } else if let Some(point) = any.downcast_mut::&lt;Point&gt;() {
        point.inc();
    }
    any
}

fn main() {
    let mut vec: Vec&lt;Box&lt;dyn Any&gt;&gt; = vec![
        Box::new(0),
        Box::new(String::from(&quot;a&quot;)),
        Box::new(Point::default()),
    ];
    // vec = [0, &quot;a&quot;, Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_any).collect();
    // vec = [1, &quot;a!&quot;, Point { x: 1, y: 1 }]
}
</code></pre></pre>
<p>这个特性鲜少被使用，因为参数化的多态性时常要优于这样变通使用的多态性，且后者也可以使用更加类型安全和更加直接的枚举来模拟。如下例：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&amp;mut self) {
        self.x += 1;
        self.y += 1;
    }
}

enum Stuff {
    Integer(i32),
    String(String),
    Point(Point),
}

fn map_stuff(mut stuff: Stuff) -&gt; Stuff {
    match &amp;mut stuff {
        Stuff::Integer(num) =&gt; *num += 1,
        Stuff::String(string) =&gt; *string += &quot;!&quot;,
        Stuff::Point(point) =&gt; point.inc(),
    }
    stuff
}

fn main() {
    let mut vec = vec![
        Stuff::Integer(0),
        Stuff::String(String::from(&quot;a&quot;)),
        Stuff::Point(Point::default()),
    ];
    // vec = [0, &quot;a&quot;, Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_stuff).collect();
    // vec = [1, &quot;a!&quot;, Point { x: 1, y: 1 }]
}
</code></pre></pre>
<p>尽管 <code>Any</code> 特性鲜少是必须要被使用的，但有时它又是一种非常便捷的用法，我们将在 <strong>错误处理</strong> 一章中领会这一点。</p>
<h2 id="文本格式化特性"><a class="header" href="#文本格式化特性">文本格式化特性</a></h2>
<p>我们可以使用 <code>std::fmt</code> 中提供的文本格式化宏来序列化结构体，例如我们最熟悉的 <code>println!</code> 。我们可以将文本格式化的参数传入 <code>{}</code> 占位符，以选择具体用哪个特性来序列化该结构。</p>
<table><thead><tr><th>特性</th><th>占位符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>Display</code></td><td><code>{}</code></td><td>常规序列化</td></tr>
<tr><td><code>Debug</code></td><td><code>{:?}</code></td><td>调试序列化</td></tr>
<tr><td><code>Octal</code></td><td><code>{:o}</code></td><td>八进制序列化</td></tr>
<tr><td><code>LowerHex</code></td><td><code>{:x}</code></td><td>小写十六进制序列化</td></tr>
<tr><td><code>UpperHex</code></td><td><code>{:X}</code></td><td>大写十六进制序列化</td></tr>
<tr><td><code>Pointer</code></td><td><code>{:p}</code></td><td>内存地址</td></tr>
<tr><td><code>Binary</code></td><td><code>{:b}</code></td><td>二进制序列化</td></tr>
<tr><td><code>LowerExp</code></td><td><code>{:e}</code></td><td>小写指数序列化</td></tr>
<tr><td><code>UpperExp</code></td><td><code>{:E}</code></td><td>大写十六进制序列化</td></tr>
</tbody></table>
<h3 id="display--tostring"><a class="header" href="#display--tostring">Display &amp; ToString</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>Display</code> 特性的类型可以被序列化为 <code>String</code> 。这对于程序的用户来说非常的友好。例如：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}

fn main() {
    println!(&quot;origin: {}&quot;, Point::default());
    // prints &quot;origin: (0, 0)&quot;

    // get Point's Display representation as a String
    // Point 表达为可显示的 String
    let stringified_point = format!(&quot;{}&quot;, Point::default());
    assert_eq!(&quot;(0, 0)&quot;, stringified_point); // ✅
}
</code></pre></pre>
<p>除了使用 <code>format!</code> 宏来序列化结构体，我们也可以使用 <code>ToString</code> 特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>我们不需要自己手动实现，事实上，我们也不能，因为对于实现了 <code>Display</code> 的类型来说，<code>ToString</code> 是由通用泛型实现所自动实现的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display + ?Sized&gt; ToString for T;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Using <code>ToString</code> with <code>Point</code>:</p>
</blockquote>
<p>对 <code>Point</code> 使用 <code>ToString</code> 特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test] // ✅
fn display_point() {
    let origin = Point::default();
    assert_eq!(format!(&quot;{}&quot;, origin), &quot;(0, 0)&quot;);
}

#[test] // ✅
fn point_to_string() {
    let origin = Point::default();
    assert_eq!(origin.to_string(), &quot;(0, 0)&quot;);
}

#[test] // ✅
fn display_equals_to_string() {
    let origin = Point::default();
    assert_eq!(format!(&quot;{}&quot;, origin), origin.to_string());
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Debug</code> 与 <code>Display</code> 具有相同的签名。唯一的区别在于我们使用 <code>{:?}</code> 文本格式化指令来调用 <code>Debug</code> 特性。 <code>Debug</code> 特性可以使用如下方法衍生：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// derive macro generates impl below
// 衍生宏展开如下
impl fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_struct(&quot;Point&quot;)
            .field(&quot;x&quot;, &amp;self.x)
            .field(&quot;y&quot;, &amp;self.y)
            .finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为特定类型实现 <code>Debug</code> 特性的同时，这也使得我们可以使用 <code>dbg!</code> 宏来快速地调试程序，这种方式要优于 <code>println!</code> 。其优点在于：</p>
<ol>
<li><code>dbg!</code> 输出到标准错误流而不是标准输出流，所以我们能够很容易地将调试信息提取出来。</li>
<li><code>dbg!</code> 同时输出值和值的求值表达式。</li>
<li><code>dbg!</code> 接管参数的属权，但不会吞掉参数，而是再抛出来，所以可以将它用在表达式中：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_condition() -&gt; bool {
    true
}

// no logging
// 没有日志
fn example() {
    if some_condition() {
        // some code
    }
}

// println! logging
// 使用 println! 打印日志
fn example_println() {
    // 🤦
    let result = some_condition();
    println!(&quot;{}&quot;, result); // just prints &quot;true&quot;
                            // 仅仅打印 &quot;true&quot;
    if result {
        // some code
    }
}

// dbg! logging
// 使用 dbg! 打印日志
fn example_dbg() {
    // 😍
    if dbg!(some_condition()) { // prints &quot;[src/main.rs:22] some_condition() = true&quot;
                                // 太棒了！打印出丰富的调试信息
        // some code
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>dbg!</code> 宏唯一的缺点是，它不能在构建最终发布的二进制文件时自动删除，我们不得不手动删除相关代码。</p>
<h2 id="算符重载特性"><a class="header" href="#算符重载特性">算符重载特性</a></h2>
<p>在 Rust 中，所有的算符都与相应的特性相关联。为特定类型实现相应特性，即为该类型实现了相应算符。</p>
<table><thead><tr><th>特性</th><th>类别</th><th>算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>Eq</code>, <code>PartialEq</code></td><td>比较</td><td><code>==</code></td><td>相等</td></tr>
<tr><td><code>Ord</code>, <code>PartialOrd</code></td><td>比较</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>比较</td></tr>
<tr><td><code>Add</code></td><td>算数</td><td><code>+</code></td><td>加</td></tr>
<tr><td><code>AddAssign</code></td><td>算数</td><td><code>+=</code></td><td>加等于</td></tr>
<tr><td><code>BitAnd</code></td><td>算数</td><td><code>&amp;</code></td><td>按位与</td></tr>
<tr><td><code>BitAndAssign</code></td><td>算数</td><td><code>&amp;=</code></td><td>按位与等于</td></tr>
<tr><td><code>BitXor</code></td><td>算数</td><td><code>^</code></td><td>按位异或</td></tr>
<tr><td><code>BitXorAssign</code></td><td>算数</td><td><code>^=</code></td><td>按位异或等于</td></tr>
<tr><td><code>Div</code></td><td>算数</td><td><code>/</code></td><td>除</td></tr>
<tr><td><code>DivAssign</code></td><td>算数</td><td><code>/=</code></td><td>除等于</td></tr>
<tr><td><code>Mul</code></td><td>算数</td><td><code>*</code></td><td>乘</td></tr>
<tr><td><code>MulAssign</code></td><td>算数</td><td><code>*=</code></td><td>乘等于</td></tr>
<tr><td><code>Neg</code></td><td>算数</td><td><code>-</code></td><td>一元负</td></tr>
<tr><td><code>Not</code></td><td>算数</td><td><code>!</code></td><td>一元逻辑非</td></tr>
<tr><td><code>Rem</code></td><td>算数</td><td><code>%</code></td><td>求余</td></tr>
<tr><td><code>RemAssign</code></td><td>算数</td><td><code>%=</code></td><td>求余等于</td></tr>
<tr><td><code>Shl</code></td><td>算数</td><td><code>&lt;&lt;</code></td><td>左移</td></tr>
<tr><td><code>ShlAssign</code></td><td>算数</td><td><code>&lt;&lt;=</code></td><td>左移等于</td></tr>
<tr><td><code>Shr</code></td><td>算数</td><td><code>&gt;&gt;</code></td><td>右移</td></tr>
<tr><td><code>ShrAssign</code></td><td>算数</td><td><code>&gt;&gt;=</code></td><td>右移等于</td></tr>
<tr><td><code>Sub</code></td><td>算数</td><td><code>-</code></td><td>减</td></tr>
<tr><td><code>SubAssign</code></td><td>算数</td><td><code>-=</code></td><td>减等于</td></tr>
<tr><td><code>Fn</code></td><td>闭包</td><td><code>(...args)</code></td><td>不可变闭包调用</td></tr>
<tr><td><code>FnMut</code></td><td>闭包</td><td><code>(...args)</code></td><td>可变闭包调用</td></tr>
<tr><td><code>FnOnce</code></td><td>闭包</td><td><code>(...args)</code></td><td>一次性闭包调用</td></tr>
<tr><td><code>Deref</code></td><td>其它</td><td><code>*</code></td><td>不可变解引用</td></tr>
<tr><td><code>DerefMut</code></td><td>其它</td><td><code>*</code></td><td>可变解引用</td></tr>
<tr><td><code>Drop</code></td><td>其它</td><td>-</td><td>类型析构</td></tr>
<tr><td><code>Index</code></td><td>其它</td><td><code>[]</code></td><td>不可变索引</td></tr>
<tr><td><code>IndexMut</code></td><td>其它</td><td><code>[]</code></td><td>可变索引</td></tr>
<tr><td><code>RangeBounds</code></td><td>其它</td><td><code>..</code></td><td>范围迭代</td></tr>
</tbody></table>
<h3 id="比较特性-comparison-traits"><a class="header" href="#比较特性-comparison-traits">比较特性 Comparison Traits</a></h3>
<table><thead><tr><th>特性</th><th>类别</th><th>算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>Eq</code>, <code>PartialEq</code></td><td>比较</td><td><code>==</code></td><td>相等</td></tr>
<tr><td><code>Ord</code>, <code>PartialOrd</code></td><td>比较</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>比较</td></tr>
</tbody></table>
<h4 id="partialeq--eq"><a class="header" href="#partialeq--eq">PartialEq &amp; Eq</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PartialEq&lt;Rhs = Self&gt; 
where
    Rhs: ?Sized, 
{
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    // provided default impls
    // 提供默认实现
    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现了 <code>PartialEq&lt;Rhs&gt;</code> 特性的类型可以使用 <code>==</code> 算符来检查与 <code>Rhs</code> 的相等性。</p>
<p>对 <code>PartialEq&lt;Rhs&gt;</code> 的实现须确保实现对称性与传递性。这意味着对于任意 <code>a</code> ， <code>b</code> 和 <code>c</code> 有：</p>
<ul>
<li>若 <code>a == b</code> 则 <code>b == a</code> （对称性）</li>
<li>若 <code>a == b &amp;&amp; b == c</code> 则 <code>a == c</code> （传递性）</li>
</ul>
<p>默认情况下 <code>Rhs = Self</code> 是因为我们几乎总是在相同类型之间进行比较。这也自动地确保了我们的实现是对称的、可传递的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32
}

// Rhs == Self == Point
impl PartialEq for Point {
    // impl automatically symmetric &amp; transitive
    // 该实现自动确保了对称性于传递性
    fn eq(&amp;self, other: &amp;Point) -&gt; bool {
        self.x == other.x &amp;&amp; self.y == other.y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果特定类型的成员都实现了 <code>PartialEq</code> 特性，那么该类型也可衍生该特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Point {
    x: i32,
    y: i32
}

#[derive(PartialEq)]
enum Suit {
    Spade,
    Heart,
    Club,
    Diamond,
}
<span class="boring">}
</span></code></pre></pre>
<p>多亏了通用泛型实现，一旦我们为特定类型实现了 <code>PartialEq</code> 特性，那么直接使用该类型的引用互相比较也是可以的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this impl only gives us: Point == Point
// 该衍生宏本身只允许我们在结构体之间进行比较
#[derive(PartialEq)]
struct Point {
    x: i32,
    y: i32
}

// all of the generic blanket impls below
// are provided by the standard library
// 以下的通用泛型实现由标准库提供

// this impl gives us: &amp;Point == &amp;Point
// 这个通用泛型实现允许我们通过不可变引用之间进行比较
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ B&gt; for &amp;'_ A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;mut Point == &amp;Point
// 这个通用泛型实现允许我们通过可变引用与不可变引用进行比较
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ B&gt; for &amp;'_ mut A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;Point == &amp;mut Point
// 这个通用泛型实现允许我们通过不可变引用与可变引用进行比较
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ mut B&gt; for &amp;'_ A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;mut Point == &amp;mut Point
// 这个通用泛型实现允许我们通过可变引用之间进行比较
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ mut B&gt; for &amp;'_ mut A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;
<span class="boring">}
</span></code></pre></pre>
<p>由于该特性提供泛型，我们可以定义不同类型之间的可相等性。标准库正是利用这一点提供了不同类型字符串之间的比较功能，例如<code>String</code>， <code>&amp;str</code>， <code>PathBuf</code>，<code>&amp;Path</code>，<code>OsString</code> 和 <code>&amp;OsStr</code>等等。</p>
<p>通常来说我们仅会实现相同类型之间的可相等性，除非两种类型虽然包含同一类数据，但又有表达形式或交互形式的差异，这时我们才会考虑实现不同类型之间的可相等性。</p>
<p>以下是一个有趣但糟糕的例子，它尝试为不同类型实现 <code>PartialEq</code> 但又违背了上述要求：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq)]
enum Suit {
    Spade,
    Club,
    Heart,
    Diamond,
}

#[derive(PartialEq)]
enum Rank {
    Ace,
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
}

#[derive(PartialEq)]
struct Card {
    suit: Suit,
    rank: Rank,
}

// check equality of Card's suit
// 检查花色的相等性
impl PartialEq&lt;Suit&gt; for Card {
    fn eq(&amp;self, other: &amp;Suit) -&gt; bool {
        self.suit == *other
    }
}

// check equality of Card's rank
// 检查牌序的相等性
impl PartialEq&lt;Rank&gt; for Card {
    fn eq(&amp;self, other: &amp;Rank) -&gt; bool {
        self.rank == *other
    }
}

fn main() {
    let AceOfSpades = Card {
        suit: Suit::Spade,
        rank: Rank::Ace,
    };
    assert!(AceOfSpades == Suit::Spade); // ✅
    assert!(AceOfSpades == Rank::Ace); // ✅
}
</code></pre></pre>
<p>上述代码有效且其逻辑有几分道理，黑桃 A 既是黑桃也是 A 。但如果我们真的去写一个处理扑克牌的库的话，最简单也最方便的方法莫过于独立地检查牌面的花色和牌序。而且，上述代码并不满足对称性！我们可以使用 <code>Card == Suit</code> 和 <code>Card == Rank</code> ，但却不能使用 <code>Suit == Card</code> 和 <code>Rank == Card</code>， 让我们来修复这一点：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// check equality of Card's suit
// 检查花色的相等性
impl PartialEq&lt;Suit&gt; for Card {
    fn eq(&amp;self, other: &amp;Suit) -&gt; bool {
        self.suit == *other
    }
}

// added for symmetry
// 增加对称性
impl PartialEq&lt;Card&gt; for Suit {
    fn eq(&amp;self, other: &amp;Card) -&gt; bool {
        *self == other.suit
    }
}

// check equality of Card's rank
// 检查牌序的相等性
impl PartialEq&lt;Rank&gt; for Card {
    fn eq(&amp;self, other: &amp;Rank) -&gt; bool {
        self.rank == *other
    }
}

// added for symmetry
// 增加对称性
impl PartialEq&lt;Card&gt; for Rank {
    fn eq(&amp;self, other: &amp;Card) -&gt; bool {
        *self == other.rank
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们实现了对称性！棒！但是实现对称性却破坏了传递性！糟tm大糕！考虑以下代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Ace of Spades
    // ♠A
    let a = Card {
        suit: Suit::Spade,
        rank: Rank::Ace,
    };
    let b = Suit::Spade;
    // King of Spades
    // ♠K
    let c = Card {
        suit: Suit::Spade,
        rank: Rank::King,
    };
    assert!(a == b &amp;&amp; b == c); // ✅
    assert!(a == c); // ❌
}
</code></pre></pre>
<p>关于对不同类型实现 <code>PartialEq</code> 特性的绝佳示例如下，本程序的功能在于处理空间上的距离，它使用不同的类型以表示不同的测量单位：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq)]
struct Foot(u32);

#[derive(PartialEq)]
struct Yard(u32);

#[derive(PartialEq)]
struct Mile(u32);

impl PartialEq&lt;Mile&gt; for Foot {
    fn eq(&amp;self, other: &amp;Mile) -&gt; bool {
        self.0 == other.0 * 5280
    }
}

impl PartialEq&lt;Foot&gt; for Mile {
    fn eq(&amp;self, other: &amp;Foot) -&gt; bool {
        self.0 * 5280 == other.0
    }    
}

impl PartialEq&lt;Mile&gt; for Yard {
    fn eq(&amp;self, other: &amp;Mile) -&gt; bool {
        self.0 == other.0 * 1760
    }
}

impl PartialEq&lt;Yard&gt; for Mile {
    fn eq(&amp;self, other: &amp;Yard) -&gt; bool {
        self.0 * 1760 == other.0
    }    
}

impl PartialEq&lt;Foot&gt; for Yard {
    fn eq(&amp;self, other: &amp;Foot) -&gt; bool {
        self.0 * 3 == other.0
    }
}

impl PartialEq&lt;Yard&gt; for Foot {
    fn eq(&amp;self, other: &amp;Yard) -&gt; bool {
        self.0 == other.0 * 3
    }
}

fn main() {
    let a = Foot(5280);
    let b = Yard(1760);
    let c = Mile(1);
    
    // symmetry
    // 对称性
    assert!(a == b &amp;&amp; b == a); // ✅
    assert!(b == c &amp;&amp; c == b); // ✅
    assert!(a == c &amp;&amp; c == a); // ✅

    // transitivity
    // 传递性
    assert!(a == b &amp;&amp; b == c &amp;&amp; a == c); // ✅
    assert!(c == b &amp;&amp; b == a &amp;&amp; c == a); // ✅
}
</code></pre></pre>
<p><code>Eq</code> 是仅用于标记的特性，也是 <code>PartialEq&lt;Self&gt;</code> 的子特性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Eq: PartialEq&lt;Self&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>鉴于 <code>PartialEq</code> 特性提供的对称性与传递性，一旦我们实现 <code>Eq</code> 特性，我们也就确保了该类型具有自反性，即对任意 <code>a</code> 有 <code>a == a</code> 。可以说， <code>Eq</code> 改良了 <code>PartialEq</code> ，因为它实现了一个比后者更加严格的可相等性。如果一个类型的全部成员都实现了 <code>Eq</code> 特性，那么该类型本身也可以衍生出该特性。</p>
<p>所有的浮点类型都实现了 <code>PartialEq</code> 但是没有实现 <code>Eq</code> ，因为 <code>NaN != NaN</code> 。几乎所有其它实现 <code>PartialEq</code> 的类型也都自然地实现了 <code>Eq</code> ，除非它们包含了浮点数。</p>
<p>对于实现了 <code>PartialEq</code> 和 <code>Debug</code> 的类型，我们也可以将它用于 <code>assert_eq!</code>  宏。并且，我们可以对实现 <code>PartialEq</code> 特性的类型组成的集合进行比较。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn example_assert(p1: Point, p2: Point) {
    assert_eq!(p1, p2);
}

fn example_compare_collections&lt;T: PartialEq&gt;(vec1: Vec&lt;T&gt;, vec2: Vec&lt;T&gt;) {
    // if T: PartialEq this now works!
    if vec1 == vec2 {
        // some code
    } else {
        // other code
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="hash"><a class="header" href="#hash">Hash</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hash {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H);

    // provided default impls
    // 提供默认实现
    fn hash_slice&lt;H: Hasher&gt;(data: &amp;[Self], state: &amp;mut H);
}
<span class="boring">}
</span></code></pre></pre>
<p>本特性并未关联到任何算符，之所以在这里提及，是因为它与 <code>PartialEq</code> 与 <code>Eq</code> 密切的关系。实现 <code>Hash</code> 特性的类型可以通过 <code>Hasher</code> 作哈希运算。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::Hasher;
use std::hash::Hash;

struct Point {
    x: i32,
    y: i32,
}

impl Hash for Point {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        hasher.write_i32(self.x);
        hasher.write_i32(self.y);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以下衍生宏展开与以上代码中相同的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型同时实现了 <code>Hash</code> 和 <code>Eq</code> ，那么二者必须要实现步调一致，即对任意 <code>a</code> 与 <code>b</code> ， 若有 <code>a == b</code> ， 则必有 <code>a.hash() == b.hash()</code> 。所以，对于同时实现二者，要么都用衍生宏，要么都手动实现，不要一个用衍生宏，而另一个手动实现，否则我们将冒着步调不一致的极大风险。</p>
<p>实现<code>Eq</code> 和 <code>Hash</code> 特性的主要好处在于，这允许我们将该类型作为一个键存储于 <code>HashMap</code> 和 <code>HashSet</code> 中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

// now our type can be stored
// in HashSets and HashMaps!
// 现在我们的类型可以存储于 HashSet 和 HashMap 中了！
#[derive(PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}

fn example_hashset() {
    let mut points = HashSet::new();
    points.insert(Point { x: 0, y: 0 }); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="partialord--ord"><a class="header" href="#partialord--ord">PartialOrd &amp; Ord</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Ordering {
    Less,
    Equal,
    Greater,
}

trait PartialOrd&lt;Rhs = Self&gt;: PartialEq&lt;Rhs&gt; 
where
    Rhs: ?Sized, 
{
    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;;

    // provided default impls
    // 提供默认实现
    fn lt(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn le(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn gt(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn ge(&amp;self, other: &amp;Rhs) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>PartialOrd&lt;Rhs&gt;</code> 的类型可以和 <code>Rhs</code> 的类型之间使用 <code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，和 <code>&gt;=</code> 算符。</p>
<p>实现 <code>PartialOrd</code> 时须确保比较的非对称性和传递性。这意味着对任意 <code>a</code>，<code>b</code>，<code>c</code>有：</p>
<ul>
<li>若 <code>a &lt; b</code> 则 <code>!(a &gt; b)</code> （非对称性）</li>
<li>若 <code>a &lt; b &amp;&amp; b &lt; c</code> 则 <code>a &lt; c</code> （传递性）</li>
</ul>
<p><code>PartialOrd</code> 是 <code>PartialEq</code> 的子特性，二者必须要实现步调一致。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn must_always_agree&lt;T: PartialOrd + PartialEq&gt;(t1: T, t2: T) {
    assert_eq!(t1.partial_cmp(&amp;t2) == Some(Ordering::Equal), t1 == t2);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>PartialOrd</code> 改良了 <code>PartialEq</code> ，后者仅能比较是否相等，而前者除了能比较是否相等，还能比较孰大孰小。</p>
<p>默认情况下 <code>Rhs = Self</code> ，因为我们几乎总是在相同类型的实例之间相比较，而不是不同类型之间。这一点自动保证了我们的实现的对称性和传递性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32
}

// Rhs == Self == Point
impl PartialOrd for Point {
    // impl automatically symmetric &amp; transitive
    // 该实现自动确保了对称性与传递性
    fn partial_cmp(&amp;self, other: &amp;Point) -&gt; Option&lt;Ordering&gt; {
        Some(match self.x.cmp(&amp;other.x) {
            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
            ordering =&gt; ordering,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果特定类型的全部成员都实现了 <code>PartialOrd</code> 特性，那么该类型也可以衍生出该特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(PartialEq, PartialOrd)]
enum Stoplight {
    Red,
    Yellow,
    Green,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>PartialOrd</code> 衍生宏依据 <strong>类型成员的定义顺序</strong> 对类型进行排序：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// generates PartialOrd impl which orders
// Points based on x member first and
// y member second because that's the order
// they appear in the source code
// 宏展开的 PartialOrd 实现排序时
// 首先考虑 x 再考虑 y
// 因为这是它们在源代码中出现的顺序
#[derive(PartialOrd, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// generates DIFFERENT PartialOrd impl
// which orders Points based on y member
// first and x member second
// 这里宏展开的 PartialOrd 实现排序时
// 首先考虑 y 再考虑 x
#[derive(PartialOrd, PartialEq)]
struct Point {
    y: i32,
    x: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Ord</code> 是 <code>Eq</code> 和 <code>PartialOrd&lt;Self&gt;</code> 的子特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Ord: Eq + PartialOrd&lt;Self&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;

    // provided default impls
    // 提供默认实现
    fn max(self, other: Self) -&gt; Self;
    fn min(self, other: Self) -&gt; Self;
    fn clamp(self, min: Self, max: Self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>鉴于 <code>PartialOrd</code> 提供的非对称性和传递性，对特定类型实现 <code>Ord</code> 特性的同时也就保证了其非对称性，即对于任意 <code>a</code> 与 <code>b</code> 有 <code>a &lt; b</code> ，<code>a == b</code> ，<code>a &lt; b</code> 。可以说， <code>Ord</code> 改良了 <code>Eq</code> 和 <code>PartialOrd</code> ，因为它提供了一种更加严格的比较。如果一个类型实现了 <code>Ord</code> ，那么 <code>PartialOrd</code> ，<code>PartialEq</code> 和 <code>Eq</code> 的实现也就微不足道了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

// of course we can use the derive macros here
// 可以使用衍生宏
#[derive(Ord, PartialOrd, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// note: as with PartialOrd, the Ord derive macro
// orders a type based on the lexicographical order
// of its members
// 注意：与 PatrialOrd 相同，Ord 衍生宏衍生宏依据
// 类型的成员的定义顺序 对类型进行排序

// but here's the impls if we wrote them out by hand
// 以下是我们手动的实现
impl Ord for Point {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        match self.x.cmp(&amp;other.x) {
            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
            ordering =&gt; ordering,
        }
    }
}
impl PartialOrd for Point {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}
impl PartialEq for Point {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.cmp(other) == Ordering::Equal
    }
}
impl Eq for Point {}
<span class="boring">}
</span></code></pre></pre>
<p>浮点数类型实现了 <code>PartialOrd</code> 但是没有实现 <code>Ord</code> ，因为 <code>NaN &lt; 0 == false</code> 与 <code>NaN &gt;= 0 == false</code> 同时为真。几乎所有其它实现 <code>PartialOrd</code> 的类型都实现了 <code>Ord</code> ，除非该类型包含浮点数。</p>
<p>对于实现了 <code>Ord</code> 特性的类型，我们可以将它存储于 <code>BTreeMap</code> 和 <code>BTreeSet</code> ，并且可以通过 <code>sort()</code> 方法对切片，或者任何可以自动解引用为切片的类型进行排序，例如 <code>Vec</code> 和 <code>VecDeque</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BTreeSet;

// now our type can be stored
// in BTreeSets and BTreeMaps!
// 现在我们的类型可以存储于 BTreeSet 和 BTreeMap 中了！
#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

fn example_btreeset() {
    let mut points = BTreeSet::new();
    points.insert(Point { x: 0, y: 0 }); // ✅
}

// we can also .sort() Ord types in collections!
// 对于实现了 Ord 特性的类型，我们可以使用 .sort() 方法来对集合进行排序！
fn example_sort&lt;T: Ord&gt;(mut sortable: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    sortable.sort();
    sortable
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="算术特性-arithmetic-traits"><a class="header" href="#算术特性-arithmetic-traits">算术特性 Arithmetic Traits</a></h3>
<table><thead><tr><th>特性</th><th>类别</th><th>算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>Add</code></td><td>算数</td><td><code>+</code></td><td>加</td></tr>
<tr><td><code>AddAssign</code></td><td>算数</td><td><code>+=</code></td><td>加等于</td></tr>
<tr><td><code>BitAnd</code></td><td>算数</td><td><code>&amp;</code></td><td>按位与</td></tr>
<tr><td><code>BitAndAssign</code></td><td>算数</td><td><code>&amp;=</code></td><td>按位与等于</td></tr>
<tr><td><code>BitXor</code></td><td>算数</td><td><code>^</code></td><td>按位异或</td></tr>
<tr><td><code>BitXorAssign</code></td><td>算数</td><td><code>^=</code></td><td>按位异或等于</td></tr>
<tr><td><code>Div</code></td><td>算数</td><td><code>/</code></td><td>除</td></tr>
<tr><td><code>DivAssign</code></td><td>算数</td><td><code>/=</code></td><td>除等于</td></tr>
<tr><td><code>Mul</code></td><td>算数</td><td><code>*</code></td><td>乘</td></tr>
<tr><td><code>MulAssign</code></td><td>算数</td><td><code>*=</code></td><td>乘等于</td></tr>
<tr><td><code>Neg</code></td><td>算数</td><td><code>-</code></td><td>一元负</td></tr>
<tr><td><code>Not</code></td><td>算数</td><td><code>!</code></td><td>一元逻辑非</td></tr>
<tr><td><code>Rem</code></td><td>算数</td><td><code>%</code></td><td>求余</td></tr>
<tr><td><code>RemAssign</code></td><td>算数</td><td><code>%=</code></td><td>求余等于</td></tr>
<tr><td><code>Shl</code></td><td>算数</td><td><code>&lt;&lt;</code></td><td>左移</td></tr>
<tr><td><code>ShlAssign</code></td><td>算数</td><td><code>&lt;&lt;=</code></td><td>左移等于</td></tr>
<tr><td><code>Shr</code></td><td>算数</td><td><code>&gt;&gt;</code></td><td>右移</td></tr>
<tr><td><code>ShrAssign</code></td><td>算数</td><td><code>&gt;&gt;=</code></td><td>右移等于</td></tr>
<tr><td><code>Sub</code></td><td>算数</td><td><code>-</code></td><td>减</td></tr>
<tr><td><code>SubAssign</code></td><td>算数</td><td><code>-=</code></td><td>减等于</td></tr>
</tbody></table>
<p>详解以上所有算术特性未免显得多余，且其大多仅用于操作数字类型。本文仅就最常见被重载的 <code>Add</code> 和 <code>AddAssign</code> 特性，亦即 <code>+</code> 和 <code>+=</code> 算符，进行说明，其重载广泛用于为集合增加内容或对不同事物的连接。这样，我们多侧重于最有趣的地方，而不是无趣枯燥地重复。</p>
<h4 id="add--addassign"><a class="header" href="#add--addassign">Add &amp; AddAssign</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>Add&lt;Rhs, Output = T&gt;</code> 特性的类型，与 <code>Rhs</code> 类型相加得到 <code>T</code> 类型的值。</p>
<p>下例对 <code>Point</code> 类型实现了 <code>Add&lt;Rhs, Output = T&gt;</code> ：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1 + p2;
    assert_eq!(p3.x, p1.x + p2.x); // ✅
    assert_eq!(p3.y, p1.y + p2.y); // ✅
}
</code></pre></pre>
<p>如果我们对 <code>Point</code> 的引用进行如上操作还能将他们加在一起吗？我们试试：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &amp;p1 + &amp;p2; // ❌
}
</code></pre></pre>
<p>遗憾的是，并不可以。编译器出错了：</p>
<pre><code class="language-none">error[E0369]: cannot add `&amp;Point` to `&amp;Point`
  --&gt; src/main.rs:50:25
   |
50 |     let p3: Point = &amp;p1 + &amp;p2;
   |                     --- ^ --- &amp;Point
   |                     |
   |                     &amp;Point
   |
   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`
</code></pre>
<p>在 Rust 的类型系统中，对于特定类型 <code>T</code> 来讲，<code>T</code> ，<code>&amp;T</code> ，<code>&amp;mut T</code> 三者本身是具有不同类型的，这意味着我们需要对它们分别实现相应特性。下面我们对 <code>&amp;Point</code> 实现 <code>Add</code> 特性：</p>
<pre><pre class="playground"><code class="language-rust">impl Add for &amp;Point {
    type Output = Point;
    fn add(self, rhs: &amp;Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &amp;p1 + &amp;p2; // ✅
    assert_eq!(p3.x, p1.x + p2.x); // ✅
    assert_eq!(p3.y, p1.y + p2.y); // ✅
}
</code></pre></pre>
<p>这是可行的，但是不觉得哪里怪怪的吗？我们对 <code>Point</code> 和 <code>&amp;Point</code> 分别实现了 <code>Add</code> 特性，现在来看这两种实现能够保持步调一致，但是未来也能保证吗？例如，我们现在决定对两个 <code>Point</code> 相加要产生一个 <code>Line</code> 而不是 <code>Point</code> ，可以对 <code>Add</code> 特性的实现做出如下改动：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(Copy, Clone)]
struct Line {
    start: Point,
    end: Point,
}

// we updated this impl
// 我们更新了这个实现
impl Add for Point {
    type Output = Line;
    fn add(self, rhs: Point) -&gt; Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

// but forgot to update this impl, uh oh!
// 但是忘记了更新这个实现，糟tm大糕！
impl Add for &amp;Point {
    type Output = Point;
    fn add(self, rhs: &amp;Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = p1 + p2; // ✅

    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = &amp;p1 + &amp;p2; // ❌ expected Line, found Point
                                // ❌ 期待得到 Line ，但是得到 Point
}
</code></pre></pre>
<p>我们对 <code>&amp;Point</code> 不可变引用类型的 <code>Add</code> 实现，给我们带来了不必要的维护困难。是否能够使得，当我们更改 <code>Point</code> 类型的实现时， <code>&amp;Point</code> 类型的实现也能够自动发生匹配，而不需要我们手动维护呢？我们的愿望是尽可能写出 <code>DRY (Don't Repeat Yourself)</code> 的不重复的代码。幸运的是，我们可以如此实现这一点：</p>
<pre><pre class="playground"><code class="language-rust">// updated, DRY impl
// 使用一种更“干”的实现
impl Add for &amp;Point {
    type Output = &lt;Point as Add&gt;::Output;
    fn add(self, rhs: &amp;Point) -&gt; Self::Output {
        Point::add(*self, *rhs)
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = p1 + p2; // ✅

    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = &amp;p1 + &amp;p2; // ✅
}
</code></pre></pre>
<p>实现 <code>AddAssign&lt;Rhs&gt;</code> 的类型，允许我们对 <code>Rhs</code> 的类型相加之并赋值到自身。该特性的声明为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AddAssign&lt;Rhs = Self&gt; {
    fn add_assign(&amp;mut self, rhs: Rhs);
}
<span class="boring">}
</span></code></pre></pre>
<p>对 <code>Point</code> 和 <code>&amp;Point</code> 类型的实现示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::AddAssign;

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32
}

impl AddAssign for Point {
    fn add_assign(&amp;mut self, rhs: Point) {
        self.x += rhs.x;
        self.y += rhs.y;
    }
}

impl AddAssign&lt;&amp;Point&gt; for Point {
    fn add_assign(&amp;mut self, rhs: &amp;Point) {
        Point::add_assign(self, *rhs);
    }
}

fn main() {
    let mut p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    p1 += &amp;p2;
    p1 += p2;
    assert!(p1.x == 7 &amp;&amp; p1.y == 10);
}
</code></pre></pre>
<h3 id="闭包特性-closure-traits"><a class="header" href="#闭包特性-closure-traits">闭包特性 Closure Traits</a></h3>
<table><thead><tr><th>特性</th><th>类别</th><th>算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>Fn</code></td><td>闭包</td><td><code>(...args)</code></td><td>不可变闭包调用</td></tr>
<tr><td><code>FnMut</code></td><td>闭包</td><td><code>(...args)</code></td><td>可变闭包调用</td></tr>
<tr><td><code>FnOnce</code></td><td>闭包</td><td><code>(...args)</code></td><td>一次性闭包调用</td></tr>
</tbody></table>
<h4 id="fnonce-fnmut--fn"><a class="header" href="#fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FnOnce&lt;Args&gt; {
    type Output;
    fn call_once(self, args: Args) -&gt; Self::Output;
}

trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    fn call(&amp;self, args: Args) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>事实上，在 stable Rust 中我们并不能对我们自己的类型实现上述特性，唯一的例外是闭包。对于闭包从环境中捕获的值的不同，该闭包会实现不同的特性：<code>FnOnce</code> ，<code>FnMut</code> ，<code>Fn</code> 。</p>
<p>对于实现 <code>FnOnce</code> 的闭包，仅可调用一次，因为它消耗掉了其执行中必须的值：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let range = 0..10;
    let get_range_count = || range.count();
    assert_eq!(get_range_count(), 10); // ✅
    get_range_count(); // ❌
}
</code></pre></pre>
<p>迭代器上的 <code>.count()</code> 方法会消耗掉整个迭代器，所以该方法仅能调用一次。所以我们的闭包也就是能调用一次了，这就是为什么当第二次调用该闭包时会出错：</p>
<pre><code class="language-none">error[E0382]: use of moved value: `get_range_count`
 --&gt; src/main.rs:5:5
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ----------------- `get_range_count` moved due to this call
5 |     get_range_count();
  |     ^^^^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `range` out of its environment
 --&gt; src/main.rs:3:30
  |
3 |     let get_range_count = || range.count();
  |                              ^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; src/main.rs:4:16
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ^^^^^^^^^^^^^^^
</code></pre>
<p>对于实现 <code>FnMut</code> 特性的闭包，我们可以多次调用，且其可以改变其从环境捕获的值。我们可以说实现 <code>FnMut</code> 的闭包的执行具有副作用，或者说它是具有状态的。下例展示了一个闭包，它通过跟踪最小值，来找到一个迭代器中所有非升序的值：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
    let mut min = i32::MIN;
    let ascending = nums.into_iter().filter(|&amp;n| {
        if n &lt;= min {
            false
        } else {
            min = n;
            true
        }
    }).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(vec![0, 4, 8, 10, 15, 18], ascending); // ✅
}
</code></pre></pre>
<p><code>FnMut</code> 改良了 <code>FnOnce</code> ，<code>FnOnce</code> 需要接管参数的属权因此只能调用一次，而 <code>FnMut</code> 只需要参数的可变引用即可并可调用多次。<code>FnMut</code> 可以在所有 <code>FnOnce</code> 可用的地方使用。</p>
<p>对于实现 <code>Fn </code> 特性的闭包，我们可以调用多次，且其不改变任何从环境中捕获的变量。我们可以说实现 <code>Fn</code> 的闭包的执行不具有副作用，或者说它是不具有状态的。下例展示了一个闭包，它通过与栈上的值进行比较，过滤掉一个迭代器中所有比它小的值：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
    let min = 9;
    let greater_than_9 = nums.into_iter().filter(|&amp;n| n &gt; min).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(vec![10, 15, 18, 13], greater_than_9); // ✅
}
</code></pre></pre>
<p><code>Fn</code> 改良了 <code>FnMut</code> ，尽管它们都可以多次调用，但是 <code>FnMut</code> 需要参数的可变引用，而 <code>Fn</code> 仅需要参数的不可变引用。<code>Fn</code> 可以在所有 <code>FnMut</code> 和 <code>FnOnce</code> 可用的地方使用。</p>
<p>如果一个闭包不从环境中捕获任何的值，那么从技术上讲它就不是闭包，而仅仅只是一个内联的匿名函数。并且它可以被转换为、用于或传递为一个常规函数指针，即 <code>fn</code>。函数指针可以用于任何 <code>Fn</code> ，<code>FnMut</code> ，<code>FnOnce</code> 可用的地方。</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn main() {
    let mut fn_ptr: fn(i32) -&gt; i32 = add_one;
    assert_eq!(fn_ptr(1), 2); // ✅
    
    // capture-less closure cast to fn pointer
    // 不捕获环境的闭包可转换为普通函数指针
    fn_ptr = |x| x + 1; // same as add_one
    assert_eq!(fn_ptr(1), 2); // ✅
}
</code></pre></pre>
<p>以下示例中，将常规函数作为闭包而传入：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![-1, 1, -2, 2, -3, 3];
    let absolutes: Vec&lt;i32&gt; = nums.into_iter().map(i32::abs).collect();
    assert_eq!(vec![1, 1, 2, 2, 3, 3], absolutes); // ✅
}
</code></pre></pre>
<h3 id="其它特性-other-traits"><a class="header" href="#其它特性-other-traits">其它特性 Other Traits</a></h3>
<table><thead><tr><th>特性</th><th>类别</th><th>算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>Deref</code></td><td>其它</td><td><code>*</code></td><td>不可变解引用</td></tr>
<tr><td><code>DerefMut</code></td><td>其它</td><td><code>*</code></td><td>可变解引用</td></tr>
<tr><td><code>Drop</code></td><td>其它</td><td>-</td><td>类型析构</td></tr>
<tr><td><code>Index</code></td><td>其它</td><td><code>[]</code></td><td>不可变索引</td></tr>
<tr><td><code>IndexMut</code></td><td>其它</td><td><code>[]</code></td><td>可变索引</td></tr>
<tr><td><code>RangeBounds</code></td><td>其它</td><td><code>..</code></td><td>范围迭代</td></tr>
</tbody></table>
<h4 id="deref--derefmut"><a class="header" href="#deref--derefmut">Deref &amp; DerefMut</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>Deref&lt;Target = T&gt;</code> 的类型，可以通过 <code>*</code> 解引用算符，解引用到 <code>T</code> 类型。智能指针是该特性的著名实现者，例如 <code>Box</code> 和 <code>Rc</code> 。不过，我们很少在 Rust 编程中看到解引用算符，这是由于 Rust 的强制解引用的特性所导致的。</p>
<p>当作为函数的参数、函数的返回值、方法的调用参数时，Rust 会自动地解引用。这就是为什么我们可以将 <code>&amp;String</code> 或 <code>&amp;Vec&lt;T&gt;</code> 类型的值作为参数传递给接受 <code>str</code> 或 <code>&amp;[T]</code> 类型的参数的函数，因为 <code>String</code> 实现了 <code>Deref&lt;Target = str&gt;</code> ，<code>Vec&lt;t&gt;</code> 实现了 <code>Deref&lt;Target = [T]&gt;</code> 。</p>
<p><code>Deref</code> 和 <code>DerefMut</code> 仅应实现于智能指针类型。最常见的误用或滥用就是，人们经常希望强行把某种面向对象编程风格的数据继承塞到 Rust 编程中。这是不可能的，因为 Rust 不是面向对象的。让我们用一个例子来领会到底为什么这是不可以的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

struct Human {
    health_points: u32,
}

enum Weapon {
    Spear,
    Axe,
    Sword,
}

// a Soldier is just a Human with a Weapon
// 士兵是手持武器的人类
struct Soldier {
    human: Human,
    weapon: Weapon,
}

impl Deref for Soldier {
    type Target = Human;
    fn deref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Mount {
    Horse,
    Donkey,
    Cow,
}

// a Knight is just a Soldier with a Mount
// 骑士是胯骑坐骑的士兵
struct Knight {
    soldier: Soldier,
    mount: Mount,
}

impl Deref for Knight {
    type Target = Soldier;
    fn deref(&amp;self) -&gt; &amp;Soldier {
        &amp;self.soldier
    }
}

enum Spell {
    MagicMissile,
    FireBolt,
    ThornWhip,
}

// a Mage is just a Human who can cast Spells
// 法师是口诵咒语的人类
struct Mage {
    human: Human,
    spells: Vec&lt;Spell&gt;,
}

impl Deref for Mage {
    type Target = Human;
    fn deref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Staff {
    Wooden,
    Metallic,
    Plastic,
}

// a Wizard is just a Mage with a Staff
// 巫师是腰别法宝的法师
struct Wizard {
    mage: Mage,
    staff: Staff,
}

impl Deref for Wizard {
    type Target = Mage;
    fn deref(&amp;self) -&gt; &amp;Mage {
        &amp;self.mage
    }
}

fn borrows_human(human: &amp;Human) {}
fn borrows_soldier(soldier: &amp;Soldier) {}
fn borrows_knight(knight: &amp;Knight) {}
fn borrows_mage(mage: &amp;Mage) {}
fn borrows_wizard(wizard: &amp;Wizard) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types can be used as Humans
    borrows_human(&amp;human);
    borrows_human(&amp;soldier);
    borrows_human(&amp;knight);
    borrows_human(&amp;mage);
    borrows_human(&amp;wizard);
    // Knights can be used as Soldiers
    borrows_soldier(&amp;soldier);
    borrows_soldier(&amp;knight);
    // Wizards can be used as Mages
    borrows_mage(&amp;mage);
    borrows_mage(&amp;wizard);
    // Knights &amp; Wizards passed as themselves
    borrows_knight(&amp;knight);
    borrows_wizard(&amp;wizard);
}
<span class="boring">}
</span></code></pre></pre>
<p>事实上，并不可以这么做。首先，强制解引用仅用于引用，所以我们不能移交属权：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_human(human: Human) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types CANNOT be used as Humans
    takes_human(human);
    takes_human(soldier); // ❌
    takes_human(knight); // ❌
    takes_human(mage); // ❌
    takes_human(wizard); // ❌
}
<span class="boring">}
</span></code></pre></pre>
<p>其次，强制解引用不可用于泛型编程。例如某特性仅对人类实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Rest {
    fn rest(&amp;self);
}

impl Rest for Human {
    fn rest(&amp;self) {}
}

fn take_rest&lt;T: Rest&gt;(rester: &amp;T) {
    rester.rest()
}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types CANNOT be used as Rest types, only Human
    take_rest(&amp;human);
    take_rest(&amp;soldier); // ❌
    take_rest(&amp;knight); // ❌
    take_rest(&amp;mage); // ❌
    take_rest(&amp;wizard); // ❌
}
<span class="boring">}
</span></code></pre></pre>
<p>强制解引用可以用于许多情况，但绝不是所有情况。例如对于算符的操作数而言就不行，即便算符仅是一种方法调用的语法糖。比如，我们希望使用 <code>+=</code> 算符来表达法师学习咒语。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DerefMut for Wizard {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Mage {
        &amp;mut self.mage
    }
}

impl AddAssign&lt;Spell&gt; for Mage {
    fn add_assign(&amp;mut self, spell: Spell) {
        self.spells.push(spell);
    }
}

fn example(mut mage: Mage, mut wizard: Wizard, spell: Spell) {
    mage += spell;
    wizard += spell; // ❌ wizard not coerced to mage here
                     // ❌ 在这里，巫师不能强制转换为法师
    wizard.add_assign(spell); // oof, we have to call it like this 🤦
                              // 所以，我们必须要这样做 🤦
}
<span class="boring">}
</span></code></pre></pre>
<p>在带有面向对象风格的数据继承的语言中，方法中的 <code>self</code> 值的类型总是等同于调用该方法的类型。但是在 Rust 语言中，<code>self</code> 值的类型总是等同于实现该方法时的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Human {
    profession: &amp;'static str,
    health_points: u32,
}

impl Human {
    // self will always be a Human here, even if we call it on a Soldier
    // 该方法中的 self 的类型永远是 Human ，即便我们在 Soldier 类型上调用
    fn state_profession(&amp;self) {
        println!(&quot;I'm a {}!&quot;, self.profession);
    }
}

struct Soldier {
    profession: &amp;'static str,
    human: Human,
    weapon: Weapon,
}

fn example(soldier: &amp;Soldier) {
    assert_eq!(&quot;servant&quot;, soldier.human.profession);
    assert_eq!(&quot;spearman&quot;, soldier.profession);
    soldier.human.state_profession(); // prints &quot;I'm a servant!&quot;
    soldier.state_profession(); // still prints &quot;I'm a servant!&quot; 🤦
}
<span class="boring">}
</span></code></pre></pre>
<p>上述特性常令人感到困惑，特别是在对新类型实现 <code>Deref</code> 和 <code>DerefMut</code> 的时候。例如我们想要设计一个 <code>SortedVec</code> 类型，相比于 <code>Vec</code> 类型，它总是处于已排序的状态。我们可能会这样做：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SortedVec&lt;T: Ord&gt;(Vec&lt;T&gt;);

impl&lt;T: Ord&gt; SortedVec&lt;T&gt; {
    fn new(mut vec: Vec&lt;T&gt;) -&gt; Self {
        vec.sort();
        SortedVec(vec)
    }
    fn push(&amp;mut self, t: T) {
        self.0.push(t);
        self.0.sort();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>显然我们不能为其实现 <code>DerefMut&lt;Target = Vec&lt;T&gt;&gt;</code> ，因为这可能会破坏排序状态。实现 <code>Deref&lt;Target = Vec&lt;T&gt;&gt;</code> 必须要保证功能的正确性。尝试指出下列代码中的 bug ：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct SortedVec&lt;T: Ord&gt;(Vec&lt;T&gt;);

impl&lt;T: Ord&gt; SortedVec&lt;T&gt; {
    fn new(mut vec: Vec&lt;T&gt;) -&gt; Self {
        vec.sort();
        SortedVec(vec)
    }
    fn push(&amp;mut self, t: T) {
        self.0.push(t);
        self.0.sort();
    }
}

impl&lt;T: Ord&gt; Deref for SortedVec&lt;T&gt; {
    type Target = Vec&lt;T&gt;;
    fn deref(&amp;self) -&gt; &amp;Vec&lt;T&gt; {
        &amp;self.0
    }
}

fn main() {
    let sorted = SortedVec::new(vec![2, 8, 6, 3]);
    sorted.push(1);
    let sortedClone = sorted.clone();
    sortedClone.push(4);
}
</code></pre></pre>
<p>鉴于我们从未对 <code>SortedVec</code> 实现 <code>Clone</code> 特性，所以当我们调用 <code>.clone()</code> 方法的时候，编译器会使用强制解引用将该方法调用解析为 <code>Vec</code> 的方法调用，所以该方法返回的是 <code>Vec</code> 而不是 <code>SortedVec</code> ！</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sorted: SortedVec&lt;i32&gt; = SortedVec::new(vec![2, 8, 6, 3]);
    sorted.push(1); // still sorted

    // calling clone on SortedVec actually returns a Vec 🤦
    let sortedClone: Vec&lt;i32&gt; = sorted.clone();
    sortedClone.push(4); // sortedClone no longer sorted 💀
}
</code></pre></pre>
<p>切记，Rust 并非设计为面向对象的语言，也并不将面向对象编程的模式作为一等公民，所以以上的限制、约束和令人困惑的特性并不被认为是在语言中是错误的。</p>
<p>本节的主旨即是使读者领会为什么不要自作聪明地实现 <code>Deref</code> 和 <code>DerefMut</code> 特性。这类特性确仅适合于智能指针类的类型，目前来讲标准库中的智能指针的实现，确需要这样的不稳定特性以及一些编译器魔法才能工作。如果我们确需要一些类似于<code>Deref</code> 和 <code>DerefMut</code> 的特性，不妨使用 <code>AsRef</code> 和 <code>AsMut</code> 特性。我们将在后面的章节中对这类特性做出说明。</p>
<h4 id="index--indexmut"><a class="header" href="#index--indexmut">Index &amp; IndexMut</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Index&lt;Idx: ?Sized&gt; {
    type Output: ?Sized;
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}

trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; where Idx: ?Sized {
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>对于实现 <code>Index&lt;T, Output = U&gt;</code> 的类型，我们可以使用 <code>[]</code> 索引算符对 <code>T</code> 类型的值索引 <code>&amp;U</code> 类型的值。作为语法糖，编译器也会为索引操作返回的值自动添加一个 <code>*</code> 解引用算符。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
    // indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
    // 鉴于 Vec&lt;i32&gt; 实现了 Index&lt;usize, Output = i32&gt;
    // 所以对 Vec&lt;i32&gt; 的索引应当返回 &amp;i32 类型的值，但是。。。
    let vec = vec![1, 2, 3, 4, 5];
    let num_ref: &amp;i32 = vec[0]; // ❌ expected &amp;i32 found i32
    
    // above line actually desugars to
    // 以上代码等价于
    let num_ref: &amp;i32 = *vec[0]; // ❌ expected &amp;i32 found i32

    // both of these alternatives work
    // 以下是建议使用的一对形式
    let num: i32 = vec[0]; // ✅
    let num_ref: &amp;i32 = &amp;vec[0]; // ✅
}
</code></pre></pre>
<p>令人困惑的是，似乎 <code>Index</code> 特性没有遵循它自己的方法签名，但其实真正有问题的是语法糖。</p>
<p>鉴于 <code>Idx</code> 是泛型类型，<code>Index</code> 特性对多个给定类型可以多次实现。并且对于 <code>Vec&lt;T&gt;</code> ，我们不仅可以对 <code>usize</code> 索引，还可以对 <code>Range&lt;usize&gt;</code> 索引得到切片。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    assert_eq!(&amp;vec[..], &amp;[1, 2, 3, 4, 5]); // ✅
    assert_eq!(&amp;vec[1..], &amp;[2, 3, 4, 5]); // ✅
    assert_eq!(&amp;vec[..4], &amp;[1, 2, 3, 4]); // ✅
    assert_eq!(&amp;vec[1..4], &amp;[2, 3, 4]); // ✅
}
</code></pre></pre>
<p>为了展示如何自己实现 <code>Index</code> 特性，以下是一个有趣的例子，它设计了一个 <code>Vec</code> 的包装结构，其使得循环索引和负数索引成为可能：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

struct WrappingIndex&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T&gt; Index&lt;usize&gt; for WrappingIndex&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        &amp;self.0[index % self.0.len()]
    }
}

impl&lt;T&gt; Index&lt;i128&gt; for WrappingIndex&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: i128) -&gt; &amp;T {
        let self_len = self.0.len() as i128;
        let idx = (((index % self_len) + self_len) % self_len) as usize;
        &amp;self.0[idx]
    }
}

#[test] // ✅
fn indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[0_usize]);
    assert_eq!(2, wrapping_vec[1_usize]);
    assert_eq!(3, wrapping_vec[2_usize]);
}

#[test] // ✅
fn wrapping_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[3_usize]);
    assert_eq!(2, wrapping_vec[4_usize]);
    assert_eq!(3, wrapping_vec[5_usize]);
}

#[test] // ✅
fn neg_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[-3_i128]);
    assert_eq!(2, wrapping_vec[-2_i128]);
    assert_eq!(3, wrapping_vec[-1_i128]);
}

#[test] // ✅
fn wrapping_neg_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[-6_i128]);
    assert_eq!(2, wrapping_vec[-5_i128]);
    assert_eq!(3, wrapping_vec[-4_i128]);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Idx</code> 的类型并不非得是数字类型或 <code>Range</code> 类型，甚至还可以是枚举！例如我们可以在一支篮球队中，对打什么位置索引从而得到队伍里打这个位置的队员：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

enum BasketballPosition {
    PointGuard,
    ShootingGuard,
    Center,
    PowerForward,
    SmallForward,
}

struct BasketballPlayer {
    name: &amp;'static str,
    position: BasketballPosition,
}

struct BasketballTeam {
    point_guard: BasketballPlayer,
    shooting_guard: BasketballPlayer,
    center: BasketballPlayer,
    power_forward: BasketballPlayer,
    small_forward: BasketballPlayer,
}

impl Index&lt;BasketballPosition&gt; for BasketballTeam {
    type Output = BasketballPlayer;
    fn index(&amp;self, position: BasketballPosition) -&gt; &amp;BasketballPlayer {
        match position {
            BasketballPosition::PointGuard =&gt; &amp;self.point_guard,
            BasketballPosition::ShootingGuard =&gt; &amp;self.shooting_guard,
            BasketballPosition::Center =&gt; &amp;self.center,
            BasketballPosition::PowerForward =&gt; &amp;self.power_forward,
            BasketballPosition::SmallForward =&gt; &amp;self.small_forward,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="drop"><a class="header" href="#drop">Drop</a></h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>对于实现 <code>Drop</code> 特性的类型，在该类型脱离作用域并销毁前，其 <code>drop</code> 方法会被调用。通常，不必为我们的类型实现这一特性，除非该类型持有某种外部的资源，且该资源需要显式释放。</p>
<p>标准库中的 <code>BufWriter</code> 类型允许我们对向 <code>Write</code> 类型写入的时候进行缓存。显然，当 <code>BufWriter</code> 销毁前应当把缓存的内容写入 <code>Writer</code> 实例，这就是 <code>Drop</code> 所允许我们做到的！对于实现了 <code>Drop</code> 的 <code>BufWriter</code> 来说，其实例在销毁前会总会调用 <code>flush</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; Drop for BufWriter&lt;W&gt; {
    fn drop(&amp;mut self) {
        self.flush_buf();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>并且，在 Rust 中 <code>Mutex</code> 类型之所以没有 <code>unlock()</code> 方法，就是因为它完全不需要！鉴于 <code>Drop</code> 特性的实现，调用 <code>Mutex</code> 的 <code>lock()</code> 方法返回的 <code>MutexGuard</code> 类型，在脱离作用域时会自动地释放 <code>Mutex</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.inner.raw_unlock();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>简而言之，如果你正在设计某种需要显示释放的资源的抽象包装，那么这正是 <code>Drop</code> 特性大显神威的地方。</p>
<h2 id="转换特性"><a class="header" href="#转换特性">转换特性</a></h2>
<h3 id="from--into"><a class="header" href="#from--into">From &amp; Into</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>From&lt;T&gt;</code> 特性的类型允许我们从 <code>T</code> 类型转换到自身的类型 <code>Self</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>Into&lt;T&gt;</code> 特性的类型允许我们从自身的类型 <code>Self</code> 转换到 <code>T</code> 类型。</p>
<p>这是一对恰好相反的特性，如同一枚硬币的两面。注意，我们只能手动实现 <code>From&lt;T&gt;</code> 特性，而不能手动实现 <code>Into&lt;T&gt;</code> 特性，因为 <code>Into&lt;T&gt;</code> 特性已经被通用泛型实现所自动实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这两个特性同时存在的一个好处在于，我们可以在为泛型类型添加约束的时候，使用两种稍有不同的记号：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T&gt;(t: T)
where
    // these bounds are equivalent
    // 以下两种记号等价
    T: From&lt;i32&gt;,
    i32: Into&lt;T&gt;
{
    // these examples are equivalent
    // 以下两种记号等价
    let example: T = T::from(0);
    let example: T = 0.into();
}
<span class="boring">}
</span></code></pre></pre>
<p>对于具体使用哪种记号并无一定之规，请根据实际情况做出最恰当的选择。接下来我们看看 <code>Point</code> 类型的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;[i32; 2]&gt; for Point {
    fn from([x, y]: [i32; 2]) -&gt; Self {
        Point { x, y }
    }
}

fn example() {
    // using From
    let origin = Point::from((0, 0));
    let origin = Point::from([0, 0]);

    // using Into
    let origin: Point = (0, 0).into();
    let origin: Point = [0, 0].into();
}
<span class="boring">}
</span></code></pre></pre>
<p>这样的转换并不是对称的，如果我们想将 <code>Point</code> 转换为元组或数组，那么我们需要显式地编写相应的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;Point&gt; for (i32, i32) {
    fn from(Point { x, y }: Point) -&gt; Self {
        (x, y)
    }
}

impl From&lt;[i32; 2]&gt; for Point {
    fn from([x, y]: [i32; 2]) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;Point&gt; for [i32; 2] {
    fn from(Point { x, y }: Point) -&gt; Self {
        [x, y]
    }
}

fn example() {
    // from (i32, i32) into Point
    let point = Point::from((0, 0));
    let point: Point = (0, 0).into();

    // from Point into (i32, i32)
    let tuple = &lt;(i32, i32)&gt;::from(point);
    let tuple: (i32, i32) = point.into();

    // from [i32; 2] into Point
    let point = Point::from([0, 0]);
    let point: Point = [0, 0].into();

    // from Point into [i32; 2]
    let array = &lt;[i32; 2]&gt;::from(point);
    let array: [i32; 2] = point.into();
}
<span class="boring">}
</span></code></pre></pre>
<p>借由 <code>From&lt;T&gt;</code> 特性，我们可以省却大量编写模板代码的麻烦。例如，我们现在具有一个包含三个 <code>Point</code> 的类型 <code>Triangle</code> 类型，以下是构造该类型的几种办法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Point {
        Point { x, y }
    }
}

struct Triangle {
    p1: Point,
    p2: Point,
    p3: Point,
}

impl Triangle {
    fn new(p1: Point, p2: Point, p3: Point) -&gt; Triangle {
        Triangle { p1, p2, p3 }
    }
}

impl&lt;P&gt; From&lt;[P; 3]&gt; for Triangle
where
    P: Into&lt;Point&gt;
{
    fn from([p1, p2, p3]: [P; 3]) -&gt; Triangle {
        Triangle {
            p1: p1.into(),
            p2: p2.into(),
            p3: p3.into(),
        }
    }
}

fn example() {
    // manual construction
    let triangle = Triangle {
        p1: Point {
            x: 0,
            y: 0,
        },
        p2: Point {
            x: 1,
            y: 1,
        },
        p3: Point {
            x: 2,
            y: 2,
        },
    };

    // using Point::new
    let triangle = Triangle {
        p1: Point::new(0, 0),
        p2: Point::new(1, 1),
        p3: Point::new(2, 2),
    };

    // using From&lt;(i32, i32)&gt; for Point
    let triangle = Triangle {
        p1: (0, 0).into(),
        p2: (1, 1).into(),
        p3: (2, 2).into(),
    };

    // using Triangle::new + From&lt;(i32, i32)&gt; for Point
    let triangle = Triangle::new(
        (0, 0).into(),
        (1, 1).into(),
        (2, 2).into(),
    );

    // using From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
    let triangle: Triangle = [
        (0, 0),
        (1, 1),
        (2, 2),
    ].into();
}
<span class="boring">}
</span></code></pre></pre>
<p>对于 <code>From&lt;T&gt;</code> 特性的使用并无一定之规，运用你的智慧明智地使用它吧！</p>
<p>使用 <code>Into&lt;T&gt;</code> 特性的一个神奇之处在于，对于那些本来只能接受特定类型参数的函数，现在你可以有更多不同的选择：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}

impl Person {
    // accepts:
    // - String
    fn new1(name: String) -&gt; Person {
        Person { name }
    }

    // accepts:
    // - String
    // - &amp;String
    // - &amp;str
    // - Box&lt;str&gt;
    // - Cow&lt;'_, str&gt;
    // - char
    // since all of the above types can be converted into String
    fn new2&lt;N: Into&lt;String&gt;&gt;(name: N) -&gt; Person {
        Person { name: name.into() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="错误处理-error-handling"><a class="header" href="#错误处理-error-handling">错误处理 Error Handling</a></h2>
<p>讲解错误处理与 <code>Error</code> 特性的最佳时机，莫过于在 <code>Display</code> ， <code>Debug</code> ， <code>Any</code> 和 <code>From</code> 之后， <code>TryFrom</code> 之前，这就是为什么我要将 <strong>错误处理</strong> 这一节硬塞在 <strong>转换特性</strong> 这一章里。</p>
<h3 id="error"><a class="header" href="#error">Error</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Error: Debug + Display {
    // provided default impls
    // 提供默认实现
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;;
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt;;
    fn description(&amp;self) -&gt; &amp;str;
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，错误是被返回的，而不是被抛出的。让我们看看下面的例子：</p>
<p>由于整数的除零操作会导致 panic ，为了程序的健壮性，我们显式地实现了安全的 <code>safe_div</code> 除法函数，它的返回值是 <code>Result</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::error;

#[derive(Debug, PartialEq)]
struct DivByZero;

impl fmt::Display for DivByZero {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;division by zero error&quot;)
    }
}

impl error::Error for DivByZero {}

fn safe_div(numerator: i32, denominator: i32) -&gt; Result&lt;i32, DivByZero&gt; {
    if denominator == 0 {
        return Err(DivByZero);
    }
    Ok(numerator / denominator)
}

#[test] // ✅
fn test_safe_div() {
    assert_eq!(safe_div(8, 2), Ok(4));
    assert_eq!(safe_div(5, 0), Err(DivByZero));
}
<span class="boring">}
</span></code></pre></pre>
<p>由于错误是被返回的，而不是被抛出的，它们必须被显式地处理。如果当前函数没有处理该错误的能力，那么该错误应当原路返回到上一级调用函数。最理想的返回错误的方法是使用 <code>?</code> 算符，它是现在已经过时的 <code>try!</code> 宏的语法糖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! try {
    ($expr:expr) =&gt; {
        match $expr {
            // if Ok just unwrap the value
            // 正常情况下直接解除 Result 的包装
            Ok(val) =&gt; val,
            // if Err map the err value using From and return
            // 否则将该错误进行适当转换后，返回到上级调用函数
            Err(err) =&gt; {
                return Err(From::from(err));
            }
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>例如，如果我们的函数其功能是将文件读为一个 <code>String</code> ，那么使用 <code>?</code> 算符来将可能的错误 <code>io::Error</code> 返回给上级调用函数就很方便：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Read;
use std::path::Path;
use std::io;
use std::fs::File;

fn read_file_to_string(path: &amp;Path) -&gt; Result&lt;String, io::Error&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error
    Ok(contents)
}
<span class="boring">}
</span></code></pre></pre>
<p>又例如，如果我们的文件是一系列数字，我们想将它们加在一起，可以这样编写代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Read;
use std::path::Path;
use std::io;
use std::fs::File;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, /* What to put here? */&gt; {
                                        // 这里填写什么类型好呢？
    let mut file = File::open(path)?; // ⬆️ io::Error
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>现在 <code>Rusult</code> 的类型又如何？该函数内部可能产生 <code>io::Error</code> 或 <code>ParseIntError</code> 两种错误。我们将介绍三种解决此类问题的方法，从最简单但不优雅的方法，到最健壮的方法：</p>
<p>方法一，我们注意到，所有实现了 <code>Error</code> 的类型同时也实现了 <code>Display</code> ，因此我们可以将错误映射到 <code>String</code> 并以此为错误类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;
use std::path::Path;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, String&gt; {
    let mut file = File::open(path)
        .map_err(|e| e.to_string())?; // ⬆️ io::Error -&gt; String
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)
        .map_err(|e| e.to_string())?; // ⬆️ io::Error -&gt; String
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()
            .map_err(|e| e.to_string())?; // ⬆️ ParseIntError -&gt; String
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>此方法的明显缺点在于，由于我们将所有的错误都序列化了，以至于丢弃了该错误的类型信息，这对于上级调用函数错误处理来讲，就不是那么方便了。</p>
<p>但此方法也有一个不明显的优点，那就是我们可以使用自定义的字符串，来提供丰富的上下文错误信息。例如，<code>ParseIntError</code> 通常序列化为 <code>&quot;invalid digit found in string&quot;</code> 这样模棱两可的文本，既没有提及无效的字符串是什么，也没有提及它要转换到什么样的数字类型。这样的信息对于我们调试程序来讲几乎没有什么帮助。不过我们可以提供更有意义的，且上下文相关的信息来明显改善这一点：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sum += line.parse::&lt;i32&gt;()
    .map_err(|_| format!(&quot;failed to parse {} into i32&quot;, line))?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The second approach takes advantage of this generic blanket impl from the standard library:</p>
</blockquote>
<p>方法二，利用标准库的通用泛型实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;E: error::Error&gt; From&lt;E&gt; for Box&lt;dyn error::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>所有实现了 <code>Error</code> 特性的类型都可以隐式地使用 <code>?</code> 转换为 <code>Box&lt;dyn error::Error&gt;</code> 类型。所以我们可以将 <code>Rusult</code> 的错误类型设为 <code>Box&lt;dyn error::Error&gt;</code> 类型，然后 <code>?</code> 算符会帮我们实现这一隐式转换。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::error;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, Box&lt;dyn error::Error&gt;&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>这看起来似乎有与第一种方法一样的缺点，丢弃了错误的类型信息。有时确实如此，但倘若上级调用函数知悉该函数的实现细节，那么它仍然可以通过 <code>error::Error</code> 特性的 <code>downcast_ref()</code> 方法来分辨错误的具体类型，这与实现了 <code>dyn Any</code> 特性的类型是一样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_sum_file_errors(path: &amp;Path) {
    match sum_file(path) {
        Ok(sum) =&gt; println!(&quot;the sum is {}&quot;, sum),
        Err(err) =&gt; {
            if let Some(e) = err.downcast_ref::&lt;io::Error&gt;() {
                // handle io::Error
            } else if let Some(e) = err.downcast_ref::&lt;ParseIntError&gt;() {
                // handle ParseIntError
            } else {
                // we know sum_file can only return one of the
                // above errors so this branch is unreachable
                // 由于我们知道该函数只能返回以上两种错误，
                // 所以这一选择肢一般是不可能执行的
                unreachable!();
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>方法三，处理错误的最健壮和类型安全的方法，是通过枚举来构建我们自己的错误类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::ParseIntError;
use std::fs::File;
use std::io;
use std::io::Read;
use std::path::Path;
use std::error;
use std::fmt;

#[derive(Debug)]
enum SumFileError {
    Io(io::Error),
    Parse(ParseIntError),
}

impl From&lt;io::Error&gt; for SumFileError {
    fn from(err: io::Error) -&gt; Self {
        SumFileError::Io(err)
    }
}

impl From&lt;ParseIntError&gt; for SumFileError {
    fn from(err: ParseIntError) -&gt; Self {
        SumFileError::Parse(err)
    }
}

impl fmt::Display for SumFileError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            SumFileError::Io(err) =&gt; write!(f, &quot;sum file error: {}&quot;, err),
            SumFileError::Parse(err) =&gt; write!(f, &quot;sum file error: {}&quot;, err),
        }
    }
}

impl error::Error for SumFileError {
    // the default impl for this method always returns None
    // but we can now override it to make it way more useful!
    // 在默认实现中，该方法总是返回 None ，现在重写它！
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        Some(match self {
            SumFileError::Io(err) =&gt; err,
            SumFileError::Parse(err) =&gt; err,
        })
    }
}

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, SumFileError&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error -&gt; SumFileError
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error -&gt; SumFileError
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError -&gt; SumFileError
    }
    Ok(sum)
}

fn handle_sum_file_errors(path: &amp;Path) {
    match sum_file(path) {
        Ok(sum) =&gt; println!(&quot;the sum is {}&quot;, sum),
        Err(SumFileError::Io(err)) =&gt; {
            // handle io::Error
        },
        Err(SumFileError::Parse(err)) =&gt; {
            // handle ParseIntError
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="转换特性深入"><a class="header" href="#转换特性深入">转换特性深入</a></h2>
<h3 id="tryfrom--tryinto"><a class="header" href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
<li><a href="#error">Error</a></li>
</ul>
<p><code>TryFrom</code> 和 <code>TryInto</code> 是可能失败版本的 <code>From</code> 和 <code>Into</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TryFrom&lt;T&gt; {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

trait TryInto&lt;T&gt; {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>与 <code>Into</code> 相似地，我们不能手动实现 <code>TryInto</code> ，因为它已经为通用泛型实现所提供。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,
{
    type Error = U::Error;

    fn try_into(self) -&gt; Result&lt;U, U::Error&gt; {
        U::try_from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>例如，我们的程序要求 <code>Point</code> 的 <code>x</code> 和 <code>y</code> 的值必须要处于 <code>-1000</code> 到 <code>1000</code> 之间，相较于 <code>From</code> ，使用 <code>TryFrom</code> 可以告知上级调用者，某些转换可能失败了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;
use std::error;
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

#[derive(Debug)]
struct OutOfBounds;

impl fmt::Display for OutOfBounds {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;out of bounds&quot;)
    }
}

impl error::Error for OutOfBounds {}

// now fallible
// TryFrom 的转换允许失败
impl TryFrom&lt;(i32, i32)&gt; for Point {
    type Error = OutOfBounds;
    fn try_from((x, y): (i32, i32)) -&gt; Result&lt;Point, OutOfBounds&gt; {
        if x.abs() &gt; 1000 || y.abs() &gt; 1000 {
            return Err(OutOfBounds);
        }
        Ok(Point { x, y })
    }
}

// still infallible
// From 的转换不允许失败
impl From&lt;Point&gt; for (i32, i32) {
    fn from(Point { x, y }: Point) -&gt; Self {
        (x, y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们对 <code>Triangle</code> 使用 <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> 进行重构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::{TryFrom, TryInto};
use std::error;
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

#[derive(Debug)]
struct OutOfBounds;

impl fmt::Display for OutOfBounds {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;out of bounds&quot;)
    }
}

impl error::Error for OutOfBounds {}

impl TryFrom&lt;(i32, i32)&gt; for Point {
    type Error = OutOfBounds;
    fn try_from((x, y): (i32, i32)) -&gt; Result&lt;Self, Self::Error&gt; {
        if x.abs() &gt; 1000 || y.abs() &gt; 1000 {
            return Err(OutOfBounds);
        }
        Ok(Point { x, y })
    }
}

struct Triangle {
    p1: Point,
    p2: Point,
    p3: Point,
}

impl&lt;P&gt; TryFrom&lt;[P; 3]&gt; for Triangle
where
    P: TryInto&lt;Point&gt;,
{
    type Error = P::Error;
    fn try_from([p1, p2, p3]: [P; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Triangle {
            p1: p1.try_into()?,
            p2: p2.try_into()?,
            p3: p3.try_into()?,
        })
    }
}

fn example() -&gt; Result&lt;Triangle, OutOfBounds&gt; {
    let t: Triangle = [(0, 0), (1, 1), (2, 2)].try_into()?;
    Ok(t)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="fromstr"><a class="header" href="#fromstr">FromStr</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#error">Error</a></li>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>FromStr</code> 特性的类型允许可失败地从 <code>&amp;str</code> 转换至 <code>Self</code> 。使用这一特性的理想方式是，调用 <code>&amp;str</code> 实例的 <code>.parse()</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;

fn example&lt;T: FromStr&gt;(s: &amp;'static str) {
    // these are all equivalent
    // 以下方法互相等价
    let t: Result&lt;T, _&gt; = FromStr::from_str(s);
    let t = T::from_str(s);
    let t: Result&lt;T, _&gt; = s.parse();
    let t = s.parse::&lt;T&gt;(); // most idiomatic
                            // 最理想的使用方式
}
<span class="boring">}
</span></code></pre></pre>
<p>下例为 <code>Point</code> 实现了 <code>FromStr</code> 特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error;
use std::fmt;
use std::iter::Enumerate;
use std::num::ParseIntError;
use std::str::{Chars, FromStr};

#[derive(Debug, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Self {
        Point { x, y }
    }
}

#[derive(Debug, PartialEq)]
struct ParsePointError;

impl fmt::Display for ParsePointError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;failed to parse point&quot;)
    }
}

impl From&lt;ParseIntError&gt; for ParsePointError {
    fn from(_e: ParseIntError) -&gt; Self {
        ParsePointError
    }
}

impl error::Error for ParsePointError {}

impl FromStr for Point {
    type Err = ParsePointError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let is_num = |(_, c): &amp;(usize, char)| matches!(c, '0'..='9' | '-');
        let isnt_num = |t: &amp;(_, _)| !is_num(t);

        let get_num =
            |char_idxs: &amp;mut Enumerate&lt;Chars&lt;'_&gt;&gt;| -&gt; Result&lt;(usize, usize), ParsePointError&gt; {
                let (start, _) = char_idxs
                    .skip_while(isnt_num)
                    .next()
                    .ok_or(ParsePointError)?;
                let (end, _) = char_idxs
                    .skip_while(is_num)
                    .next()
                    .ok_or(ParsePointError)?;
                Ok((start, end))
            };

        let mut char_idxs = s.chars().enumerate();
        let (x_start, x_end) = get_num(&amp;mut char_idxs)?;
        let (y_start, y_end) = get_num(&amp;mut char_idxs)?;

        let x = s[x_start..x_end].parse::&lt;i32&gt;()?;
        let y = s[y_start..y_end].parse::&lt;i32&gt;()?;

        Ok(Point { x, y })
    }
}

#[test] // ✅
fn pos_x_y() {
    let p = &quot;(4, 5)&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Ok(Point::new(4, 5)));
}

#[test] // ✅
fn neg_x_y() {
    let p = &quot;(-6, -2)&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Ok(Point::new(-6, -2)));
}

#[test] // ✅
fn not_a_point() {
    let p = &quot;not a point&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Err(ParsePointError));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>FromStr</code> 与 <code>TryFrom&lt;&amp;str&gt;</code> 具有相同的函数签名。先实现哪个特性无关紧要，因为我们可以利用先实现的特性实现后实现的特性。例如，我们假定 <code>Point</code> 类型已经实现了 <code>FromStr</code> 特性，再来实现 <code>TryFrom&lt;&amp;str&gt;</code> 特性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TryFrom&lt;&amp;str&gt; for Point {
    type Error = &lt;Point as FromStr&gt;::Err;
    fn try_from(s: &amp;str) -&gt; Result&lt;Point, Self::Error&gt; {
        &lt;Point as FromStr&gt;::from_str(s)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="asref--asmut"><a class="header" href="#asref--asmut">AsRef &amp; AsMut</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsRef&lt;T: ?Sized&gt; {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

trait AsMut&lt;T: ?Sized&gt; {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef</code> 特性的存在很大程度上便捷了引用转换，其最常见的使用是为函数的引用类型的参数的传入提供方便：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// accepts:
//  - &amp;str
//  - &amp;String
fn takes_str(s: &amp;str) {
    // use &amp;str
}

// accepts:
//  - &amp;str
//  - &amp;String
//  - String
fn takes_asref_str&lt;S: AsRef&lt;str&gt;&gt;(s: S) {
    let s: &amp;str = s.as_ref();
    // use &amp;str
}

fn example(slice: &amp;str, borrow: &amp;String, owned: String) {
    takes_str(slice);
    takes_str(borrow);
    takes_str(owned); // ❌
    takes_asref_str(slice);
    takes_asref_str(borrow);
    takes_asref_str(owned); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<p>另外一个常见的使用是，返回一个包装类型的内部私有数据的引用（该类型用于保证内部私有数据的不变性）。标准库中的 <code>String</code> 就是对 <code>Vec&lt;u8&gt;</code> 的这样一种包装：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>之所以不公开内部的 <code>Vec</code> 数据，是因为一旦允许用户随意修改内部数据，就有可能破环 <code>String</code> 有效的 UTF-8 编码。但是，对外开放一个只读的字节数组的引用是安全的，所以有如下实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AsRef&lt;[u8]&gt; for String;
<span class="boring">}
</span></code></pre></pre>
<p>通常来讲我们不对类型实现 <code>AsRef</code> 特性，除非该类型包装了其它类型以提供额外的功能，或是对内部类型提供了不变性的保护。</p>
<p>以下是实现 <code>AsRef</code> 特性的一个反例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    age: u32,
}

impl AsRef&lt;String&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

impl AsRef&lt;u32&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;u32 {
        &amp;self.age
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>乍看起来这似乎有几分道理，但是当我们对 <code>User</code> 类型添加新的成员时，缺点就暴露出来了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    email: String,
    age: u32,
    height: u32,
}

impl AsRef&lt;String&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;String {
        // uh, do we return name or email here?
        // 既然我们要返回一个字符串引用，那具体应该返回什么呢？
        // name 和 email 都是字符串，如何选择呢？
        // 出于返回类型的限制，似乎我们也难以返回一个混合的字符串。
    }
}

impl AsRef&lt;u32&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;u32 {
        // uh, do we return age or height here?
        // 如上同理
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>User</code> 类型由多个 <code>String</code> 和 <code>u32</code> 类型的成员所组成，但我们也不能说 <code>User</code> 是 <code>String</code> 或 <code>u32</code> 吧？即便由更加具体的类型来构造也不行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: Name,
    email: Email,
    age: Age,
    height: Height,
}
<span class="boring">}
</span></code></pre></pre>
<p>对于 <code>User</code> 这样的类型来讲，实现 <code>AsRef</code> 特性并没有什么太多意义。因为 <code>AsRef</code> 的存在仅是为了做一种最简单的引用转换，这种转换最好存在于语义上相类似的事务之间。<code>Name</code>，<code>Email</code>，<code>Age</code> 和 <code>Height</code> 其本身和 <code>User</code> 就不是一回事，在逻辑上谈不上转换。</p>
<p>下例展示了 <code>AsRef</code> 特性的正确用法，我们实现了一个新的类型 <code>Moderator</code>，它仅仅是包装了 <code>User</code> 类型，并对其添加了权限控制：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    age: u32,
}

// unfortunately the standard library cannot provide
// a generic blanket impl to save us from this boilerplate
// 不幸的是，标准库并没有提供相应的通用泛型实现，我们不得不手动实现
impl AsRef&lt;User&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;User {
        self
    }
}

enum Privilege {
    BanUsers,
    EditPosts,
    DeletePosts,
}

// although Moderators have some special
// privileges they are still regular Users
// and should be able to do all the same stuff
// 尽管主持人类具有一些特殊的权限，
// 但其仍然是普通的用户
// 所有用户类能做到的主持人类也应能做到
struct Moderator {
    user: User,
    privileges: Vec&lt;Privilege&gt;
}

impl AsRef&lt;Moderator&gt; for Moderator {
    fn as_ref(&amp;self) -&gt; &amp;Moderator {
        self
    }
}

impl AsRef&lt;User&gt; for Moderator {
    fn as_ref(&amp;self) -&gt; &amp;User {
        &amp;self.user
    }
}

// this should be callable with Users
// and Moderators (who are also Users)
// 这个函数的参数可以是 User 也可以是 Moderator
// （ Moderator 也是 User ）
fn create_post&lt;U: AsRef&lt;User&gt;&gt;(u: U) {
    let user = u.as_ref();
    // etc
}

fn example(user: User, moderator: Moderator) {
    create_post(&amp;user);
    create_post(&amp;moderator); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<p>之所以可以这样做，是因为 <code>Moderator</code> 就是 <code>User</code> 。下例是将 <code>Deref</code> 一节中的例子使用 <code>AsRef</code> 做出替代：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::AsRef;

struct Human {
    health_points: u32,
}

impl AsRef&lt;Human&gt; for Human {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        self
    }
}

enum Weapon {
    Spear,
    Axe,
    Sword,
}

// a Soldier is just a Human with a Weapon
// 士兵是手持武器的人类
struct Soldier {
    human: Human,
    weapon: Weapon,
}

impl AsRef&lt;Soldier&gt; for Soldier {
    fn as_ref(&amp;self) -&gt; &amp;Soldier {
        self
    }
}

impl AsRef&lt;Human&gt; for Soldier {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Mount {
    Horse,
    Donkey,
    Cow,
}

// a Knight is just a Soldier with a Mount
// 骑士是胯骑坐骑的士兵
struct Knight {
    soldier: Soldier,
    mount: Mount,
}

impl AsRef&lt;Knight&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Knight {
        self
    }
}

impl AsRef&lt;Soldier&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Soldier {
        &amp;self.soldier
    }
}

impl AsRef&lt;Human&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.soldier.human
    }
}

enum Spell {
    MagicMissile,
    FireBolt,
    ThornWhip,
}

// a Mage is just a Human who can cast Spells
// 法师是口诵咒语的人类
struct Mage {
    human: Human,
    spells: Vec&lt;Spell&gt;,
}

impl AsRef&lt;Mage&gt; for Mage {
    fn as_ref(&amp;self) -&gt; &amp;Mage {
        self
    }
}

impl AsRef&lt;Human&gt; for Mage {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Staff {
    Wooden,
    Metallic,
    Plastic,
}

// a Wizard is just a Mage with a Staff
// 巫师是腰别法宝的法师
struct Wizard {
    mage: Mage,
    staff: Staff,
}

impl AsRef&lt;Wizard&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Wizard {
        self
    }
}

impl AsRef&lt;Mage&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Mage {
        &amp;self.mage
    }
}

impl AsRef&lt;Human&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.mage.human
    }
}

fn borrows_human&lt;H: AsRef&lt;Human&gt;&gt;(human: H) {}
fn borrows_soldier&lt;S: AsRef&lt;Soldier&gt;&gt;(soldier: S) {}
fn borrows_knight&lt;K: AsRef&lt;Knight&gt;&gt;(knight: K) {}
fn borrows_mage&lt;M: AsRef&lt;Mage&gt;&gt;(mage: M) {}
fn borrows_wizard&lt;W: AsRef&lt;Wizard&gt;&gt;(wizard: W) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types can be used as Humans
    borrows_human(&amp;human);
    borrows_human(&amp;soldier);
    borrows_human(&amp;knight);
    borrows_human(&amp;mage);
    borrows_human(&amp;wizard);
    // Knights can be used as Soldiers
    borrows_soldier(&amp;soldier);
    borrows_soldier(&amp;knight);
    // Wizards can be used as Mages
    borrows_mage(&amp;mage);
    borrows_mage(&amp;wizard);
    // Knights &amp; Wizards passed as themselves
    borrows_knight(&amp;knight);
    borrows_wizard(&amp;wizard);
}
<span class="boring">}
</span></code></pre></pre>
<p>之所以 <code>Deref</code> 在上例之前的版本中不可使用，是因为自动解引用是一种隐式的转换，这就为程序员错误地使用留下了巨大的空间。</p>
<p>而 <code>AsRef</code> 在上例中可以使用，是因为其实现的转换是显式的，这样很大程度上就消除了犯错误的空间。</p>
<h3 id="borrow--borrowmut"><a class="header" href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Borrow&lt;Borrowed&gt; 
where
    Borrowed: ?Sized, 
{
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}

trait BorrowMut&lt;Borrowed&gt;: Borrow&lt;Borrowed&gt; 
where
    Borrowed: ?Sized, 
{
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed;
}
<span class="boring">}
</span></code></pre></pre>
<p>这类特性存在的意义旨在于解决特定领域的问题，例如在 <code>Hashset</code>，<code>HashMap</code>，<code>BTreeSet</code>，<code>BtreeMap</code> 中使用 <code>&amp;str</code> 查询 <code>String</code> 类型的键。</p>
<p>我们可以将 <code>Borrow&lt;T&gt;</code> 和 <code>BorrowMut&lt;T&gt;</code> 视作 <code>AsRef&lt;T&gt;</code> 和 <code>AsMut&lt;T&gt;</code> 的严格版本，其返回的引用 <code>&amp;T</code> 具有与 <code>Self</code> 相同的 <code>Eq</code>，<code>Hash</code> 和 <code>Ord</code> 的实现。这一点在下例的注释中得到很好的解释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::Borrow;
use std::hash::Hasher;
use std::collections::hash_map::DefaultHasher;
use std::hash::Hash;

fn get_hash&lt;T: Hash&gt;(t: T) -&gt; u64 {
    let mut hasher = DefaultHasher::new();
    t.hash(&amp;mut hasher);
    hasher.finish()
}

fn asref_example&lt;Owned, Ref&gt;(owned1: Owned, owned2: Owned)
where
    Owned: Eq + Ord + Hash + AsRef&lt;Ref&gt;,
    Ref: Eq + Ord + Hash
{
    let ref1: &amp;Ref = owned1.as_ref();
    let ref2: &amp;Ref = owned2.as_ref();
    
    // refs aren't required to be equal if owned types are equal
    // 值相等，不意味着其引用一定相等
    assert_eq!(owned1 == owned2, ref1 == ref2); // ❌
    
    let owned1_hash = get_hash(&amp;owned1);
    let owned2_hash = get_hash(&amp;owned2);
    let ref1_hash = get_hash(&amp;ref1);
    let ref2_hash = get_hash(&amp;ref2);
    
    // ref hashes aren't required to be equal if owned type hashes are equal
    // 值的哈希值相等，其引用不一定相等
    assert_eq!(owned1_hash == owned2_hash, ref1_hash == ref2_hash); // ❌
    
    // ref comparisons aren't required to match owned type comparisons
    // 值的比较，与其应用的比较没有必然联系
    assert_eq!(owned1.cmp(&amp;owned2), ref1.cmp(&amp;ref2)); // ❌
}

fn borrow_example&lt;Owned, Borrowed&gt;(owned1: Owned, owned2: Owned)
where
    Owned: Eq + Ord + Hash + Borrow&lt;Borrowed&gt;,
    Borrowed: Eq + Ord + Hash
{
    let borrow1: &amp;Borrowed = owned1.borrow();
    let borrow2: &amp;Borrowed = owned2.borrow();
    
    // borrows are required to be equal if owned types are equal
    // 值相等，借用值也必须相等
    assert_eq!(owned1 == owned2, borrow1 == borrow2); // ✅
    
    let owned1_hash = get_hash(&amp;owned1);
    let owned2_hash = get_hash(&amp;owned2);
    let borrow1_hash = get_hash(&amp;borrow1);
    let borrow2_hash = get_hash(&amp;borrow2);
    
    // borrow hashes are required to be equal if owned type hashes are equal
    // 值的哈希值相等，借用值的哈希值也必须相等
    assert_eq!(owned1_hash == owned2_hash, borrow1_hash == borrow2_hash); // ✅
    
    // borrow comparisons are required to match owned type comparisons
    // 值的比较，与借用值的比较必须步调一致
    assert_eq!(owned1.cmp(&amp;owned2), borrow1.cmp(&amp;borrow2)); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<p>理解这类特性存在的意义，有助于我们揭开 <code>HashSet</code>，<code>HashMap</code>，<code>BTreeSet</code> 和 <code>BTreeMap</code> 中某些方法的实现的神秘面纱。但是在实际应用中，几乎没有什么地方需要我们去实现这样的特性，因为再难找到一个需要我们对一个值再创造一个“借用”版本的类型的场景了。对于某种类型 <code>T</code> ，<code>&amp;T</code> 就能解决 99.9% 的问题了，且 <code>T: Borrow&lt;T&gt;</code> 已经被通用泛型实现对 <code>T</code> 实现了，所以我们无需手动实现它，也无需去实现某种的对 <code>U</code> 有 <code>T: Borrow&lt;U&gt;</code> 了。</p>
<h3 id="toowned"><a class="header" href="#toowned">ToOwned</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    fn to_owned(&amp;self) -&gt; Self::Owned;
    
    // provided default impls
    // 提供默认实现
    fn clone_into(&amp;self, target: &amp;mut Self::Owned);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ToOwned</code> 特性是 <code>Clone</code> 特性的泛型版本。 <code>Clone</code> 特性允许我们由 <code>&amp;T</code> 类型得到 <code>T</code> 类型，而 <code>ToOwned</code> 特性允许我们由 <code>&amp;Borrow</code> 类型得到 <code>Owned</code> 类型，其中 <code>Owned: Borrow&lt;Borrowed&gt;</code> 。</p>
<p>换句话讲，我们不能将 <code>&amp;str</code> 克隆为 <code>String</code>，将 <code>&amp;Path</code> 克隆为 <code>PathBuf</code> 或将 <code>&amp;OsStr</code> 克隆为 <code>OsString</code> 。鉴于 <code>clone</code> 方法的签名不支持这样跨类型的克隆，这就是 <code>ToOwned</code> 特性存在的意义。</p>
<p>与 <code>Borrow</code> 和 <code>BorrowMut</code> 相同地，理解此类特性存在的意义对我们或有帮助，但是鲜少需要我们手动为自己的类实现该特性。</p>
<h2 id="迭代特性"><a class="header" href="#迭代特性">迭代特性</a></h2>
<h3 id="iterator"><a class="header" href="#iterator">Iterator</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#default-impls">Default Impls</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // provided default impls
    // 提供默认实现
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
    fn count(self) -&gt; usize;
    fn last(self) -&gt; Option&lt;Self::Item&gt;;
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt;;
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;;
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;;
    fn chain&lt;U&gt;(
        self, 
        other: U
    ) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator&lt;Item = Self::Item&gt;;
    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator;
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; B;
    fn for_each&lt;F&gt;(self, f: F)
    where
        F: FnMut(Self::Item);
    fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt;;
    fn peekable(self) -&gt; Peekable&lt;Self&gt;;
    fn skip_while&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn map_while&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt;
    where
        P: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn skip(self, n: usize) -&gt; Skip&lt;Self&gt;;
    fn take(self, n: usize) -&gt; Take&lt;Self&gt;;
    fn scan&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt;
    where
        F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;;
    fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;
    where
        F: FnMut(Self::Item) -&gt; U,
        U: IntoIterator;
    fn flatten(self) -&gt; Flatten&lt;Self&gt;
    where
        Self::Item: IntoIterator;
    fn fuse(self) -&gt; Fuse&lt;Self&gt;;
    fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt;
    where
        F: FnMut(&amp;Self::Item);
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self;
    fn collect&lt;B&gt;(self) -&gt; B
    where
        B: FromIterator&lt;Self::Item&gt;;
    fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)
    where
        F: FnMut(&amp;Self::Item) -&gt; bool,
        B: Default + Extend&lt;Self::Item&gt;;
    fn partition_in_place&lt;'a, T, P&gt;(self, predicate: P) -&gt; usize
    where
        Self: DoubleEndedIterator&lt;Item = &amp;'a mut T&gt;,
        T: 'a,
        P: FnMut(&amp;T) -&gt; bool;
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R
    where
        F: FnMut(B, Self::Item) -&gt; R,
        R: Try&lt;Ok = B&gt;;
    fn try_for_each&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R
    where
        F: FnMut(Self::Item) -&gt; R,
        R: Try&lt;Ok = ()&gt;;
    fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, Self::Item) -&gt; B;
    fn fold_first&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(Self::Item, Self::Item) -&gt; Self::Item;
    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn try_find&lt;F, R&gt;(
        &amp;mut self, 
        f: F
    ) -&gt; Result&lt;Option&lt;Self::Item&gt;, &lt;R as Try&gt;::Error&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; R,
        R: Try&lt;Ok = bool&gt;;
    fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        Self: ExactSizeIterator + DoubleEndedIterator,
        P: FnMut(Self::Item) -&gt; bool;
    fn max(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn min(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn max_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn min_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn rev(self) -&gt; Rev&lt;Self&gt;
    where
        Self: DoubleEndedIterator;
    fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)
    where
        Self: Iterator&lt;Item = (A, B)&gt;,
        FromA: Default + Extend&lt;A&gt;,
        FromB: Default + Extend&lt;B&gt;;
    fn copied&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Copy;
    fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Clone;
    fn cycle(self) -&gt; Cycle&lt;Self&gt;
    where
        Self: Clone;
    fn sum&lt;S&gt;(self) -&gt; S
    where
        S: Sum&lt;Self::Item&gt;;
    fn product&lt;P&gt;(self) -&gt; P
    where
        P: Product&lt;Self::Item&gt;;
    fn cmp&lt;I&gt;(self, other: I) -&gt; Ordering
    where
        I: IntoIterator&lt;Item = Self::Item&gt;,
        Self::Item: Ord;
    fn cmp_by&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Ordering
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering,
        I: IntoIterator;
    fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn partial_cmp_by&lt;I, F&gt;(
        self, 
        other: I, 
        partial_cmp: F
    ) -&gt; Option&lt;Ordering&gt;
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,
        I: IntoIterator;
    fn eq&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn eq_by&lt;I, F&gt;(self, other: I, eq: F) -&gt; bool
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool,
        I: IntoIterator;
    fn ne&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn lt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn le&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn gt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn ge&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn is_sorted(self) -&gt; bool
    where
        Self::Item: PartialOrd&lt;Self::Item&gt;;
    fn is_sorted_by&lt;F&gt;(self, compare: F) -&gt; bool
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Option&lt;Ordering&gt;;
    fn is_sorted_by_key&lt;F, K&gt;(self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; K,
        K: PartialOrd&lt;K&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现 <code>Iterator&lt;Item = T&gt;</code> 的类型可以迭代产生 <code>T</code> 类型。注意：并不存在 <code>IteratorMut</code> 类型，因为可以通过在实现 <code>Iterator</code> 特性时指定 <code>Item</code> 关联类型，来选择其返回的是不可变引用、可变引用还是自有值。</p>
<table><thead><tr><th><code>Vec&lt;T&gt;</code> 方法</th><th>返回类型</th></tr></thead><tbody>
<tr><td><code>.iter()</code></td><td><code>Iterator&lt;Item = &amp;T&gt;</code></td></tr>
<tr><td><code>.iter_mut()</code></td><td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td></tr>
<tr><td><code>.into_iter()</code></td><td><code>Iterator&lt;Item = T&gt;</code></td></tr>
</tbody></table>
<p>对于 Rust 的初学者而言可能有些费解，但是对于中级学习者而言则是顺理成章的一件事是 —— 绝大多数类型并不是自己的迭代器。这意味着，如果某种类型是可迭代的，那么应当实现某种额外的迭代器类型去迭代它，而不是让它自己迭代自己。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType {
    items: Vec&lt;String&gt;
}

impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        MyTypeIterator {
            index: 0,
            items: &amp;self.items
        }
    }
}

struct MyTypeIterator&lt;'a&gt; {
    index: usize,
    items: &amp;'a Vec&lt;String&gt;
}

impl&lt;'a&gt; Iterator for MyTypeIterator&lt;'a&gt; {
    type Item = &amp;'a String;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.index &gt;= self.items.len() {
            None
        } else {
            let item = &amp;self.items[self.index];
            self.index += 1;
            Some(item)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>出于教学的原因，我们在上例中从头手动实现了一个迭代器。而在这种情况下，最理想的做法是直接调用 <code>Vec</code> 的 <code>iter</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType {
    items: Vec&lt;String&gt;
}

impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        self.items.iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>另外，最好了解这个通用泛型实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;I: Iterator + ?Sized&gt; Iterator for &amp;mut I;
<span class="boring">}
</span></code></pre></pre>
<p>任何迭代器的可变引用也是一个迭代器。了解这样的性质有助于我们理解，为什么可以将迭代器的某些参数为 <code>self</code> 的方法当作具有 <code>&amp;mut self</code> 参数的方法来使用。</p>
<p>举个例子，想象我们有这样一个函数，它处理一个具有三个以上值的迭代器，这个函数首先要取得该迭代器的前三个值并分别地处理他们，然后再依次迭代剩余的值。初学者可能会这样实现该函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.take(3).collect();
    for item in iter { // ❌ iter consumed in line above
                       // ❌ iter 在上一行就已经被消耗掉了
        // process remaining items
        // 处理剩余的值
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>糟糕，<code>take</code> 方法具有 <code>self</code> 参数，这意味着我们不能在不消耗掉整个迭代器的前提下调用该方法。以下可能是一个初学者的改进：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = vec![
        iter.next().unwrap(),
        iter.next().unwrap(),
        iter.next().unwrap(),
    ];
    for item in iter { // ✅
        // process remaining items
        // 处理剩余的值
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这是可行的，但是理想的改进方式莫过于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.by_ref().take(3).collect();
    for item in iter { // ✅
        // process remaining items
        // 处理剩余的值
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这真是一个很隐蔽的方法，但是被我们抓到了。</p>
<p>同样，对于什么可以是迭代器，什么不可以是，并无一定之规。实现了 <code>Iterator</code> 特性的就是迭代器。而在标准库中，确有一些具有创造性的用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;
use std::thread;

fn paths_can_be_iterated(path: &amp;Path) {
    for part in path {
        // iterate over parts of a path
        // 迭代 path 的不同部分
    }
}

fn receivers_can_be_iterated() {
    let (send, recv) = channel();

    thread::spawn(move || {
        send.send(1).unwrap();
        send.send(2).unwrap();
        send.send(3).unwrap();
    });

    for received in recv {
        // iterate over received values
        // 迭代接收到的值
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="intoiterator"><a class="header" href="#intoiterator">IntoIterator</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator 
where
    &lt;Self::IntoIter as Iterator&gt;::Item == Self::Item, 
{
    type Item;
    type IntoIter: Iterator;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>闻弦歌而知雅意，实现 <code>IntoIterator</code> 特性的类型可以被转换为迭代器。当用于 <code>for-in</code> 循环时，将自动调用该类型的 <code>into_iter</code> 方法.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vec = Vec&lt;T&gt;
for v in vec {} // v = T

// above line desugared
// 以上代码等价于
for v in vec.into_iter() {}
<span class="boring">}
</span></code></pre></pre>
<p>不仅 <code>Vec</code> 实现了 <code>IntoIterator</code> 特性，<code>&amp;Vec</code> 与 <code>&amp;mut Vec</code> 同样如此。因此我们可以相应的对可变与不可变的引用，以及自有值进行迭代。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vec = Vec&lt;T&gt;
for v in &amp;vec {} // v = &amp;T

// above example desugared
// 以上代码等价于
for v in (&amp;vec).into_iter() {}

// vec = Vec&lt;T&gt;
for v in &amp;mut vec {} // v = &amp;mut T

// above example desugared
// 以上代码等价于
for v in (&amp;mut vec).into_iter() {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="fromiterator"><a class="header" href="#fromiterator">FromIterator</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromIterator&lt;A&gt; {
    fn from_iter&lt;T&gt;(iter: T) -&gt; Self
    where
        T: IntoIterator&lt;Item = A&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>顾叶落而晓秋至，实现 <code>FromIterator</code> 特性的类型可以由迭代器而构造。<code>FromIterator</code> 特性最常见和最理想的使用方法是调用 <code>Iterator</code> 的 <code>collect</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>下例展示了如何将 <code>Iterator&lt;Item = char&gt;</code> 迭代器的值收集为 <code>String</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_letters(string: &amp;str) -&gt; String {
    string.chars().filter(|c| c.is_alphabetic()).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>标准库中的全部集合类型都实现了 <code>IntoIterator</code> 和 <code>FromIterator</code> 特性，所以在它们之间进行转换是很方便的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{BTreeSet, HashMap, HashSet, LinkedList};

// String -&gt; HashSet&lt;char&gt;
fn unique_chars(string: &amp;str) -&gt; HashSet&lt;char&gt; {
    string.chars().collect()
}

// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
fn ordered_unique_items&lt;T: Ord&gt;(vec: Vec&lt;T&gt;) -&gt; BTreeSet&lt;T&gt; {
    vec.into_iter().collect()
}

// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
fn entry_list&lt;K, V&gt;(map: HashMap&lt;K, V&gt;) -&gt; LinkedList&lt;(K, V)&gt; {
    map.into_iter().collect()
}

// and countless more possible examples
// 还有数不胜数的例子
<span class="boring">}
</span></code></pre></pre>
<h2 id="输入输出特性-io-traits"><a class="header" href="#输入输出特性-io-traits">输入输出特性 I/O Traits</a></h2>
<h3 id="read--write"><a class="header" href="#read--write">Read &amp; Write</a></h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    // provided default impls
    // 提供默认实现
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    unsafe fn initializer(&amp;self) -&gt; Initializer;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;;
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;;
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized;
    fn bytes(self) -&gt; Bytes&lt;Self&gt;
    where
        Self: Sized;
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
    where
        Self: Sized;
    fn take(self, limit: u64) -&gt; Take&lt;Self&gt;
    where
        Self: Sized;
}

trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    // provided default impls
    // 提供默认实现
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt;;
    fn is_write_vectored(&amp;self) -&gt; bool;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt;;
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Generic blanket impls worth knowing:</p>
</blockquote>
<p>值得关注的通用泛型实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;R: Read + ?Sized&gt; Read for &amp;mut R;
impl&lt;W: Write + ?Sized&gt; Write for &amp;mut W;
<span class="boring">}
</span></code></pre></pre>
<p>对于任何实现了 <code>Read</code> 特性的类型，其可变的引用类型也实现了 <code>Read</code> 特性。<code>Write</code> 也是如此。知晓这一点有助于我们理解为什么，对于具有 <code>self</code> 参数的函数可以如同那些具有 <code>&amp;mut self</code> 参数的函数一般使用。鉴于我们已经在 <code>Iterator</code> 特性一节中做出了相近的说明，对此我不再赘述。</p>
<p>我特别指出的是，在 <code>&amp;[u8]</code> 实现 <code>Read</code> 的同时，<code>Vec&lt;u8&gt;</code> 实现了 <code>Write</code>，因此我们可以很方便地使用 <code>String</code> 来对我们的文件处理函数进行单元测试，因为它可以轻易地转换到 <code>&amp;[u8]</code> 和转换自 <code>Vec&lt;u8&gt;</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::io;

// function we want to test
// 欲要测试此函数
fn uppercase&lt;R: Read, W: Write&gt;(mut read: R, mut write: W) -&gt; Result&lt;(), io::Error&gt; {
    let mut buffer = String::new();
    read.read_to_string(&amp;mut buffer)?;
    let uppercase = buffer.to_uppercase();
    write.write_all(uppercase.as_bytes())?;
    write.flush()?;
    Ok(())
}

// in actual program we'd pass Files
// 实际使用中我们传入文件
fn example(in_path: &amp;Path, out_path: &amp;Path) -&gt; Result&lt;(), io::Error&gt; {
    let in_file = File::open(in_path)?;
    let out_file = File::open(out_path)?;
    uppercase(in_file, out_file)
}

// however in unit tests we can use Strings!
// 但是在单元测试中我们使用 String !
#[test] // ✅
fn example_test() {
    let in_file: String = &quot;i am screaming&quot;.into();
    let mut out_file: Vec&lt;u8&gt; = Vec::new();
    uppercase(in_file.as_bytes(), &amp;mut out_file).unwrap();
    let out_result = String::from_utf8(out_file).unwrap();
    assert_eq!(out_result, &quot;I AM SCREAMING&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="结语-conclusion"><a class="header" href="#结语-conclusion">结语 Conclusion</a></h2>
<blockquote>
<p>We learned a lot together! Too much in fact. This is us now:</p>
</blockquote>
<p>我们真是学习了太多！太多了！可能这就是我们现在的样子：</p>
<p><img src="../../../assets/jason-jarvis-stdlib-traits.png" alt="rust standard library traits" /></p>
<p><em>该漫画的创作者: <a href="https://thejenkinscomic.wordpress.com/2020/05/06/memory/">The Jenkins Comic</a></em></p>
<h2 id="讨论-discuss"><a class="header" href="#讨论-discuss">讨论 Discuss</a></h2>
<blockquote>
<p>Discuss this article on</p>
</blockquote>
<p>可以在如下地点讨论本文</p>
<ul>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/ml9shl/tour_of_rusts_standard_library_traits/">learnrust subreddit</a></li>
<li><a href="https://users.rust-lang.org/t/blog-post-tour-of-rusts-standard-library-traits/57974">official Rust users forum</a></li>
<li><a href="https://twitter.com/pretzelhammer/status/1379561720176336902">Twitter</a></li>
<li><a href="https://lobste.rs/s/g27ezp/tour_rust_s_standard_library_traits">lobste.rs</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/mmrao0/tour_of_rusts_standard_library_traits/">rust subreddit</a></li>
</ul>
<h2 id="通告-notifications"><a class="header" href="#通告-notifications">通告 Notifications</a></h2>
<blockquote>
<p>Get notified when the next blog post get published by</p>
</blockquote>
<p>在如下处得知我下一篇博文的详情</p>
<ul>
<li><a href="https://twitter.com/pretzelhammer">订阅我的推特 pretzelhammer</a> 或者</li>
<li>订阅这个 repo (点击 <code>Watch</code> -&gt; 点击 <code>Custom</code> -&gt; 选择 <code>Releases</code> -&gt; 点击 <code>Apply</code>)</li>
</ul>
<h2 id="更多资料-further-reading"><a class="header" href="#更多资料-further-reading">更多资料 Further Reading</a></h2>
<ul>
<li><a href="../../sizedness-in-rust.html">Sizedness in Rust</a></li>
<li><a href="./common-rust-lifetime-misconceptions.html">Common Rust Lifetime Misconceptions</a></li>
<li><a href="../../learning-rust-in-2020.html">Learning Rust in 2020</a></li>
<li><a href="../../too-many-brainfuck-compilers.html">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
<h2 id="翻译-translation"><a class="header" href="#翻译-translation">翻译 Translation</a></h2>
<p>鉴于水平所限，</p>
<p>难免出现翻译错误，</p>
<p>如发现错误还请告知！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../lang/rust/09-Rust异步执行器.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../lang/rust/11-Rust中的宏:带有示例的教程.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../lang/rust/09-Rust异步执行器.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../lang/rust/11-Rust中的宏:带有示例的教程.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../theme/ferris.js"></script>
        

        

    </body>
</html>
